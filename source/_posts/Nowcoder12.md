---
title: 牛客网OJ题解--20210210
comments: false
top: false
date: 2021-02-10 13:50:31
tags: [算法,C++]
categories: 
	- [刷题日志]
---

本系列记录翀翀😐痛苦的刷题日志，所有题目均来自于牛客网OJ题目，坚持刷题谈起来容易做起来难，希望我可以坚持下去，这里仍然分享一段励志文案：每个人都有梦想，然而有些人把梦想变成了现实，有些人的梦想依旧是梦想，只因为他们为梦想付出的努力程度不一样，他们坚持的时间不一样，最终才有这样的结果。

<!-- more -->

### NC22169-回文对称数

#### 题目链接

https://ac.nowcoder.com/acm/problem/22169

#### 题目描述

今天牛牛学到了回文串，他想在数字里面找回文，即回文数，回文数是正着读与倒着读都一样的数，比如1221，343是回文数，433不是回文数。请输出不超过n的回文数。输入就是给出一个n，检验1~n中的回文对称数。

#### 测试样例

输入

```c
10
```

输出

```c
1
2
3
4
5
6
7
8
9
```

#### 解题思路

对于3435，我们逐位取余10，然后再乘10，这样就得到了另一个数5343，如果这个新的数和之前的数一样，那么就是回文对称数。说白了就是用之前数的数尾作为数首，数首作为数尾，如果倒戈以后还是一样的数就是回文对称数，比如52125，那么结果就是52125。

#### 解题代码

```c
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n, tmp, num;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        tmp = 0;
        num = i;
        //将tmp按照数i的从后到前写一遍
        while (num != 0)
        {
            tmp *= 10;
            tmp += num % 10;
            num /= 10;
        }
        //如果一样，那么就是回文数
        if (tmp == i)
        {
            cout << i << endl;
        }
    }
    return 0;
    system("pause");
    return 0;
}
```

### NC21579-牛牛学括号

#### 题目链接

https://ac.nowcoder.com/acm/problem/21579

#### 题目描述

牛牛最近在学习括号匹配问题给你一个合法的括号序列，每次操作分两步，第一步删除第一个左括号，第二步删除某一个右括号，要保证删除之后的括号序列还是合法的,求将括号删到空为止一共有多少种不同的删除方法，两种方法不同当且仅当存在某一步右括号的删除位置不同，答案膜1e9+7。

#### 测试样例

##### 样例1

输入

```c
()()()()()
```

输出

```
1
```

##### 样例2

输入

```c
(((())))
```

输出

```c
24
```

##### 样例3

输入

```c
((()))(()(()))((()))
```

输出

```c
432
```

#### 解题思路

因为是合法的序列，所以第一个一定是左括号，对于后面我们定义如下规则，如果是左括号就放到栈中，如果是右括号就可以和此时栈中的任意一个左括号相抵消，所以可以任选一个左括号，所以定义sum初始化为1，每次遇到右括号sum就乘以此时栈中左括号的数量即栈的大小，最后不要忘记pop一个左括号，因为右括号抵消了一个左括号所以左括号数量要减少一个。

#### 解题代码

```c
#include <bits/stdc++.h>
using namespace std;

const int mod = 1e9 + 7;

int main()
{
    //以字符串形式存入
    char s[2505];
    //结果初始化为1
    int sum = 1;
    cin >> s;
    //声明一个栈p
    stack<char> p;
    //先放入一个左括号
    p.push(s[0]);
    //剩下的位置进行检验
    for (int i = 1; i < strlen(s); i++)
    {
        //如果是左括号就加入栈中
        if (s[i] == '(')
        {
            p.push(s[i]);
        }
        else
        {
            //如果是右括号，那么他可以与栈中的任意一个左括号相抵消，所以可选择的方法数就是此时栈中左括号的数量
            sum = (sum * p.size()) % mod;
            //因为抵消了一个左括号，所以栈中弹出一个左括号，数量减一
            p.pop();
        }
    }
    cout << sum << endl;
    system("pause");
    return 0;
}
```



