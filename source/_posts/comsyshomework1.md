---
title: 计算机系统基础大作业--nemu(pa1)编写
comments: false
top: false
date: 2020-10-22 10:06:20
tags: [计算机系统基础,C++,大作业,nemu,pa1,linux]
categories: 
	- [项目总结,计算机系统大作业]
headimg: https://gitee.com/Langwenchong/figure-bed/raw/master/20210704162954.png
---

### 作业要求

本次实验包含如下三个阶段：
阶段1: 实现“单步、打印寄存器状态、扫描内存”三个调试功能
阶段2: 实现调试功能的表达式求值
阶段3: 实现监视点

实验介绍手册下载链接：https://pan.baidu.com/s/1Arf3odVy7uxU2wklXtDGXA 
提取码：h4yb 

<!-- more -->

### 📝任务自查表

|   序号    | 是否已完成 |
| :-------: | :--------: |
| 必做任务1 |     是     |
| 必做任务2 |     是     |
| 必做任务3 |     是     |
| 选做任务1 |     是     |
| 选做任务2 |     是     |

### 解题思路

进入实验之前首先要解决cpu的结构构建,这里打开了reg.h文件,对cpu结构体的定义进行了修改,如下图 ![](https://pic.downk.cc/item/5f91931f1cd1bbb86bc6070c.jpg) 相比开始的结构体的定义,我将struct改为union来定义gpr,因为一个寄存器会同时有多个别名他们分别表示32位16位或者8位,但是这几个会同时享有一个地址空间,而struct会将其各自分配一个内存空间,这显然与cpu结构相悖,而union联合体则是为其分配一个共用内存单元,空间大些取决于这几个中的最大值,所以与cpu结构相似,改用union完美解决问题进入pa1.

#### pa1.1

首先查看手册的对命令行输入格式规定要求,然后进入解题,读源代码并观察知道在ui.c中要补充help中的其他命令功能,每一个对象中会先声明命令参数,然后加入描述性文本行,最后一行应该是会调用uic中定义的cmd函数(需要自己补充),如下图: ![](https://pic.downk.cc/item/5f91934a1cd1bbb86bc613f5.jpg)

##### (1)单步执行

思路简单,就是传入命令并赋值给args然后调用已经写好的cmd\*si函数,其中需要注意首先要切割args来获取字符型的数字,然后通过atoi函数强制转换成整型数字,最后在将参数传给cpu*exec即完成单步执行相应的步数,这里会学到一个新的函数叫strtok()笔记中已记录详细内容.

##### (2)打印寄存器

也挺简单,没用循环,纯暴力printf输出就完事,同样还是得先切割一下字符获取相应的参数,但是这里要注意后面的w是表示打印断点信息的,所以这里要对参数进行判断,用来strcmp()函数来进行判断,输出的信息就是reg.h定义的cpu结构体所带的八个寄存器成员

##### (3)扫描内存

思路较为清晰,首先就是要获取第一个参数一个字符型数字代表输出的函数,用到了atoi()函数强制转换,然后在用strtok()获取第二个参数(这里有一个小知识点笔记记录了)转换为16进制数是一个开始地址,然后通过swaddr_read(手册里提示提供这个函数来扫描内存),并且这里要注意是每次四个字节输出,地址每循环访问一次要进行+4来访问下一个,当然还有一个小技巧,输出信息的时候未必都是刚好可以用2个16进制数来表示,进行与0xff与运算的结果则可以刚好是输出对齐(大概是进位约数l?).还有一个坑:gcc版本限制,这里所有for循环的第一个局部变量定义不支持,一定要在外部定义,否则make时会报错.当然还有为了保证严谨性,在每一个函数切割字符串进行参数传递时都可以加入参量个数判断,或多或少都不可以,是函数更完整.

#### pa1.2

任务目的主要是完成表达式的计算,但是要注意的是传进来的表达式是字符串形式需要将数字转换为整数形式,其次,还要注意要添加相应的规则对每一个字符标注其类型为后面操作做准备(也就是比做任务3的要求),这里要用到正则表达式匹配类型,然后在进行计算,计算时首先要考虑表达式括号个数是否正确(即使不是一个正确的表达式),若正确,那么在进行切割,切割成多个小表达式计算,所以要写一个新函数来判断哪些符号最后进行计算,并且为每一个计算元类型标注权重,权重越大,计算越靠前(这里参考C语言计算规则就好),然后最后在对每一个具体的小表达式进行计算(一般是两个相加减乘除,但是也有去寄存器数值或者单个数字加负号或取反等操作),最后通过递归把每一个小表达式结果再次计算直至得到正确结果为止. 多次测验应该有以下几种类型:整型number,十六进制数hnumber,指针pointer,寄存器register,加(plus)减(subs)乘(mult)除(div)符号,空格(spaces),tab键(tab),取反(!),相与(&),相或(|),相等,不等,左括,右括,,其中空格与tap键都是notype类型,不参与计算.把上述类型填写在规定的区域rules中. ![](https://pic.downk.cc/item/5f9193671cd1bbb86bc61d80.jpg) 并且在rule的结构体定义中新增priority权重,并且在后面定义token中也补充priority权重. 然后就是在规定位置补充进行对每一个成员的类型进行判断,如下图: ![](https://pic.downk.cc/item/5f9193921cd1bbb86bc62a7e.jpg) 但是这里要注意要特殊处理寄存器,因为寄存器前面有个特殊符号,为了后面操作方便,只取其第一位开始往后取,这里会用到strncpy函数(笔记已记录),然后把相应的类型,权重,表达式切割串传入token数组中,并且一定要记住在strncpy后面加上'\0',因为strncpy函数不会自动加上终止符,需要人为手动添加,并且在判断完后要记住position不是加1,而是根据元成员的长度加上相应的长度…至此,比做任务3就大致完成了. 然后按顺序进行递归求职函数的编写,但是这里先讲解选做任务判断指针和负数形式,其实思路也很简单,当看到\*号时,如果前面不是数字型成员,那么这个位置的*很明显是一个解引用的指针,所以要特殊标记将其类型改为指针pointer类型,至于负数那也是一样,如果这个'-'前面是一个符号而不是数字,那么这个位置代表的应该是负数,也要进行特殊处理标记改为负数,当然权重也是要改的,自此,全部rule标注成员类型任务大体上就完成了. 然后就是递归计算了,在计算前先讲解几个重要函数,第一个就是检验表达式是否正确,即左右括号是否配对,这里用递归函数来逐一检验,函数大致如下: ![](https://pic.downk.cc/item/5f9193bb1cd1bbb86bc637cd.jpg) 即只有最左侧是左括号且最右侧也是一个右括号时才是可能正确的,此时在进行进一步检验,如果第一步都不对即出现了两边都是左括或右括那就直接返回false表达式错误不能计算,如果是正确的,那么就检验里面的左右括号是否配对,这里进行数量检验即可,因为当再次递归调用此函数时就会判断p+1以后的第一个括号,和q-1处之前的括号是否是一左一右的形式检验.所以里面定义两个参量lc,rc表示左括号数量与右括号数量,每次匹配到就++,最后比较是否相等,如果不等,那么就是有一个括号多了,直接返回false,表达式错误,反之这次检验正确返回true.通过这个函数可以首先对大量的表达式尤其是复杂的计算表达式进行筛选,如果表达式错误,则不用进行复杂的计算了,直接返回错误即可. 然后就是第二个寻找主符号函数,这里大致思路就是 ![](https://pic.downk.cc/item/5f9193d51cd1bbb86bc64192.jpg) 要找到每次最后进行计算的符号位,所以权重肯定是越来越小的,所以定义一个最大权重为这里大于9都可以,然后最后计算为肯定得是符号,所以把所有数值成员全部排除掉,然后再看符号是否在括号里,括号里的肯定是优先计算的,所以也排除,最后剩下的权重最小的符号就是主符号位了,返回这个location值即可.自此计算前的准备已经完成,开始进行递归计算. ![](https://pic.downk.cc/item/5f9193fe1cd1bbb86bc64e7d.jpg) 当左端p>右端q时出错了,表达式不存在,当p==q时就有可能是只输入了一个数或16进制数,或者是一个寄存器就存储了一个数,这种情况,就直接返还数值即可,当然这里寄存器要特别注意区分是哪一类寄存器进行长度判断,然后去特定的寄存器读取数值,记住要对寄存器类型进行判断,如果不存在则返回错误. 然后就是对含括号的各种小表达式进行递归求值了.如下图:

 ![](https://pic.downk.cc/item/5f92baf41cd1bbb86bfd0e74.jpg) 

最后就是返还相应的加减乘除等操作的结果即可.自此选做任务和1.2就大体完成了,如果有小bug在进行完善,因为测试数据有限,代码可能会有小问题(反正我测得都对…)

#### pa1.3

任务就是打断点,模仿gdb,然后还可以删除断点,具体思路入下,首先文档里给了两个函数定义,一个是初始化new\*wp()和释放free\*pool(WP \*wp).新建池new\*wp()函数很好写 ![](https://pic.downk.cc/item/5f9194261cd1bbb86bc65caf.jpg) 就是要从free链表头部拿取节点,如果free为空就Assert(0);与之相反,free\*wp就是把节点返还给free链表但是当free为空时,free\*wp即可了.print*wp()是自己要写的函数,就是从头遍历一遍整个链表并打印相关信息,这里要修改结构体加入存值value和expr[32]来存储相关表达式的信息以便输出,然后delete就是删除操作了,释放空间,其中还有一个重要的函数check函数来监视值是否发生了变化,当发生了变化就要输出新值和旧值,当然写完后要插入到exec.c文件中指定位置,在每次执行后会先进入check进行判断,当然这其中最难也是最易忽视的地方是,手写的函数都是未定义的函数,直接在ui.C中引用会报错未定义,记住要现在watchpoint.h文件中声明函数,还有就是貌似exec.c中没有引入相关文件会导致直接引入check也是会报错的,也许手动加入.h文件自此,1.3即完成.

### 实验部分结果截图

![](https://pic.downk.cc/item/5f9142e01cd1bbb86bb23f2c.jpg)

![](https://pic.downk.cc/item/5f9143b91cd1bbb86bb25f3b.jpg)

![](https://pic.downk.cc/item/5f9144201cd1bbb86bb271c9.jpg)

### 思考题解答

1. opcode\*table是一个opcode*entry结构体定义的数组,里面储存有指令,推测是模拟电脑指令码结构
2. 查看nemu/src/monitor/cpu-exec.c文件,可以看到cpuexec函数传进来一个参数n,这个是无符号整数,所以-1代表的是最大值,下面for循环执行n次循环,所以传进来-1时,会进行最大次数循环,底下的ecex*wrapper()函数就是更新%eip,所以当n为-1时,就会把所有后面的指令全部依次执行从而达到continue的效果
3. 标志位CF是进位状态标志位，用来反映运算结果是否产生进位或者是借位。如果运算结果的最高位（字操作的15位和字节操作的第7位）产生一个进位（减法），则CF置1，否则CF清零,举例说明就是当两个数相加时，若最高位向上形成进位，则CF=1；当两个数du相减时，若最高位向上形成借位，则CF=1；当两个无符号数相乘时，若乘积的高一半为0，则CF=0；当两个带符号数相乘时，若乘积的高一半是低一半的符号扩展，则CF=0.mov指令的格式是mov reg/mem,reg/mem/Imm,表示把源操作数（第二操作数）的值传给目的操作数（第一操作数）。指令执行后，目的操作数的值被改变，而源操作数的值不变。相当于高级编程语言中的赋值语句,在汇编语言中使用频繁.gcc中-Wall表示打开gcc所有的警告,-Werror表示将所有的警告当成错误来处理

### 实验笔记总结

1. strtok(str,c)函数:C语言库函数之一,是将目标字符串str以c为分隔符切割为多个子串,其中注意的是str会改变为首切割子串
2. atoi()函数:C语言库函数之一,是将字符串str强制转换成整数形式
3. fputs(const char \*str, FILE \*stream) 函数:*字符串写入到指定的流 stream 中，但不包括空字
4. 在C中:%0x8x,%0x2x等是表示位不足时补零
5. 在strtok()函数中:取后面的子串时,只需把strtok中的首参变为NULL即可
6. 与0xff相且可以舍去多余的位
7. 坑点:本程序遵循C99的相关规定,所以for循环不支持局部变量声明,需要提前在外部声明或者make时声明以什么版本编译(浪费好长时间.)
8. strncp():char *strncpy(char *dest, const char *src, size_t n) 把 src 所指向的字符串复制到 dest，最多复制 n 个字符。当 src 的长度小于 n 时，dest 的剩余部分将用空字节填充。而且要十分注意坑点:strncpy()函数没有自动加上字符串终止符,所以需要手动添加,所以make_token函数中有一步是加'\0'哦.
9. sscanf():int sscanf(const char *str, const char *format, ...) 从字符串读取格式化输入,修改为规定形式,注意要赋值的参量前加&,sprintf功能类似
10. strlen():返回字符串长度
11. 在某个c文件中引用某个外部文件的函数时,首先要在外部h文件中声明函数然后引入.h文件
12. 在enum枚举中,每个元素没有直接的比较关系,与数组有一定的区别,且每个参量都对应的一个Index值,若为定义则从0开始,所以for遍历循环时i++即为下一个元素
13. cpu寄存器模拟的修改(struct与union):struct是将所定义的变量全部各申请一个内存空间,各个变量互不影响,而union是对各个变量共享一个内存空间,且只会保留最后

### 实验源代码下载

注意:此文件不包括编译相关文件,只含括任务编辑区域文件,切不可直切抄袭!!

git仓库：https://github.com/Langwenchong/nemu/pa1

百度云：链接：https://pan.baidu.com/s/1PS5BVG8K6vYAd7HxGBNWnw 
提取码：z5xo 