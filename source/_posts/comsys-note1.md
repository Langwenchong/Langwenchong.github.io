---
title: 计算机系统基础笔记--Part1
comments: false
top: false
date: 2021-01-30 10:45:49
tags: [note,408,计组原理]
categories: 
	- [学习笔记]
	- [408,计算机系统]
---

本系列记录翀翀😛学习计算机组成原理的部分核心笔记，这部分是408最重要的部分，需要极大的毅力坚持学完，学习之前分享一句话与君共勉：你所有的迷茫，可能只是因为想得太多却做得太少。与其整日纠结，不如立即行动。也许不是每次出发都能找到正确的方向，不是每次尝试都能收获鲜花和掌声，但进一步自有进一步的欢喜。人生那么宝贵，既然渴望改变，就别畏首畏尾。

<!-- more -->

### 什么是计算机系统组成原理

#### 计算机组成原理的学习

顾名思义，计算机组成原理知识点可以用三部分概括，首先是介绍什么是计算机，然后是计算机的组成，最终再是计算机各个部分的构成原理，知识点由浅入深，由易到难。

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130105829.png)

各个部分各占1/3板块，我们需要全部熟练掌握，只有理解了最底层的构成原理以及各个板块之间的组成配合方法，才能够深刻理解计算机组成原理的知识点。

所以我们主要学习：

1. 基本计算机部件的结构和组织方式
2. 基本运算的操作原理
3. 基本部件和单元的设计思想

#### 计算机系统简介

我们很容易就可以将计算机系统划分成两部分：

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130111145.png)

上面是所有计算机都有的共性特征，即软件和硬件相互配合形成才能组成计算机系统，这是区别于操作系统的一大特点，操作系统只是软件。

#### 计算机发展历程

##### 第一代计算机

电子管时代（1946-1957），由电子管组成的电子数字计算机：ENIC横空出世，虽然确实能够进行计算，但是使用的是二进制机器语言，占地面积很大约170平方米，耗电量巨大。

##### 第二代计算机

晶体管计算机时代来临（1958-1964），使用的是面向过程的程序设计语言：FOTRAN，有了操作系统雏形。相较于电子管更叫精巧高效。

##### 第三代计算机

中小规模集成电路时代（1965-1971），此时高级语言迅速发展，开始有了分时操作系统。OS中介绍过分时操作系统他是一个RR时间片轮转执行的操作系统的计算机，对于每一个用户都分配一定的时间片进行运行。

##### 第四代计算机

大规模，超大规模集成电路时代（1971-至今），此时产生了微处理器，并且还产生了许多高级的系统概念：并行，流水线，高速缓存，虚拟存储器等。

##### 计算机硬件发展总结

| 发展阶段 |   时间    |         逻辑元件         | 速度（次/秒） |      内存      |              外存              |
| :------: | :-------: | :----------------------: | :-----------: | :------------: | :----------------------------: |
|  第一代  | 1946-1957 |          电子管          |   几千-几万   | 汞延迟线、磁鼓 |         穿孔卡片，纸袋         |
|  第二代  | 1958-1964 |          晶体管          |  几万-几十万  |   磁芯存储器   |              磁带              |
|  第三代  | 1964-1971 |     中小规模集成电路     | 几十万-几百万 |  半导体存储器  |           磁带、磁盘           |
|  第四代  | 1971-至今 | 大规模，超大规模集成电路 |  上千万-万亿  |  半导体存储器  | 磁盘、磁带、光盘、半导体存储器 |

{% note info, 

这里我们一定要注意之前所讲的各种计算器的组成原件都是逻辑元件，即用来实现逻辑运算的元件。

{%endnote %}

###### 计算机编程语言的发展？

我们前面介绍了各个时代计算器所使用的编程语言的不同，大体上编程语言可以分类为：

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130112512.png)

这个在OS中也有所介绍，但是这里要注意在高级语言翻译成机器语言之前，还有一个步骤是先编译译成汇编语言，汇编语言是一种助记符，我们并不陌生，在做计算机系统实验时会经常看到。前面是不同汇编指令的名称，后面两项一般是操作数或者寄存器等。这里要注意是通过编译程序将高级语言先编译成汇编语言，然后再通过汇编程序将汇编语言汇编成机器语言，计算机才能够识别指令并进行执行，并且一条高级语言通常会编译成多行汇编语言，一条汇编指令又会翻译成多条机器语言指令。

###### 思考：微处理器的发展？

我们前面讲到在大规模集成电路的第四代计算器时代出现了微处理器硬件，其发展历程如下，主要是机器字长的增加：

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130113005.png)

其中机器字长的意思是计算机执行一次整数运算所能处理的二进制位数，我们可以看到随着计算机的发展，机器字长再逐渐增长，这个无疑会表示更大的数，更长的地址，也就同时增大了计算机的空间和计算能力，所以计算机的发展不仅仅是由软件推进，硬件部分的发展也可以大幅提升计算机的性能。我们这里对于80386微处理器的计算机不能再熟悉了，他是最经典的32位微处理器计算机，在我们的[nemu](https://wenchong.space/tags/nemu/)实验中，就是再借鉴80386的计算机来进行的。

##### 摩尔定律

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130113706.png)

伴随着计算机硬件的发展，摩尔提出了一个非常有趣的理论：集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，整体性能也会提升一倍。这个定律揭示了信息技术进步的速度之快。

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130113726.png)

我们可以看到半导体存储器的单芯片容量在迅速增大，从1KB->4KB->16KB->64KB->256KB->1MB->4MB->16MB->64MB->256MB->1GB，每次提升都在2^10量级以上。

#### 计算机发展方向

##### 角度一：体型

在计算机的发展历程中，逐渐两极分化为两个类型，一种是体型小，便捷可携带但是计算性能较小的微型计算机，例如：手机、PAD、私人电脑等，另一种是体型较大的巨型服务器计算机，其计算性能可观，通常可以集成并并行完成许多任务。再细分可以分为：巨型机，大型机，中型机，小型机，微型机，单片机。

##### 角度二：硬件组成

电子模拟计算机、电子数字计算机等，主要区别是逻辑元件的功能原理不同

##### 角度三：服务对象的不同

通用计算机和专用计算机，通用计算机一般是大型的服务器，而专用计算机就是每个人自己的Laptop等。

##### 角度四：指令和数据流

1. 单指令流&单数据流（SISD）：冯诺依曼体系结构

   ![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130114609.png)

   经典的五大基础硬件：输入设备，输出设备，存储器，运算器和控制器。

2. 单指令流&多数据流（SIMD）：阵列处理器、向量处理器

   <img src="https://gitee.com/Langwenchong/figure-bed/raw/master/20210130114723.png" style="zoom:50%;" />

3. 多指令流&单数据流（MISD）：实际上不存在，因为在单数据流的条件下，多数据流没有实际应用意义。

4. 多指令流&多数据流（MIMD）：多处理器，多计算机

   ![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130114856.png)

   很明显这种多核的计算机可以并行执行多个进程，性能更高，但是也较为昂贵，耗能大。

### 计算机硬件的基本组成

接下来我们就来讲一讲计算机硬件的基本组成，这里主要介绍冯诺依曼这一经典的组成方式，基本上现代计算器的硬件组成仍然沿用的是冯诺依曼体系。

#### 冯诺依曼计算机

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130114609.png)

上图就是冯诺依曼体系的简化图，其中有以下几大特点：

- 计算机硬件系统由输入设备，输出设备，存储器，运算器和控制器5大部件组成
- 指令和数据以同等的地位存于存储器中，并且可以按地址寻访
- 存储程序：将指令以代码的形式事先输入到计算机主存储器中，然后按其在存储器中的首地址执行程序的第一条指令，以后就按照该程序的规定顺序执行其他指令直至程序执行结束。
- 指令和数据都是使用二进制代码表示
- 指令由操作码和地址码组成，操作码用来表示操作的性质，地址用来表示操作数在存储器中的位置，比如LOAD A,16等
- 指令在存储器内按顺序存放，通常，指令是顺序执行的，在特定条件下，可以根据运算结果或根据设定的条件改变执行顺序，最经典的就是if-else判断语句的跳转。
- 早期的冯诺依曼机以运算器为中心，输入/输出设备通过运算器和存储器传送数据。

当然根据计算机的功能不同，会将冯诺依曼的体系进行略微的调整，比如：

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130120047.png)

不同的设备侧重的硬件也不相同，比如：

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130120131.png)

但是总体来看，基本上沿用的都是冯诺依曼的经典组成结构。

#### 总结

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130120223.png)

### 计算机的功能部件

这里我们逐一对各个部件的原理进行介绍来进一步了解计算机的5大部件

####  存储器

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130120511.png)

在一个计算机中，有两处存储数据的地方，和运算器控制器直接进行数据交换的是主存储器为主的主存又称为内存，而还有一部分数据是先存放在外存又称为辅存的地方，一般是暂时不会用到的数据，当使用时是先将数据从外存中调入到内存中再进行运算。外存可以是外设的辅助存储器，磁盘等。

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130120908.png)

从上图我们不难看出一个数据的访问过程，大部分数据都是存放到了存储体内，当访问这个数据时，实现调用访问指令找到他的存储地址，这个地址就存放在了地址寄存器（MAR)中，通过地址进行访存获得这个数据值然后存储到数据寄存器(MDR)中方便使用。并且一个数据并不是一个十进制的数存放，而是许许多多个0/1位组成表示，通常0/1串的长度是根据机器字长决定的，那么通过译码器可以将二进制串表示的数据翻译成10进制等其他进制的数据。

##### 思考：为什么要用二进制表示？

首先最主要的就是由计算机的硬件特性决定的，我们知道一个电位通常可以用两个状态来表示，通电和断点，那么刚好可以用1和0来表示，再无第三个状态，所以使用二进制表示契合硬件的特点，同时二进制数据存储虽然可能长度较长，但是同时也意味着计算效率的高效，无论是多么复杂的计算方法，都可以最终拆解为交并异或等基本的二进制操作，这些基础操作运算效率更高，实现简单，所以使用二进制的方式来存储数据。

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130121712.png)

通常一个数是由固定的位表示的，MAR用于寻址访存，其位数就对应着存储单元的个数。每一位都可以有两种情况0或者1，所以8位存储字就是可以表示0~2\^8-1范围的数，存储性能非常可观。MDR数据寄存器的位数一般和存储字长相等，一般是字节的二次幂的整数倍。并且虽然这里介绍是MAR和MDR都是在存储器中，但是在现在的CPU中，MAR和MDR通常都是存在于CPU中的，不难理解，这样的方法数据交流更加利于寄存器和cpu,性能更高。这里一定要注意一个存储单元就是一字节，存储单元中的一个通电元件就是一位，所以假设存储单元是8位，n个存储单元表示的空间就是2\^n*8bit=2^nB。

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130122502.png)

并且MDR是应用于数据交流的总线，是双向的，而MAR是地址总线，一般是访存时的地址，很明显是单向的。cpu通过两个寄存器和指令，译码驱动等部件，实现了和主存之间的读写操作。

#### 运算器，控制器

运算器，控制器一起组成了cpu核心处理器的功能，其中运算器顾名思义肯定是进行运算的，数学运算方式加、减、乘、除还有逻辑运算或、与、非、异或等。如下：

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130123118.png)

|      |     加     |     减     |       乘       |      除      |
| :--: | :--------: | :--------: | :------------: | :----------: |
| ACC  | 被加数，和 | 被减数，差 |    乘积高位    | 被除数、余数 |
|  MQ  |            |            | 乘数、乘积地位 |      商      |
|  X   |    加数    |    减数    |     被乘数     |     除数     |

上面的ACC是累加器，MQ是乘商寄存器，X是操作数寄存器，这三个元件是组成运算器必须的部件。PSW我们知道是程序状态寄存器来表示这个指令或者这个程序是否越权限执行了。ALU是算术逻辑单元，当然运算器中肯定还有许多通用寄存器来存储中间结果的。

控制器是协调各个部件、功能单元配合工作的。他的构成如下：

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130123717.png)

其中CU是控制单元，IR是指令寄存器存储当前执行的指令，而RC是程序计数器，就是存储下一个指令的地址，实际上就是在IR基础上加一表示下一条指令（这是因为指令通常是顺序存储的）。

所以我们知道cpu同时集成了运算和调度控制各任务执行的功能，是计算机的核心部件。

#### I/O设备

输入输出设备，都是相对于计算机来说的，所以键盘，鼠标等是输入设备，显示屏，打印机等是输出设备，里面也有自己相对应的独立软件，和驱动软件来完成指令的翻译，执行以及向cpu报告状态信息等，所以同时也听从于cpu的指令调度。

### 计算机系统多层次结构

我们知道硬件是提供底层服务环境的，软件是在硬件支持下进行运行的。并且操作系统等系统软件是最接近硬件层次的第一层软件，他们会涉及到许多有关硬件的功能。同时根据硬件的状态向上层的应用软件提供接口等服务环境:

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130124627.png)

所以上层软件会使用高级开发语言，相应的程序先翻译成汇编语言，然后再翻译成传统机器，硬件所能执行的二进制代码，最终再由硬件直接进行微指令的执行：

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130124850.png)

我们同样将这个语言翻译的过程进行层次划分如下：

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130125010.png)

一般将二进制代码的部分分为硬件层次，其他为软件层次。这里如何理解汇编语言是一种助记符呢？我们在做过nemu实验后知道实际上log.txt打印的就是我们规定输出的汇编语言，他已经被翻译成了一种对应着机器语言执行序列的方式了，但是不是给硬件机械设备用的，而是方便于我们设计人员了解程序走向，设计程序的助记符，我们可以通过汇编语言向上了解软件程序的运行原理，同时也可以向下掌握硬件系统的工作原理。

### 计算机的性能指标

最后我们再来简单讲解一下如何评判一个计算机的性能？我们可以从两个角度出发：

#### 容量

毫无以为，计算机的容量至关重要，我们知道在8位数据时代，存储的数据范围很有限，伴随着信息的增大，我们需要扩大数据空间了，所以增大了机器字长，16位，32位再到如今的64位，可以看出，容量毫无疑问会影响到我们计算机的工作性能。

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130125914.png)

当然伴随着技术的发展，我们也不仅仅局限于扩大机器字长来增大计算机的存储性能了，虚拟存储技术，动态分配都可以让我们充分利用优先的存储空间来存储更多的数据。这里我们只需要记住系统最大的容量计算公式
$$
总容量=存储单元个数Byte=存储单元个数×存储字长bit/8
$$

#### 速度

另一方面，毫无疑问，计算机的工作速度也非常重要，执行一个任务我们肯定是需要在保证精度准确的情况下执行的越迅速越好。我们通常用时钟周期来表示一个单位时间长度，那么一条指令的耗时就是数个时钟周期，即（CPI是平均执行周期数，又称为计算机执行一条指令所需的时钟周期数）
$$
单条指令耗时=CPI*CPU时钟周期
$$
所以我们可以重新定义一下机器字长，机器字长是计算机进行一次整数运算所能处理的二进制数据的位数

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130130443.png)

假设每次只能处理一个二进制位，那么可以通过编程8条指令完成对8位数据的运算：指令1，指令2……指令8。那么

CPU的执行时间（这个数据运算耗时）=指令1耗时+指令2耗时+……指令8耗时=（指令1的CPI+指令2的CPI+……+指令8的CPI）×CPU时钟周期=平均CPI×指令条数×CPU时钟周期。

同时还有几个可以表示运算速度的指标：

- 数据通路宽度：数据总线一次所能并行传送信息的位数

  ![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130131128.png)

- 吞吐量：指系统在单位时间内处理请求的数量，他取决于信息能够多快的输入内存，cpu能够多快的取指令，数据能多快的从内存取出或存入，以及所得结果能够多快的从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。

- 响应时间：指从用户向计算机发送一个请求，到系统对该请求做出相应并且获得它所需要的结果的等待时间。通常包括CPU时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I/O操作、操作系统开销等时间）。

- MIPS(每秒执行多少百万条指令)
  $$
  MIPS=指令条数/(执行时间×10^6)=主频/CPI
  $$
  MFLOPS(每秒执行多少百万次浮点运算)
  $$
  MFLOPS=浮点操作次数/(执行时间×10^6)
  $$
  GFLOPS(每秒执行多少十亿次浮点操作)
  $$
  GFLOPS=浮点数操作次数/(执行时间×10^9)
  $$
  TFLOPS(每秒执行多少十万亿次浮点运算)
  $$
  TFLOPS=浮点数操作次数/(执行时间×10^{12})
  $$
  

#### 总结

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130132310.png)

### 计算机系统概述总结

![](https://gitee.com/Langwenchong/figure-bed/raw/master/20210130132400.png)