---
title: python学习笔记--python基础(1)
comments: false
top: false
date: 2022-01-15 14:52:21
tags: [python]
categories: 
	- [个人笔记,Python基础]

---

python基础入门笔记，记录翀翀对Python基础的理解与总结，常言道：一分耕耘，一分收获。”在自己的理想道路上，多动脑筋，不断的思考，不停地学习，四肢能勤，不断地“书读百遍”，就会“其义自现”。愿你我都能坚持学习😁

<!-- more -->

### Python整数类型(int)详解

#### 数值范围

对于弱类型语言python，整数的范围是无限大，他不会区分byte,int,long等等，只要是整数统一使用int来表示，**当使用的数值超过计算机自身的计算能力时，python就会自动转用高精度进行计算（大数计算）**

```python
#将 78 赋值给变量 n
n = 78
print(n)
print( type(n) )

#给x赋值一个很大的整数
x = 8888888888888888888888
print(x)
print( type(x) )

#给y赋值一个很小的整数
y = -7777777777777777777777
print(y)
print( type(y) )
```

{% note info,

以上的所有数字最终的type打印出来的类型都是int，即python不会发生数值溢出，具有非常强大的整数处理能力，但是要注意python2.x是会区分int、long的类型的。

%}

#### 整数的不同进制

- 十进制形式：0~9组成，开头不能是0
- 二进制形式：书写时以`0b`或者`0B`作为开头，同时数字只能由0和1组成，比如0B101对应的就是十进制的5
- 八进制形式：首先是`0o`或者`0O`开头，数字范围为0~7,**同时要注意在Python2.x中八进制数字还可以以`0`开头表示**
- 十六进制形式：以`0x`或者`0X`开头，后面数字0~9，同时还可以使用字母A-F或者a-f表示

```python
#十六进制
hex1 = 0x45
hex2 = 0x4Af
print("hex1Value: ", hex1)
print("hex2Value: ", hex2)

#二进制
bin1 = 0b101
print('bin1Value: ', bin1)
bin2 = 0B110
print('bin2Value: ', bin2)

#八进制
oct1 = 0o26
print('oct1Value: ', oct1)
oct2 = 0O41
print('oct2Value: ', oct2)
```

运行结果：

```python
hex1Value:  69
hex2Value:  1199
bin1Value:  5
bin2Value:  6
oct1Value:  22
oct2Value:  33
```

同时Python中为了提高数字的可读性，允许对数字使用`_`进行分割，比如348000000可以表示为348_000_000，一般是隔三个数字进行一次划分。

### Python小数/浮点数(float)类型详解

Python浮点数就是float类型，没有double双精度类型，他有如下两种写法

#### 十进制形式

这个就是我们平常总是使用的形式，比如34.6、34.60等等，书写时必须包含一个小数点从而和整数进行区分

#### 指数形式

Python中指数形式的写法就和科学计数法类似，形式为:

```python
aEn或者aen
```

a是尾数部分，是一个十进制数（**可以是整数或者小数**），n是指数部分，必须是一个**十进制整数**，E或者e是固定的字符，用于分割尾数部分和指数部分，整个表达式计算公式为
$$
a×10^n
$$
例如以下形式：

- 2.1E5 = 2.1×105，其中 2.1 是尾数，5 是指数。
- 3.7E-2 = 3.7×10-2，其中 3.7 是尾数，-2 是指数。
- 0.5E7 = 0.5×107，其中 0.5 是尾数，7 是指数。

{% note info,

要注意只要写成了指数形式就一定是小数，即使此时他的值看起来像一个整数，比如14E3等价于14000，但是实际上此时14E3也是小数而非整数

%}

### Python复数类型(complex)类型详解

在Python中还内置了复数类型，直接书写即可，复数由实部和虚部两部分组成，因此在python中写法如下：

```python
a+bj
```

a表示实部，b表示虚部

```python
c1 = 12 + 0.2j
print("c1Value: ", c1)
print("c1Type", type(c1))

c2 = 6 - 1.2j
print("c2Value: ", c2)

#对复数进行简单计算
print("c1+c2: ", c1+c2)
print("c1*c2: ", c1*c2)
```

运行结果：

```python
c1Value:  (12+0.2j)
c1Type <class 'complex'>
c2Value:  (6-1.2j)
c1+c2:  (18-1j)
c1*c2:  (72.24-13.2j)
```

### Python字符串(string)详解

首先我们要知道在Python中字符串可以看成是若干个字符组成的列表，因此他支持len()统计长度，使用索引进行获取指定位置字符等方法。Python中字符串必须使用双引号`""`或者单引号`''`包裹。

#### 处理字符串中的引号

对于本身就包含双引号`"`或者单引号`'`的字符串，此时我们需要对其进行处理，我们这里以`I'm a great coder`为例，此时我们需要使用如下两种方法正确表示这个字符串：

##### 对引号进行转义

如果此时我们就要使用单引号对这个字符串进行包裹，那么我们需要对字符串内部的单引号进行转义，使用符号`\`对其进行转义即可

```python
str1 = 'I\'m a great coder!'
str2 = "引文双引号是\"，中文双引号是“"
```

##### 使用不同的引号包围字符串

也可以此时外部使用不同的双引号包裹即可：

```python
str1 = "I'm a great coder!"  #使用双引号包围含有单引号的字符串
str2 = '引文双引号是"，中文双引号是“'  #使用单引号包围含有双引号的字符串
```

{% note info,

但是假设此时这个字符串内部同时包含有单引号和双引号，那么没有办法只能使用`\`对特殊的符号进行转义了

%}

#### 字符串的换行

我们只需要在需要换行处末尾添加一个反斜杠`\`既可以换行继续书写字符串如下，同时也可以对过长的表达式进行换行：

```python
#长字符串进行换行书写
s2 = 'It took me six months to write this Python tutorial. \
    Please give me more support. \
    I will keep it updated.'
#长表达式进行换行书写
num = 20 + 3 / 4 + \
    2 * 3
```

#### 长字符串

我们之前也了解过在Python有两种书写代码注释的方法：

```python
#单行注释
"""
多行
注释
"""
'''
多行注释
'''
```

但是实际上三个单引号或者三个双引号自身就是长字符串，也就是说三个单引号或者三个双引号包围的字符串会默认支持换行书写，**同时在其内部在放置单引号或者双引号也是不会出现解析错误的，因此无需对其进行转义**，当这个长字符串没有赋值给任何一个变量时，那么这个长字符串就是一个不会对代码程序本身起到任何影响的事物，因此他可以用来书写注释，那么换句话说也就是它本身实际上是可以被当成字符串赋值给一个变量进行存储的如下：

```python
longstr = '''
    It took me 6 months to write this Python tutorial.
    Please give me a to 'thumb' to keep it updated.
    The Python tutorial is available at http://c.biancheng.net/python/.
'''
print(longstr)
```

运行结果：

```python
#注意这里是有一个空行的
It took me 6 months to write this Python tutorial.
    Please give me a to 'thumb' to keep it updated.
    The Python tutorial is available at http://c.biancheng.net/python/.
#这里也会有一个空行      
```

但是我们会发现对于长字符串，他会自动存储换行、空格、缩进等内容，因此对于上面的代码我们如果想去掉空行需要写为：

```python
longstr = '''It took me 6 months to write this Python tutorial.
    Please give me a to 'thumb' to keep it updated.
    The Python tutorial is available at http://c.biancheng.net/python/.'''
print(longstr)
```

#### Python原始字符串

由于反斜杠`\`本身具有转义的意义，那么假如我们希望写一些包含反斜杠的字符串（最常见的即使文件路径）时就需要特别注意需要对反斜杠进行转义从而取消其自身本身的转义功能，那么写起来就会非常麻烦如下：

假设此时我们要写一个Windows路径`D:\Program Files\Python 3.8\python.exe`,那么为了避免反斜杠转义对路径的影响，我们需要对路径中的每一个反斜杠进行转义因此应该写为:`D:\\Program Files\\Python 3.8\\python.exe`。

但是这样写太麻烦了，因此Python支持原始字符串，即默认字符串中的每一个反斜杠`\`都是**会原封不动的保留(即使此时他发挥转义的作用）**，所有内容都保持`原汁原味`的样子，写法只需要在开头加上r即可：

```python
str1 = r'原始字符串内容'
str2 = r"""原始字符串内容"""
rstr = r'D:\Program Files\Python 3.8\python.exe'
```

{% note info,

一定要注意原始字符串中的反斜杠还是会起到转义的作用，但是不同的是此时反斜杠也会被保留显示出来

%}

假设此时我们对单引号包裹的原始字符串`I'm a great coder`进行转义，很明显需要在`'`前加上反斜杠，但是这个反斜杠也会保留显示如下：

```python
str1 = r'I\'m a great coder!'
print(str1)
```

运行结果：

```python
I\'m a great coder!
```

正是由于斜杆转义这个特性，我们一定要注意字符串的结尾处不能是反斜杠，否则字符串结尾处的引号将会被转义，导致字符串不能正常结束。

##### 思考：D:\Program Files\Python 3.8\怎么表示？

那么此时上面的这种以反斜杠结尾的路径我们该怎么样表示呢？有两种方法：

##### 方法一：直接使用`\\`进行结尾即可

很简单我们对结尾的\进行转义即可，如下所示：

```python
print('D:\\Program Files\\Python 3.8\\')
```

##### 方法二：拼接字符串

但是上面的写法中我们需要对每一个反斜杠都进行一次转义太麻烦了，为了方便我们肯定是会用到原始字符串来写的，但是此时如果结尾是`\\`就会保留显示出两个反斜杠，但是又不能只写一个反斜杠，此时我们就可以使用字符串拼接的方法：

```python
str1 = r'D:\Program Files\Python 3.8' '\\'
str1 = r'D:\Program Files\Python 3.8' + '\\'
print(str1)
```

前半部分使用原始字符串书写，结尾的反斜杠再使用字符串双反斜杠书写，这样即可简便的完成需求，同时我们注意到了python会自动将相邻的字符串进行拼接，即中间的`+`写不写都可以。

### Python bytes

Python中bytes用来表示一个字节串，他和字符串很类似，但是又有区别：

1. 字符串是由若干个字符组成的，以字符为单位进行操作，但是字节串是由若干个字节组成的，以字节为单位进行操作
2. 字节串和字符串除了操作的数据单元不同之外，它们支持的所有方法基本相同
3. 字节串和字符串都是不可变序列，不能随意增加和删除数据，一般的操作都仅仅是生成一个新的字节串或者字符串，并不会修改其自身

bytes的最大特点就是他只负责以字节序列的形式（二进制形式）存储数据，这些数据到底表示什么完全由程序的解析方式决定，如果采用合适的字符编码方式（字符集），字节串可以恢复成字符串，反之亦然，字符串也可以转换成字节串。

说白了，bytes 只是简单地记录内存中的原始数据，至于如何使用这些数据，bytes 并不在意，你想怎么使用就怎么使用，bytes 并不约束你的行为。

字符串和 bytes 存在着千丝万缕的联系，我们可以通过字符串来创建 bytes 对象，或者说将字符串转换成 bytes 对象。有以下三种方法可以达到这个目的：

- 如果字符串的内容都是 ASCII 字符，那么直接在字符串前面添加`b`前缀就可以转换成 bytes。
- bytes 是一个类，调用它的构造方法，也就是 bytes()，可以将字符串按照指定的字符集转换成 bytes；如果不指定字符集，那么默认采用 UTF-8。
- 字符串本身有一个 encode() 方法，该方法专门用来将字符串按照指定的字符集转换成对应的字节串；如果不指定字符集，那么默认采用 UTF-8。

```python
#通过构造函数创建空 bytes
b1 = bytes()
#通过空字符串创建空 bytes
b2 = b''

#通过b前缀将字符串转换成 bytes
b3 = b'http://c.biancheng.net/python/'
print("b3: ", b3)
print(b3[3])
print(b3[7:22])

#为 bytes() 方法指定字符集
b4 = bytes('C语言中文网8岁了', encoding='UTF-8')
print("b4: ", b4)

#通过 encode() 方法将字符串转换成 bytes
b5 = "C语言中文网8岁了".encode('UTF-8')
print("b5: ", b5)
```

运行结果：

```python
b3:  b'http://c.biancheng.net/python/'
112
b'c.biancheng.net'
b4:  b'C\xe8\xaf\xad\xe8\xa8\x80\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x918\xe5\xb2\x81\xe4\xba\x86'
b5:  b'C\xe8\xaf\xad\xe8\xa8\x80\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x918\xe5\xb2\x81\xe4\xba\x86'
```

我们仔细观察b3的三个输出结果，可以发现字节串和字符串的区别，对于字符串获取的是返还的字符，**但是对于字节串，获取的是指定数据的ASCII，这个特性可以帮助我们获取任意一个字符的ASCII。**假设此时我们需要知道B的ASCII，我们不需要查询ASCII表，只需要在Python终端中输入`print(b'B'[0])`即可获知：

```python
>>> print(b'B'[0])
66
```

### Python布尔(bool)类型详解

Python中使用True和False来表示真假，同时True相当于整数值1，False相当于整数值0，因此下面运算是可以的：

```python
>>> False+1
1
>>> True+1
2
```

### Python input()函数

input()是Python的内置函数，用来从控制天获取用户输入的内容。**Input()函数总是以字符串的形式来处理用户输入的内容**，所以用户输入的内容可以包含任意字符串。

```python
str=input(tipmsg)
```

1. str表示一个字符串类型的变量，input会将读取到的字符串放入str中
2. tipmsg表示提示信息，他会显示在控制台上，告诉用户应该输入什么样的内容，如果不写tipmsg那么就不会有任何的提示信息

```python
a = input("Enter a number: ")
b = input("Enter another number: ")

print("aType: ", type(a))
print("bType: ", type(b))

result = a + b
print("resultValue: ", result)
print("resultType: ", type(result))
```

运行结果：

```python
Enter a number: 100↙
Enter another number: 45↙
aType:  <class 'str'>
bType:  <class 'str'>
resultValue:  10045
resultType:  <class 'str'>
```

`↙`表示按下回车键，按下回车键后 input() 读取就结束了。但是我们发现上面的代码我们是想计算输入的a和b的和，但是由于输入的内容会被当做字符串类型，因此最终变成了字符串的拼接，为了解决这个问题，我们首先需要将a和b输入内容转成整数类型，此时我们会使用如下一些类似的强转类型函数：

- int(string) 将字符串转换成 int 类型；
- float(string) 将字符串转换成 float 类型；
- bool(string) 将字符串转换成 bool 类型。

### Python print()函数高级用法

之前我们使用print()函数都只是输出显示单个内容变量，但是实际上print()函数完全可以同时输出多个变量，而且他具有更复杂丰富的功能。

```python
print (value,...,sep='',end='\n',file=sys.stdout,flush=False)
```

value参数可以接收任意多个变量的值，不同的变量之间使用`,`进行分割，因此print()可以输出多个值：

```python
user_name ＝ 'Charlie'
user_age = 8
#同时输出多个变量和字符串
print("读者名：",user_name,"年龄：",user_age)
```

运行结果：

```python
读者名： Charlie 年龄： 8
```

从上面的输出结果我们不难看出print()输出多个变量时，会**默认使用空格进行分隔**，如果希望手动设定分隔符，需要修改sep参数：

```python
#同时输出多个变量和字符串，指定分隔符
print("读者名：" ,user_name,"年龄：",user_age,sep='|')
```

运行结果：

```pyth
读者名：|Charlie|年龄：|8
```

同时我们还发现print()默认输出结束会进行换行，这是因为print()的end参数的默认值是`\n`因此他总是会在输出结果后面加上一个换行符，如果我们要手动设定，只需要修改end参数即可：

```python
#设置end 参数，指定输出之后不再换行
print(40,'\t',end＝"")
print(5O,'\t',end＝"")
print(60,'\t',end＝"")
```

运行结果：

```pyt
40    50    60
```

同时file指定了输入的地方，默认是`sys.stdout`即控制台因此会将变量的内容打印在控制台上，我们也可以修改它为指定文件，这样内容将会打印到文件中：

```python
f = open("demo.txt","w")#打开文件以便写入
print('沧海月明珠有泪',file=f)
print('蓝回日暖玉生烟',file=f)
f.close()
```

上面的代码中，open()函数用于打开demo.txt文件，同时权限为`w`写入权限，此时即使没有这个文件也会自动创建，然后写入两句话再关闭这个文件输入流，这样我们就将这句诗输出到了demo.txt文件中了

print()的flush参数用于控制输出缓存，改参数一般设置为False，这样可以获得更好的性能。

### Python格式化输出字符串

#### 转换说明符

和C类似，Python也可以对要输出的变量的内容进行格式化，在print()中使用`%`开头的转换说明符对各种类型的数据进行格式化输出，具体参考下表：、

| 转换说明符 |                 解释                  |
| :--------: | :-----------------------------------: |
|   %d,%i    |       转换为带符号的十进制整数        |
|     %o     |       转换为带符号的八进制整数        |
|   %x,%X    |      转换为带符号的十六进制正式       |
|     %e     | 转换为科学计数法表示的浮点数（e小写） |
|     %E     | 转换为科学计数法表示的浮点数（E大写） |
|   %f,%F    |          转换为十进制浮点数           |
|     %g     |       智能选择使用%f或者%e格式        |
|     %G     |       智能选择使用%F或者%E格式        |
|     %c     |         格式化字符及其ASCII码         |
|     %r     |  使用repr()函数将表达式转换为字符串   |
|     %s     |   使用str()函数将表达式转换为字符串   |

{% note info,

要注意转换说明符只是一个占位符，他会被后面表达式（变量，常量，数字，字符串，加减乘除等各种形式）的值代替。

%}

```python
name="小明"
age = 8
print("%s已经%d岁了！" % (name,age))
```

运行结果：

```python
小明已经8岁了！
```

#### 指定最小输出宽度

有时候我们需要指定格式化的输出内容占用的最少宽度即最小输出宽度（至少占用多少个字符的位置）：

- %10d 表示输出的整数宽度至少为 10；
- %20s 表示输出的字符串宽度至少为 20。

```python
n = 1234567
print("n(10):%10d." % n)
print("n(5):%5d." % n)
```

运行结果：

```python
n(10):   1234567.
n(5):1234567.
```

可以看出对于整数和字符串，当数据的实际宽度小于指定宽度时，会在左侧以空格填充补齐，当数据的实际宽度大于指定宽度时，会按照数据的实际宽度输出，因此他只会限制最小宽度，当数据的实际宽度够宽时指定宽度就没有任何意义了。

#### 指定对齐方式

也就是说默认情况下，print()的数据对齐方式是右对齐的，当数据宽度不够宽时，数据总是靠右侧，左侧不足的地方用空格进行填充，但是我们有时候需要指定的对齐方式，此时我们就可以使用如下标志进行指定：

| 标志 |                    说明                    |
| :--: | :----------------------------------------: |
|  -   |                 指定左对齐                 |
|  +   | 表示输出的数字要带着符号，正式带+，负数带- |
|  0   |    表示宽度不足时补充0，而不是补充空格     |

几点说明：

- 对于**整数**，指定左对齐时，在右边补 0 是没有效果的，因为这样会改变整数的值。
- 对于**小数**，以上三个标志可以同时存在。
- 对于**字符串**，只能使用`-`标志，因为符号对于字符串没有意义，而补 0 会改变字符串的值。

```python
n = 123456
# %09d 表示最小宽度为9，左边补0
print("n(09):%09d" % n)
# %+9d 表示最小宽度为9，带上符号
print("n(+9):%+9d" % n)

f = 140.5
# %-+010f 表示最小宽度为10，左对齐，带上符号
print("f(-+0):%-+010f" % f)

s = "Hello"
# %-10s 表示最小宽度为10，左对齐
print("s(-10):%-10s." % s)
```

运行结果：

```python
n(09):000123456
n(+9):  +123456
f(-+0):+140.500000
s(-10):Hello     .
```

#### 指定小数精度

对于小数（浮点数），print()还允许指定小数点的数字位数，也即指定小数的输出精度。精度值需要放在最小宽度以后，中间用`.`隔开，也可以不写最小宽度，只写精度，具体格式如下：

```python
%m.nf
%.nf
```

m表示最小宽度，n表示输出精度，`.`是必须存在的。

```python
f = 3.141592653
# 最小宽度为8，小数点后保留3位
print("%8.3f" % f)
# 最小宽度为8，小数点后保留3位，左边补0
print("%08.3f" % f)
# 最小宽度为8，小数点后保留3位，左边补0，带符号
print("%+08.3f" % f)
```

运行结果：

```python
   3.142
0003.142
+003.142
```

### Python转义字符

ASCII编码为每一个字符都分配了唯一的编号，称为编码值。在Python中，一个ASCII字符除了可以使用它的实体（也就是真正的字符）表示，还可以使用它的编码表示值。这种使用编码值来间接的表示字符的方式称为转义字符。

转义字符以`\0`或者`\x`开头，当转义字符以`\0`开头表示后面跟的是八进制形式的编码值，以`\x`开头表示后面跟十六进制形式的编码值，Python中转义字符只能使用八进制或者十六进制。

{% note info,

ASCII编码共收录了128个字符，而\0和\x后面最多只能跟两位数字，所以八进制形式\0并不能表示所有ASCII字符，只有十六进制\x可以表示所有ASCII字符。

%}

字符 1、2、3、x、y、z 对应的 ASCII 码的八进制形式分别是 61、62、63、170、171、172，十六进制形式分别是 31、32、33、78、79、7A。下面的例子演示了转义字符的用法：

```python
str1 = "Oct: \061\062\063"
str2 = "Hex: \x31\x32\x33\x78\x79\x7A"
print(str1)
print(str2)
```

运行结果：

```python
Oct: 123
Hex: 123xyz
```

**要注意使用八进制的转义字符是不能表示xyz的，因为他们的编码值都转换成八进制以后有三位**。

对于ASCII编码，0~31（十进制）范围内的字符是控制字符，他们都是看不见的，不能在显示器上显示，甚至无法从键盘输入，只能使用转义字符的形式来表示，不过，直接使用ASCII编码记忆不方便，也不容易理解，因此针对常用的控制字符，我们有简写方式如下：

| 转义字符 |                         说明                         |
| :------: | :--------------------------------------------------: |
|    \n    |           换行符，将光标位置移到下一行开头           |
|    \r    |            回车符，将光标位置移到本行开头            |
|    \t    |      水平制表符，也即Tab键，一般相当于四个空格       |
|    \     | 在字符串行尾的续行符，即一行未完，转到下一行继续写。 |
|    \b    |      退格（Backspace），将光标位置移到前一列。       |
|   \\\    |                        反斜线                        |
|   \\'    |                        单引号                        |
|  \\\\"   |                        双引号                        |

虽然转义字符书写形式上由多个字符组成，但是Python将他们看成是一个整体，表示一个字符。

```python
#使用\t排版
str1 = '网站\t\t域名\t\t\t年龄\t\t价值'
str2 = 'C语言中文网\tc.biancheng.net\t\t8\t\t500W'
str3 = '百度\t\twww.baidu.com\t\t20\t\t500000W'
print(str1)
print(str2)
print(str3)
```

运行结果：

```python
网站        域名                年龄    价值
C语言中文网 c.biancheng.net     8       500W
百度        www.baidu.com       20      500000W
```

### Python数据类型转换

假设我们现在要输入一句话是“您的身高+身高值”，此时身高值是小数类型，那么如下写法是错误的：

```python
>>> height = 70.0
>>> print("您的身高"+height)
Traceback (most recent call last):
  File "<pyshell#1>", line 1, in <module>
    print("您的身高"+height)
TypeError: must be str, not float
```

解释器提示我们字符串和浮点数类型变量不能直接相连，需要将浮点数类型变量height转换为字符串类型才可以。此时我们就需要使用类型转换函数了如下所示：

|         函 数          |                       作 用                        |
| :--------------------: | :------------------------------------------------: |
|         int(x)         |                将 x 转换成整数类型                 |
|        float(x)        |               将 x 转换成浮点数类型                |
| complex(real，[,imag]) |                    创建一个复数                    |
|         str(x)         |                 将 x 转换为字符串                  |
|        repr(x)         |              将 x 转换为表达式字符串               |
|       eval(str)        | 计算在字符串中的有效 Python 表达式，并返回一个对象 |
|         chr(x)         |              将整数 x 转换为一个字符               |
|         ord(x)         |         将一个字符 x 转换为它对应的整数值          |
|         hex(x)         |       将一个整数 x 转换为一个十六进制字符串        |
|         oct(x)         |       将一个整数 x 转换为一个八进制的字符串        |

#### 思考：除了使用类型转换还能怎样输出？

其实很简单，使用我们之前提到的格式化输出即可，如下所示：

```python
>>> height=185.0
>>> print('你的身高是%g' % height)
你的身高是185
>>> print('你的身高是%f' % height)
你的身高是185.000000
>>> print('你的身高是%.1f' % height)
你的身高是185.0
```

### Python算术运算符

这里就简单介绍了，因为无论是运算符号还是运算优先级都是差不多的，但是我们要注意在python中指数不是`^`表示，这个是按位异或的意思，我们需要使用`**`来表示指数，同时`/`就是除法并且不是整除而是直接输出具体的值，`//`才是整除。如下所示：

```python
>>> 2**3
8
>>> 4**0
1
>>> 2/3
0.6666666666666666
>>> 2//3
0
>>> 3/3
1.0
>>> 3//3
1
```

{% note info,

一定要注意python中`/`输出的一定是浮点数，如果要输出整数必须使用`//`。

%}

### Python比较运算符

这里我们主要区分理解一下`==`和`is`的区别：

| 比较运算符 |                             说明                             |
| :--------: | :----------------------------------------------------------: |
|     ==     |   等于，如果==两边的值相等，则返回 True，否则返回 False。    |
|     is     | 判断两个变量所引用的对象是否相同，如果相同则返回 True，否则返回 False。 |

实际上很好区分，`==`就是单纯比较数值是否相同，而`is`就是比较引用是否相同，即存储地址是否相同。因此一下代码如下输出：

```python
import time  #引入time模块

t1 = time.gmtime() # gmtime()用来获取当前时间
t2 =  time.gmtime()
print(t1 == t2) #输出True
print(t1 is t2) #输出False
```

运行结果：

```python
True
False
```

由于time模块的gettime()方法用来获取当前的系统时间，精确到秒级，因为程序运行非常快，所以t1和t2得到的时间是一样的。==用来判断t1和t2的是否相等，因此返还True。而is是判断两者是否为一个对象，但是gettime()每次都是返还一个新对象，因此两者的存储地址并不相同，因此is判断返还False。

### Python逻辑运算符

| 逻辑运算符 |              含义              | 基本格式 |                             说明                             |
| :--------: | :----------------------------: | :------: | :----------------------------------------------------------: |
|    and     | 逻辑与运算，等价于数学中的“且” | a and b  | 当 a 和 b 两个表达式都为真时，a and b 的结果才为真，否则为假。 |
|     or     | 逻辑或运算，等价于数学中的“或” |  a or b  | 当 a 和 b 两个表达式都为假时，a or b 的结果才是假，否则为真。 |
|    not     | 逻辑非运算，等价于数学中的“非” |  not a   | 如果 a 为真，那么 not a 的结果为假；如果 a 为假，那么 not a 的结果为真。相当于对 a 取反。 |

```python
age = int(input("请输入年龄："))
height = int(input("请输入身高："))
if age>=18 and age<=30 and height >=170 and height <= 185 :
    print("恭喜，你符合报考飞行员的条件")
else:
    print("抱歉，你不符合报考飞行员的条件")
```

一种运行结果：

```python
请输入年龄：23↙
请输入身高：178↙
恭喜，你符合报考飞行员的条件
```

{% note info,

但是我们要注意逻辑表达式最终返还的结果并不一定是布尔类型，即不一定是True或者False。他可以是任意类型。

%}

```python
print(100 and 200)
print(45 and 0)
print("" or "http://c.biancheng.net/python/")
print(18.5 or "http://c.biancheng.net/python/")
```

运行结果：

```python
200
0
http://c.biancheng.net/python/
18.5
```

那么为什么上面的输出结果不是布尔类型呢，这就要求我们要去理解逻辑运算的本质原理。

#### 逻辑运算符的本质

在Python中，and和or并不一定会计算右边表达式的值，有时候仅仅计算左边的值就能得到最终的结果。同时and和or运算会将其中一个表达式的值作为最终结果，而不一定是True或者False。

对于and运算，两边的都为真时，最终结果才为真，但是只要其中有一个值为假，那么最终结果就是假，所以Python按照下面的规则执行and运算：

- 如果左边表达式的值为假，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是假，此时 and 会把左边表达式的值作为最终结果。
- 如果左边表达式的值为真，那么最终值是不能确定的，and 会继续计算右边表达式的值，并将右边表达式的值作为最终结果。

对于 or 运算符，情况是类似的，两边的值都为假时最终结果才为假，只要其中有一个值为真，那么最终结果就是真，所以 Python 按照下面的规则执行 or 运算：

- 如果左边表达式的值为真，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是真，此时 or 会把左边表达式的值作为最终结果。
- 如果左边表达式的值为假，那么最终值是不能确定的，or 会继续计算右边表达式的值，并将右边表达式的值作为最终结果。

了解了上面的原理以后我们就可以很容易理解下面的代码的输出结果了：

```python
url = "http://c.biancheng.net/cplus/"
print("----False and xxx-----")
print( False and print(url) )
print("----True and xxx-----")
print( True and print(url) )
print("----False or xxx-----")
print( False or print(url) )
print("----True or xxx-----")
print( True or print(url) )
```

运行结果:

```python
----False and xxx-----
False
----True and xxx-----
http://c.biancheng.net/cplus/
None
----False or xxx-----
http://c.biancheng.net/cplus/
None
----True or xxx-----
True
```

### Python三元运算符

我们在C中和Java中都可以使用一种非常简便的比较赋值操作即三元比较符，他们的格式为：

```java
a=(exp?trueVal:falseVal)
//等价于
if(exp==true){
    a=trueVal
}else{
    a=falseVal
}
```

那么python中有没有三元比较符呢？是有的，但是形式略有区别，他直接使用if和else来表示如下：

```python
max = a if a>b else b
#等价于
if(a>b):
    max=a
else:
    max=b
```

也就是说形式为：

```python
a=trueVal if exp else falseVal
```

更复杂的嵌套如下：

```python
a = int( input("Input a: ") )
b = int( input("Input b: ") )
print("a大于b") if a>b else ( print("a小于b") if a<b else print("a等于b") )
```

运行结果：

```python
Input a: 45↙
Input b: 100↙
a小于b
```

两个变量值得大小关系有三种，很明显我们需要嵌套使用三元比较复杂，此时由于嵌套后逻辑关系较为难以理解我们最好使用`()`包裹表达式以便提高代码可读性