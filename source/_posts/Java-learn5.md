---
title: Java学习笔记-第五讲
comments: false
top: false
date: 2021-03-15 16:18:09
tags: [java]
categories: 
	- [个人笔记,Java基础]
---

记录翀翀🧐学习Java面向对象程序设计的核心笔记与思考，努力学习的过程，就像在黑屋子里洗衣服，你不知道洗干净没有，只能一遍一遍尽力去洗，等到了考场上那一刻，灯光亮了，你会发现，只要认真洗过，那件衣服就会光亮如新，愿你我都能够坚持学习。

<!-- more -->

#### 构造函数细节

实际上前面我们已经多次讲到了构造函数，构造函数和类同名，可以重载，调用父类构造函数使用super，调用同类下的重载函数只需this并且传入的参数不同即可，还有不能用static修饰等等。

##### 思考：为什么构造函数不能使用static修饰？

我们讲过static是使得一个函数方法只属于类，而不属于对象，因此对象无权使用这个方法，但是一个实例化对象初始化时是需要使用构造函数来赋初值的，因此构造函数不能使用static修饰。接下来我们再来谈一谈默认构造函数的有关知识，一定要注意这部分内容非常重要。

首先我们知道默认构造方法就是没有参数的构造方法，你可以显示定义类的默认构造方法。为了保证每一个类至少要有一个构造方法，因此如果定义类的时候你没有定义任何一个构造方法，那么Java将会自动提供一个默认构造方法，这个构造方法没有参数，用public修饰，而且方法体为空，即格式如下：

```java
public ClassName(){};
```

此时实例化的对象都会自动获得定义类中成员变量的初始值，如果类中的成员变量没有赋予初值，那么Java会自动给变量赋予默认值（比如int的0，String的""）。比如下面：

```java
public class Dog{
	int age;
	public static void main(String[] args){
		//正确，此时Java生成了默认的无参数构造函数
		//所以dog会按照默认构造方法初始化
		Dog dog=new Dog();
		//又因为定义类中age变量无初始值，所以Java会用0默认值初始化
		System.out.print(dog.age);//0
	}
}
```

但是一旦类中显式定义了一个或多个构造方法，而且所有显式定义的构造方法都带参数，那么将会失去默认构造方法。即此时Java就不会自动补充默认构造方法了。那么此时在调用无参数的初始化构造函数就会出错。比如：

```java
public class Dog{
	int age;
	public Dog(int age){this.age=age};
	public static void main(String[] args){
		Dog dog=new Dog();//错误，没有默认构造函数了
		Dog dog=new Dog(3);//正确，可以调用显式声明的接受age的构造函数
	}
}
```

那么上面的第一种写法就报错了，因为他未找到不接受参数的构造函数（由于此时你自己显式写了一个构造方法，所以Java就不会添加默认构造方法了）。那么假如此时我们希望第一个构造方法也可以正确使用，那么就需要我们显式的声明默认构造函数了。

```java
public class Dog{
	int age;
	public Dog(){this.age=6};
	public Dog(int age){this.age=age};
	public static void main(String[] args){
		Dog dog1=new Dog();//正确，找到了无参数构造方法，此时dog1 6岁
		Dog dog2=new Dog(3);//正确，此时dog2 3岁
	}
}
```

此时就对了，因为我们显式的声明了无参数构造函数，又因为此时我们在方法体内将age初始化为了6，所以dog1会是6岁，而dog2的年龄就会根据传入的age动态变化了。

{% note info, 

注意默认构造函数时Java为我们添加的不接受参数的方法体为空的函数，但是我们自己显式声明无参数的构造方法时可以在方法体内执行一些语句。

%} 

同时，我们还要注意在构造函数中只能调用一次this(...),同时this(...)语句必须写在第一行。比如：

```
public Dog(int weight,String name){
	this(name,weight);//正确
}

public Dog(int weight,String name){
	System.out.println("ok");
	this(name,weight);//错误，不在第一行
}
```

##### 思考：为什么this(...)语句只能在构造函数中使用一次？

一定要区分this语句和this(...)语句的区别，this语句是this.age,this.weight等，他只是一个改变成员变量的语句，可以多次使用，但是this(...)语句我们知道他其实代表的是一个构造函数，那么我们默认一次构造函数只能实例化一个对象。如果我们允许this(...)语句可以多次使用，那么岂不是可以不断递归了，一个构造函数实例化10000个小狗都是可以得！？这明显是不允许的，因此this(...)语句（实际上是重载构造函数只能在构造函数中使用一次）。

我们前面还学到了super(...)实际上是调用父类的构造函数，其实每个子类的构造函数在开始执行代码前，都会先默认调用其父类的无参数构造函数，除非这个类开始显式的调用了其他父类的构造函数。但是每一个子类的构造函数不会默认调用自己的无参数构造方法。比如：

```java
public class Father{
	int age;
}

class Son{
	int height;
	public Son(int height){
		this.height=height;
	}
}

public static void main(){
	Son xiaoming=new Son(180);
}
```

如上，那么当初始化xiaoming时我们会调用接受height的构造函数（注意，联系我们上面的知识，如果此时xiaoming构造直接调用无参数构造函数是会报错的）。但是在Son构造函数在执行this.height=height语句之前实际上会先调用一下父类的函数，由于此时没有显式声明调用父类的函数（即没有super(...)）语句，因此Son构造函数会自动调用父类的默认构造函数，发现此时父类确实拥有默认构造函数（因为父类没有显式声明构造函数，所以Java会自动为Father类补充一个默认构造函数），发现父类默认构造函数什么代码也不需要执行，接着Son构造函数才会执行this.height=height。我们了解了一个调用过程后会发现有一个明显的隐藏风险，就是如果此时父类显式的声明了构造函数，且没有声明无参数构造函数，那么子类的构造函数如果也恰好没有显式调用父类已有的构造函数，那么子类构造方法就会调用父类的默认构造函数，但是此时会发现不能找到父类的无参数的默认构造函数，因此会报错。即：

```java
public class Father{
	int age;
    public Father(int age){
        this.age=age;
    }
}

class Son{
	int height;
	public Son(int height){
        //会报错，因为没有找到Father的无参数默认构造函数
		this.height=height;
	}
}

public static void main(){
	Son xiaoming=new Son(180);
}
```

那么此时我们就需要解决问题，有两种解决思路：

##### 思路一：子类构造函数显式调用父类的有的显式声明构造方法

```java
public class Father{
	int age;
    public Father(int age){
        this.age=age;
    }
}

class Son{
	int height;
	public Son(int height){
        //此时就不报错了
        //因为会显式调用父类的接受age的构造函数
        //因此此时实际上就相当于与通过父类的构造函数为子类的对象也初始化了age
        //不要忘记此时子类Son是会继承父类的成员变量age的，所以Son也有age
        super(int age);
		this.height=height;
	}
}

public static void main(){
	Son xiaoming=new Son(180);
}
```

但是很明显这个方法不好，因为这样的话Son的所有构造函数都需要显式声明调用父类已有的构造方法。

##### 思路二：为父类显式声明无参数的构造方法（最优方案）

```java
public class Father{
	int age;
	public Father(){};
    public Father(int age){
        this.age=age;
    }
}

class Son{
	int height;
	public Son(int height){
        //不会报错
        //因为此时可以成功调用父类的无参数构造方法
		this.height=height;
	}
}

public static void main(){
	Son xiaoming=new Son(180);
}
```

{% note info, 

很明显，这种错误不太容易发现，我们为了避免这种情况，最后对于每一个类都显式的声明一个无参数构造方法，这样就可以避免bug了。

%} 

#### Java数据类型划分

其实我们第一讲就介绍了，但是当时可能并不了解这种划分有何意义，现在我们再来看一下划分关系：

<img src="https://langwenchong.gitee.io/figure-bed/20210305164117.png" style="zoom: 150%;" />

基本数据类型和引用数据类型，后者可以看成就是对象关系。并且我们也学习到了只有对象才会有Java帮助赋予一个默认值，而对于基本数据类型是不会赋予默认值的。

{% note info, 

Java帮助赋予默认值的机制很重要，这意味着当数组或者类，接口中的成员变量没有初始化初始值时，Java会帮我们赋予一个初始值比如int的0，String的""。但是对于基本数据类型，则必须我们手动赋予一个值，才可以使用（这里和C/C++不同，C中基本数据类型的默认值是一个随机值）。

![](https://langwenchong.gitee.io/figure-bed/20210316201954.png)

比如上面的b没有初始化就是用了所以报错，但是a数组中的值会被Java都赋予一个默认值0。

%} 

并且基本数据类型在JDK1.4之前没有类似于数组，类这种初始化的形式，但是在JDK1.4以后基本数据类型也可以像数组，类那样进行定义了，但是他只是形式类似，还是必须手动初始化赋予初值，比如：

```java
//JDK1.4之前我们只能这样写
int a=5;//注意必须手动赋予初值，否则不能使用

//JDK1.4之后我们也可以像引用类型数据初始化那样写了
Integer a=new Integer(5);//注意，这里必须手动赋予一个初值
Boolean ok=new Boolean(true);//注意，必须手动赋予初值
//或者这样写
Integer a=5;
Boolean ok=true;
```

##### 思考：为什么JDK1.4之后也允许像引用数据类型定义却还要手动赋予初值？

主要是因为Java并没有帮助自动赋予基本数据类型变量初值的机制，而之所以JDK1.4以后也允许基本数据类型像引用数据类型一样书写定义主要是为了满足一部分人的变量定义书写习惯，使得变量定义都有一个统一类似的形式。代码风格的优雅也是很重要滴。同时还有一个最核心之处就是new创建的变量（即引用类型数据形式声明的变量）存储方式与基本数据类型形式声明的变量存储方式有所不同，这才是关键。

#### 变量及其传递

基本数据类型和引用数据类型一个最大的区别就是存储方式不同，在基本类型中值就是直接存于变量中，而引用的变量除了占据一定的内存空间外，他所引用的对象实体（即由new创建的变量实体）也要占据一定的空间。什么意思？引用型变量保存的实际上是对象在内存的地址，也称为对象的句柄。比如现在我们同时用基本类型方式和引用类型方式存储整型数值5，即：

```java
//b存放的就是数值5，某一个存储单元X就是存储的b的数值5
int b=5;
//此时b存储的是存放这个数值5的对象的内存单元Y的地址，类似于C中的b指针指向存储5的地址单元
Integer b=new Integer(5);
b++;
```

那么有什么实际区别吗？当然有，如果此时我们执行下面的语句：

```java
b++;
b=7;
```

如果是基本数据类型的形式定义的b，那么此时X还是存储的b，但是此时X存储的是b的新的数值7。而此时对于引用形式定义的b，那么此时Y单元存储的就是数值6，然后b此时又指向了一个新的地址单元Z，并且Z中存储的是7，也就是此时b类似于指针一样指向了另一个存储单元Z的地址，所以从数值上来看，两者没区别都是b存储了7，但是从变化形式来看，两者区别很大。

{% note info, 

我们只要把引用型数据看成是一个对象，然后他使用对象中的成员变量来存储值就不难理解了，所以每一次对引用型数据进行修改都是建立一个新的对象所以需要再次占用一个新的存储单元（可以发现和指针很像）。

%} 