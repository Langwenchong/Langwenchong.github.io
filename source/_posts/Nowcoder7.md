---
title: 牛客网OJ题解--20210205
comments: false
top: false
date: 2021-02-05 18:12:34
tags: [算法,C++]
categories: 算法导论
---

本系列记录翀翀😐痛苦的刷题日志，所有题目均来自于牛客网OJ题目，坚持刷题谈起来容易做起来难，希望我可以坚持下去，这里仍然分享一段励志文案：每个人都有梦想，然而有些人把梦想变成了现实，有些人的梦想依旧是梦想，只因为他们为梦想付出的努力程度不一样，他们坚持的时间不一样，最终才有这样的结果。

<!-- more -->

### NC16422-图书管理员

#### 题目链接

https://ac.nowcoder.com/acm/problem/16422

#### 题目描述

图书馆中每本书都有一个图书编码，可以用于快速检索图书，这个图书编码是一个正整数。 每位借书的读者手中有一个需求码，这个需求码也是一个正整数。如果一本书的图书编码恰好以读者的需求码结尾，那么这本书就是这位读者所需要的。小D 刚刚当上图书馆的管理员，她知道图书馆里所有书的图书编码，她请你帮她写一个程序，对于每一位读者，求出他所需要的书中图书编码最小的那本书，如果没有他需要的书，请输出-1。

输入的第一行，包含两个正整数 n 和 q，以一个空格分开，分别代表图书馆里书的数量和读者的数量。
接下来的 n 行，每行包含一个正整数，代表图书馆里某本书的图书编码。
接下来的 q 行，每行包含两个正整数，以一个空格分开，第一个正整数代表图书馆里读者的需求码的长度，第二个正整数代表读者的需求码。保证1≤n ≤1,000，1 ≤ q ≤ 1,000，所有的图书编码和需求码均不超过 10,000,000。

#### 测试样例

输入

```c
5 5
2123
1123
23
24
24
2 23
3 123
3 124
2 12
2 12
```

输出

```c
23
1123
-1
-1
-1
```

#### 解题思路

因为给出了每一个借阅图书的长度，所以我们将图书馆的所有图书按照长度从短到长排序，然后每次都截取这个图书编号的后n为与长度为n的借阅图书编号对比，相同就输出这个图书编号，如果所有图书都不符合条件，就输出-1。

#### 解题代码

```c
#include <bits/stdc++.h>
using namespace std;
string book[1005];

bool cmp(string a, string b)
{
    if (a.length() != b.length())
    {
        //a编号长度比b编号长度短
        return a.length() < b.length();
    }
    //否则按照字典序排序即可
    return a < b;
}

int main()
{
    int n, q;
    cin >> n >> q;
    for (int i = 1; i <= n; i++)
    {
        //存储图书馆的图书编号
        cin >> book[i];
    }
    //排序
    sort(book + 1, book + 1 + n, cmp);
    //检验q组借阅情况
    while (q--)
    {
        int len;
        string s;
        cin >> len >> s;
        //假设没有能借的图书
        int flag = 0;
        for (int i = 1; i <= n; i++)
        {
            //一定要注意细节，可能这次的图书编号比借阅图书编号短，那么就跳过检验，否则会越界
            if (book[i].length() >= s.length())
            {
                //裁剪出和借阅图书编号相同长度的图书编号后几位，如果相等
                if (book[i].substr(book[i].length() - len) == s)
                {
                    //返还这个书就是最短编号的可借阅图书
                    cout << book[i] << endl;
                    flag = 1;
                    break;
                }
            }
        }
        if (!flag)
        {
            //没找到返还-1
            cout << -1 << endl;
        }
    }
    system("pause");
    return 0;
}
```

### NC21302-被3整除的子序列

#### 题目链接

https://ac.nowcoder.com/acm/problem/21302

#### 题目描述

给你一个长度为50的数字串,问你有多少个子序列构成的数字可以被3整除
答案对1e9+7取模，保证长度小于50

#### 测试样例

##### 样例1

输入

```c
132
```

输出

```c
3
```

##### 样例2

输入

```c
9
```

输出

```c
1
```

##### 样例3

输入

```c
333
```

输出


```c
7
```

##### 样例4

输入

```c
123456
```

输出

```c
23
```

##### 样例5

输入

```c
00
```

输出

```c
3
```

#### 解题思路

参考了[adoptions](https://ac.nowcoder.com/acm/contest/profile/774707494)大佬的思路，这里写出自己的见解以便温习。我们定义如下公式：
$$
dp[i][j]-前i个字符串中任意子序列模3余数为j的子序列个数
$$
那么我们i就会由n个，j只能是0,1,2。我们从i=1开始注意向后加下一个字符打表。那么对于dp[i+1]\[j\]就会由以下三种情况：

1. dp[i+1]\[j\]肯定包含了dp[i]\[j\]，因为前i个字符组成的子序列同时也是前i+1个字符组成的子序列。

2. 单独检验只取第i+1这一个字符模3的余数是多少，那么就在相对应的位置+1。如果余数为m，那么就是dp[i+1]\[m\]+1。

3. 前i+1个字符任意组合，那么就有对于dp[i+1]\[j\]，我们肯定是必须选择第i+1个数，那么假设第i+1个数模3的余数为m，那么前i个字符组成的子序列模3的余数k必须满足：
   $$
   (m+k)\%3=j
   $$
   我们可以验证一下，比如7模3的余数为1,10模3余数也为1，那么17模3的余数就是2。这里的7的余数就是m，10的余数就是k，17的余数就是j。

得到上面的公式后，我们就打表打到最后一个字符A，那么输出他的dp[A]\[0\]即可。

#### 解题代码

```c
#include <bits/stdc++.h>
using namespace std;

const int mod = 1e9 + 7;
int dp[55][3];

int main()
{
    string s;
    cin >> s;
    int len = s.length();
    //初始化
    memset(dp, 0, sizeof(dp));
    //初始化个数
    int tmp = 0;
    //检验第一个数的余数，在相应的位置+1
    dp[0][(s[0] - '0') % 3] = 1;
    //检验后面的s-1个数，逐一加上
    for (int i = 1; i < len; i++)
    {
        //存储第i+1个数%3的结果
        tmp = (s[i] - '0') % 3;
        //只检验第i+1%3的余数并在相应的位置+1
        dp[i][tmp] = (dp[i][tmp] + 1) % mod;
        for (int j = 0; j < 3; j++)
        {
            //包含了前i个数组成序列的情况，以及第1+1的余数和前i个数组成序列的和数取余为j的情况个数
            dp[i][j] += (dp[i - 1][j] + dp[i - 1][(j + 3 - tmp) % 3]) % mod;
        }
    }
    //打印答案，因为从0开始，所以到i-1
    cout << dp[len - 1][0] % mod << endl;
    system("pause");
    return 0;
}
```

