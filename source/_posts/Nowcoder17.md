---
title: 牛客网OJ题解--20210222
comments: false
top: false
date: 2021-02-22 12:16:15
tags: [算法,C++]
categories: 算法导论
---

本系列记录翀翀😐痛苦的刷题日志，所有题目均来自于牛客网OJ题目，坚持刷题谈起来容易做起来难，希望我可以坚持下去，这里仍然分享一段励志文案：每个人都有梦想，然而有些人把梦想变成了现实，有些人的梦想依旧是梦想，只因为他们为梦想付出的努力程度不一样，他们坚持的时间不一样，最终才有这样的结果。

<!-- more -->

### NC13592-武藏牌牛奶促销

#### 题目链接

https://ac.nowcoder.com/acm/problem/13592

#### 题目描述

武藏牌牛奶为了吸引顾客，推出优惠活动，可以使用x个空的瓶身，或者y个瓶盖，去商店换一瓶全新的武藏牌牛奶。注意，一瓶牛奶包含了瓶身和瓶盖。 现在小萌老师有a个空的瓶身和b个瓶盖，她想喝到尽可能多的牛奶，你知道她到底能喝到多少瓶完整的牛奶吗？多组输入 每组数据第一行包含4个正整数x y a b(1<=x,y,a,b<=100)，意义见题目描述。对于每组数据，输出一行，表示小萌老师最多能喝多少瓶完整的牛奶。如果能喝无数瓶，输出"INF"(不要输出引号)。

#### 测试样例

输入

```c
1 3 1 1
4 3 6 4
```

输出

```c
INF
4
```

说明

```c
对于第二组测试样例，小萌老师有6个空的瓶身和4个瓶盖，她用4个瓶身和3个瓶盖换了2瓶牛奶并喝完，此时她就有4个空的瓶身和3个瓶盖。之后她再换2瓶牛奶并喝完，此时只有2个空的瓶身和2个瓶盖，就无法继续兑换了，所以答案是4
```

#### 解题思路

对于有限次兑换，很简单，就是用空瓶和瓶盖尽可能多兑换就好了，只要注意每次兑换一瓶奶以后空瓶和瓶盖都会加1即可。难点在于无限次兑换的条件，有两个，一种是x=1或者y=1的情况即可，另一种是x=2&&y=2且a+b>2。

#### 解题代码

```c
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int x, y, a, b;
    while (cin >> x >> y >> a >> b)
    {
        int ans = 0;
        if ((x == 1 || y == 1) || ((x == 2 && y == 2) && (a + b >= 2)))
        {
            cout << "INF" << endl;
            continue;
        }
        else
        {
            //否则有限次兑换
            while (a >= x || b >= y)
            {
                //用x个瓶子兑换
                if (a >= x)
                {
                    int tmp1 = a / x;
                    a = a % x;
                    a += tmp1;
                    b += tmp1;
                    ans += tmp1;
                }
                //用y个瓶盖兑换
                if (b >= y)
                {
                    int tmp2 = b / y;
                    b = b % y;
                    a += tmp2;
                    b += tmp2;
                    ans += tmp2;
                }
            }
            cout << ans << endl;
        }
    }
    system("pause");
    return 0;
}
```

### NC13253-子串

#### 题目链接

https://ac.nowcoder.com/acm/problem/13253

#### 题目描述

给出一个正整数n，我们把1..n在k进制下的表示连起来记为s(n,k)，例如s(16,16)=123456789ABCDEF10, s(5,2)=11011100101。现在对于给定的n和字符串t，我们想知道是否存在一个k(2 ≤ k ≤ 16)，使得t是s(n,k)的子串。第一行一个整数n(1 ≤ n ≤ 50,000)。 第二行一个字符串t(长度 ≤ 1,000,000)。"yes"表示存在满足条件的k，否则输出"no"

#### 测试样例

输入

```c
8
01112
```

输出

```c
yes
```

#### 解题思路

我们就是暴力枚举对于不同k进制下的1~n的字符串即可，难点在于要自己手写以下进制转换，同时最后要注意字符串是反的，需要手动翻转。最后再用find函数寻找子串即可。

#### 解题代码

```c
#include <bits/stdc++.h>
using namespace std;
 
int main()
{
    int n;
    string t, s, tmp;
    cin >> n;
    cin >> t;
    //逐一尝试1~n的k进制串表示
    for (int k = 2; k < 17; k++)
    {
        //记录1~n的k进制串
        s = "";
        for (int i = 1; i <= n; i++)
        {
            //从1~n枚举整数值
            int num = i;
            //临时存储i的k进制串，最后不断拼接成为1~n的k进制串
            tmp = "";
            //使用循环取余的方法模拟转换进制
            while (num)
            {
                int cnt = num % k;
                if (cnt < 10)
                {
                    tmp += cnt + '0';
                }
                else
                {
                    //大于9的时候用ABCDE等表示
                    tmp += 'A' + cnt - 10;
                }
                num /= k;
            }
            //最后得到的是反的，要翻转一下字符串
            reverse(tmp.begin(), tmp.end());
            s += tmp;
        }
        //find()函数寻找子串在母串中出现的第一次位置，没有则返还-1
        if (s.find(t) != -1)
        {
            cout << "yes" << endl;
            system("pause");
            return 0;
        }
    }
    cout << "no" << endl;
    system("pause");
    return 0;
}
```

### 蓝桥杯1261-移动距离

#### 题目链接

http://oj.ecustacm.cn/problem.php?id=1261&csrf=bcupvEZe4bjudajPwEvj88NJnrXQ6IWD

#### 题目描述

X星球居民小区的楼房全是一样的，并且按矩阵样式排列。
其楼房的编号为1,2,3... 当排满一行时，从下一行相邻的楼往反方向排号。
比如：当小区排号宽度为6时，开始情形如下：

1 2 3 4 5 6
12 11 10 9 8 7
13 14 15 ..... 

我们的问题是：已知了两个楼号m和n，需要求出它们之间的最短移动距离。（不能斜线方向移动）。输入存在多组测试数据，输入为3个整数w m n，空格分开，都在1到10000范围内。w为排号宽度，m,n为待计算的楼号。

#### 测试样例

输入

```c
6 8 2
4 7 20
```

输出

```c
4
5
```

#### 解题思路

实际上就是曼哈顿距离，根据给定的m,n,w两个地点的位置已经确定了，我们只需要能够找到他们的位置并求出曼哈顿距离即可。

#### 解题代码

```c
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int w, m, n;
    while (cin >> w >> m >> n)
    {
        //m必须保证小于n
        if (m > n)
        {
            int tmp = n;
            n = m;
            m = tmp;
        }
        //特例
        if (m == n)
        {
            cout << 0 << endl;
            return 0;
        }
        int i = 0;
        int j = 0;
        int num = 1;
        //位置1用(a,b)，位置二用(c,d)
        int a, b, c, d;
        //是否向右填写
        bool dirr = true;
        while (num <= n)
        {
            //找到了位置记录下来
            if (num == m)
            {
                a = i;
                b = j;
            }
            if (num == n)
            {
                c = i;
                d = j;
            }
            num++;
            if (dirr)
            {
                j++;
            }
            else
            {
                j--;
            }
            //切换方向的条件
            if (j == w)
            {
                dirr = false;
                i++;
                j = w - 1;
            }
            if (j == -1)
            {
                j = 0;
                dirr = true;
                i++;
            }
        }
        //曼哈顿距离计算公式
        cout << abs(a - c) + abs(b - d) << endl;
    }
    // system("pause");
    return 0;
}
```

#### 解题反思

上面的方法太笨了，使用模拟枚举，时间长，这里其实完全可以使用模m商为行数，余数为列数即可迅速锁定两个位置。代码如下：

```c
#include <bitsdc++.h>
using namespace std;
typedef long long ll;
 
int getl(int x, int w, int h) {
    if (h % 2 != 0)  //正向
        return (x % w);
    return w - (x % w) + 1;
}
 
signed main() {
    ios::sync_with_stdio(false), cin.tie(0);
    int w, m, n;
    while (cin >> w >> m >> n) {
        if (m > n) swap(m, n);
        int h1 = m / w + (m % w ? 1 : 0), h2 = n / w + (n % w ? 1 : 0);
        int l1 = getl(m, w, h1), l2 = getl(n, w, h2);
        cout << h2 - h1 + abs(l2 - l1) << endl;
    }
    // system("pause");
    return 0;
}
```

### 蓝桥杯1263-打印大X

#### 题目链接

http://oj.ecustacm.cn/problem.php?id=1263&csrf=DeGbAGWXj3yK3LtbE6TRFrSp0zKd37xP

#### 题目描述

小明希望用星号拼凑，打印出一个大X，他要求能够控制笔画的宽度和整个字的高度。
为了便于比对空格，所有的空白位置都以句点符来代替。要求输入两个整数m n，表示笔的宽度，X的高度。输入存在多组数据，每组测试数据输入一行，包含两个整数，用空格分开，(0<m<n, 3<n<1000, 保证n是奇数)。要求输出一个大X。

#### 测试样例

输入

```c
3 9
4 21
```

输出

```c
***.....***
.***...***.
..***.***..
...*****...
....***....
...*****...
..***.***..
.***...***.
***.....***
****................****
.****..............****.
..****............****..
...****..........****...
....****........****....
.....****......****.....
......****....****......
.......****..****.......
........********........
.........******.........
..........****..........
.........******.........
........********........
.......****..****.......
......****....****......
.....****......****.....
....****........****....
...****..........****...
..****............****..
.****..............****.
****................****
```

#### 解题思路

我们分两种情况，先打印上半部分，再打印下半部分。这里使用一个小方法简化输出，即先把这一行全部填写成.，然后设置左右\*字符串的起始位置，再循环m次替换.为*即可。难点主要是寻找起始位置。

#### 解题代码

```c
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int m, n;
    while (cin >> m >> n)
    {
        //计算一行的字符串长度
        int len = m + n - 1;
        //左、右端起始位置
        int l = 1;
        int r = len - m + 1;
        char s[len + 5];
        //上半部分包括中间行的打印
        for (int i = 0; i < (n - 1) / 2 + 1; i++)
        {
            //初始化全部填写.
            memset(s, '.', sizeof(s));
            int ll = l;
            int rr = r;
            //*替换.
            for (int i = 0; i < m; i++)
            {
                s[ll + i] = '*';
                s[rr + i] = '*';
            }
            //输出这一行
            for (int i = 1; i <= len; i++)
            {
                cout << s[i];
            }
            //下一行左起始位置右移，右起始位置左移
            l++;
            r--;
            //换行输出下一行
            cout << endl;
        }
        // l = (n - 1) / 2;会wa
        // r = (len - 1) / 2 + 1;会wa，貌似是起点位置不够具有普遍性
        //正确的起始位置，就是相较于刚刚的中间行的左右起始位置分别左移1个和右移1格
        l-=2;
        r+=2;
        //特判，不加貌似也对
        if(m==1){
            r=(len+1)/2+1;
        }
        //打印下半部分
        for (int i = 0; i < (n - 1) / 2; i++)
        {
            memset(s, '.', sizeof(s));
            int ll = l;
            int rr = r;
            for (int i = 0; i < m; i++)
            {
                s[ll + i] = '*';
                s[rr + i] = '*';
            }
            for (int i = 1; i <= len; i++)
            {
                cout << s[i];
            }
            l--;
            r++;
            cout << endl;
        }
    }
    // system("pause");
    return 0;
}
```

