---
title: 牛客网OJ题解--20210227
comments: false
top: false
date: 2021-02-27 14:13:03
tags: [算法,C++]
categories: 
	- [刷题日志]
---

本系列记录翀翀😐痛苦的刷题日志，所有题目均来自于牛客网OJ题目，坚持刷题谈起来容易做起来难，希望我可以坚持下去，这里仍然分享一段励志文案：每个人都有梦想，然而有些人把梦想变成了现实，有些人的梦想依旧是梦想，只因为他们为梦想付出的努力程度不一样，他们坚持的时间不一样，最终才有这样的结果。

<!-- more -->

### NC13223-锦标赛

#### 题目链接

https://ac.nowcoder.com/acm/problem/13223

#### 题目描述

组委会正在为美团点评CodeM大赛的决赛设计新赛制。比赛有 n 个人参加（其中 n 为2的幂），每个参赛者根据资格赛和预赛、复赛的成绩，会有不同的积分。比赛采取锦标赛赛制，分轮次进行，设某一轮有 m 个人参加，那么参赛者会被分为 m/2 组，每组恰好 2 人，m/2 组的人分别厮杀。我们假定积分高的人肯定获胜，若积分一样，则随机产生获胜者。获胜者获得参加下一轮的资格，输的人被淘汰。重复这个过程，直至决出冠军。现在请问，参赛者小美最多可以活到第几轮（初始为第0轮）？

第一行一个整数 n (1≤n≤ 2^20)，表示参加比赛的总人数。接下来 n 个数字（数字范围：-1000000…1000000），表示每个参赛者的积分。小美是第一个参赛者。小美最多参赛的轮次。

#### 测试样例

输入

```c
4
4 1 2 3
```

输出

```c
2
```

#### 解题思路

我们统计一下小于等于小妹积分的人数，对于每一次比赛，都是人数/2，所以每一次比赛后小于等于小妹积分的人数也会减小2倍，这样当没有小于等于小妹积分的人时小妹就该淘汰了，所以只需检验人数是2的几次方即可。

#### 解题代码

```c
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int a, b, n, j = 1;
    cin >> n;
    cin >> a;
    for (int i = 1; i < n; i++)
    {
        cin >> b;
        //找出所有小于mei积分的人数
        if (b <= a)
            j++;
    }
    //最后求出取2对数的向下取整即为答案，小美可以进行的最多轮数
    cout << (int)log2(j) << endl;
    system("pause");
    return 0;
}
```

### NC14503-晨跑

#### 题目链接

https://ac.nowcoder.com/acm/problem/14503

#### 题目描述

“无体育，不清华”、“每天锻炼一小时，健康工作五十年，幸福生活一辈子”。在清华，体育运动绝对是同学们生活中不可或缺的一部分。为了响应学校的号召，模范好学生王队长决定坚持晨跑。不过由于种种原因，每天都早起去跑步不太现实，所以王队长决定每a天晨跑一次。换句话说，假如王队长某天早起去跑了步，之后他会休息a-1天，然后第a天继续去晨跑，并以此类推。王队长的好朋友小钦和小针深受王队长坚持锻炼的鼓舞，并决定自己也要坚持晨跑。为了适宜自己的情况，小钦决定每b天早起跑步一次，而小针决定每c天早起跑步一次。某天早晨，王队长、小钦和小针在早起跑步时相遇了，他们非常激动、相互鼓励，共同完成了一次完美的晨跑。为了表述方便，我们把三位同学相遇的这天记为第0天。假设三位同学每次晨跑的时间段和路线都相同，他们想知道，下一次三人在跑步时相遇是第几天。由于三位同学都不会算，所以希望由聪明的你来告诉他们答案。

输入共一行，包含三个正整数a,b,c，表示王队长每隔a天晨跑一次、小钦每隔b天晨跑一次且小针每隔c天晨跑一次。输出共一行，包含一个正整数x，表示三位同学下次将在第x天相遇。

#### 测试样例

输入

```c
2 3 5
```

输出

```c
30
```

#### 解题思路

实际上就是求解a,b,c三者的最小公倍数。可以先对a,b求最小公倍数，再求ab的最小公倍数与c的最小公倍数即可。这里主要是记录一下板子。并且最小公倍数=两个数相乘/最大公约数。

#### 解题代码

```c
#include <bits/stdc++.h>
using namespace std;

//最小公倍数=两数乘积/最大公约数
long f(long a, long b)
{
    long m = a * b;
    //最大公约数--相减法
    //     while(a<b || a>b){
    //        if(a<b)b=b-a;//此时最终b是最大公约数
    //        if(a>b)a=a-b;//此时最终a是最大公约数
    //    }

    /*最大公约数--辗转相除法*/
    if (b > a)
        swap(a, b);
    long c = a % b;
    while (c != 0)
    {
        a = b;
        b = c;
        c = a % b;
    }//此时b是最大公约数

    return m / b;
}
int main()
{
    long a, b, c;
    cin >> a >> b >> c;
    long cnt = f(a, b);
    long ans = f(cnt, c);
    cout << ans << endl;
    system("pause");
    return 0;
}
```

