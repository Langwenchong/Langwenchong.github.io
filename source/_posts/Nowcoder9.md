---
title: 牛客网OJ题解--20210207
comments: false
top: false
date: 2021-02-07 17:32:22
tags: [算法,C++]
categories: 算法导论
---

本系列记录翀翀😐痛苦的刷题日志，所有题目均来自于牛客网OJ题目，坚持刷题谈起来容易做起来难，希望我可以坚持下去，这里仍然分享一段励志文案：每个人都有梦想，然而有些人把梦想变成了现实，有些人的梦想依旧是梦想，只因为他们为梦想付出的努力程度不一样，他们坚持的时间不一样，最终才有这样的结果。

<!-- more -->

### NC21800-最佳射击

#### 题目链接

https://ac.nowcoder.com/acm/problem/21800

#### 题目描述

平面直角坐标系上有一些点，你可以进行0或者若干次操作
 每次操作可以将所有的点往某个方向平移也可以将所有的点绕着(0,0)旋转任意角度你射击一枪能够射到x轴与y轴上的所有点，你希望经过若干次操作后，射击一枪能击中尽可能多的点，求最多可以击中几个点。

第一行输入一个整数n (1 ≤ n ≤ 50)
第二行输入n个整数表示x坐标
第三行输入n个整数表示y坐标
(坐标的范围在[-1000000,1000000]之间)

#### 测试样例

##### 样例1

输入

```c
2
0 5
0 5
```

输出

```c
2
```

##### 样例2

输入

```c
5
0 -1 1 1 -1
0 -1 -1 1 1
```

输出

```c
5
```

##### 样例3

输入

```c
9
0 -3 3 3 -3 0 0 3 -3
0 -3 -3 3 3 3 -3 0 0
```

输出

```c
5
```

#### 解题思路

我们任取两个点组成x轴，在取一个点向x轴做垂线形成y轴，然后对于所有剩余的点暴力枚举是否在x轴或者y轴的延长线上。如果在，那么这个点就可以被射中，最后输出最好情况即可。细节1在于做x,y轴的三个点必须是不同的点，且检验的其余点也必须和着三个点不同，细节2发现当点的个数不多于3个时，那么必定可以一次射中这三个点，直接输出n值即可。检验被检验点是否在x轴的延长线上很简单，使用x轴的两个组成点和被检验点组成两个斜率即可进行检验，若相同，就在x轴延长线上，但是检验是否在y轴延长线上时，因为只有一个已知组成点，垂足坐标（或者x,y轴相较的原点）我们不知道也不好求，我们可以让被检验点和y轴上的已知点形成向量1，x轴的两个组成点形成向量2，如果向量1和向量2满足x1x2+y1y2=0也可以证明被检验点在y轴延长线上。

#### 解题代码

```c
#include <bits/stdc++.h>
using namespace std;

int num = 0;      //答案初始化
int x[55], y[55]; //x,y坐标存储

int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> x[i];
    }
    for (int i = 1; i <= n; i++)
    {
        cin >> y[i];
    }
    if (n <= 3)
    {
        //点数少于三个必定可以全部射中，即两个点做x轴，第三个点引垂线做y轴即可
        cout << n << endl;
        system("pause");
        return 0;
    }
    //点数多于3个
    for (int i = 1; i <= n; i++)
    {
        //先选一个点i
        for (int j = 1; j <= n; j++)
        {
            //和j不同的点i，ij组成x轴
            if (i == j)
                continue;
            for (int k = 1; k <= n; k++)
            {
                //k不同于i,j，引垂线垂直于ij作为y轴
                if (k == i || k == j)
                    continue;
                int ans = 3;
                for (int f = 1; f <= n; f++)
                {
                    //检验剩余的f点，肯定是不同于i,j,k
                    if (f == i || f == j || f == k)
                        continue;
                    //在y轴延长线上，使用向量检查
                    int vec1_x = x[i] - x[j]; //向量1（ij向量）X
                    int vec1_y = y[i] - y[j]; //向量1Y
                    int vec2_x = x[k] - x[f]; //向量2（kf向量)X
                    int vec2_y = y[k] - y[f]; //向量2Y
                    //向量检验：X,Y向量满足x1x2+y1y2=0即证明在
                    if (vec1_x * vec2_x + vec1_y * vec2_y == 0)
                        //f添加
                        ans++;
                    //或者f与组成的x轴共线，使用斜率检验
                    else if ((x[i] - x[f]) * (y[f] - y[j]) == (x[f] - x[j]) * (y[i] - y[f]))
                        ans++;
                }
                num = max(num, ans);
            }
        }
    }
    cout << num << endl;
    system("pause");
    return 0;
}
```

### NC16639-奖学金

#### 题目链接

https://ac.nowcoder.com/acm/problem/16639

#### 题目描述

某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前5名学生发奖学金。期末，每个学生都有3门课的成绩:语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学 排在前面，这样，每个学生的排序是唯一确定的。 
 任务：先根据输入的3门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名名学生的学号和总分。注意，在前5名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据(每行输出两个数:学号、总分) 是: 
 7 279 
 5 279 
 这两行数据的含义是:总分最高的两个同学的学号依次是7号、5号。这两名同学的总分都是 279 (总分等于输入的语文、数学、英语三科成绩之和) ，但学号为7的学生语文成绩更高一些。如果你的前两名的输出数据是: 
 5 279 
 7 279 
 则按输出错误处理，不能得分。

第1行为一个正整数n，表示该校参加评选的学生人数。
第2到n+1行，每行有3个用空格隔开的数字，每个数字都在O到100之间z第1行的3个数 字依次表示学号为j-1的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为l~n (恰好是输入数据的行号减1)。
所给的数据都是正确的，不必检验。保证6<=n<=300。

#### 测试样例

##### 样例1

输入

```c
6 
90 67 80 
87 66 91 
78 89 91 
88 99 77 
67 89 64 
78 89 98
```

输出

```c
6 265
4 264
3 258
2 244
1 237
```

##### 样例2

输入

```c
8 
80 89 89 
88 98 78 
90 67 80 
87 66 91 
78 89 91 
88 99 77 
67 89 64 
78 89 98
```

输出

```c
8 
80 89 89 
88 98 78 
90 67 80 
87 66 91 
78 89 91 
88 99 77 
67 89 64 
78 89 98
```

#### 解题思路

主要就是要声明一个学生结构体即可，然后重置一下sort()比较规则。

#### 解题代码

```c
#include <bits/stdc++.h>
using namespace std;

struct Student
{
    int Ch;
    int Math;
    int Eng;
    int sum;
    int id;
} s[305];

bool cmp(Student a, Student b)
{
    if (a.sum != b.sum)
    {
        return a.sum > b.sum;
    }
    else
    {
        if (a.Ch != b.Ch)
        {
            return a.Ch > b.Ch;
        }
        else
        {
            return a.id < b.id;
        }
    }
}
int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> s[i].Ch >> s[i].Math >> s[i].Eng;
        s[i].id = i;
        s[i].sum = s[i].Ch + s[i].Math + s[i].Eng;
    }
    sort(s + 1, s + n + 1, cmp);
    for (int i = 1; i <= 5; i++)
    {
        cout << s[i].id << " " << s[i].sum << endl;
    }
    system("pause");
    return 0;
}
```

