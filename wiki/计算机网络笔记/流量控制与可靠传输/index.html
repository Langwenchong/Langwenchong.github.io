<!DOCTYPE html>
<html lang='zh-CN'>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?fc63ac4843a697431e3d43c4d48b99de";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://fastly.jsdelivr.net'>
  <link rel="preconnect" href="https://fastly.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>ComputerNetwork：流量传输与可靠传输 - 雨中•学圃堂</title>

  
    <meta name="description" content="流量控制 我们在前面的流量控制中学习到流量控制涉及对链路上的帧的发送速率的控制，以便使接收方能够有足够的缓冲时间来接收每一个帧。例如：在面向帧的自动重传请求系统中，当待确认帧的数量增加时，有可能就会超出缓冲存储空间而造成过载。此时流量控制的基本方法是由接收方控制发送方发送数据的速率，常见的方法有两种：①停止-等待协议②滑动窗口协议  停止-等待协议流量控制原理 在停止-等待协议中每发送一个帧，都">
<meta property="og:type" content="website">
<meta property="og:title" content="流量传输与可靠传输">
<meta property="og:url" content="https://scholar.coolchong.cn/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/index.html">
<meta property="og:site_name" content="雨中•学圃堂">
<meta property="og:description" content="流量控制 我们在前面的流量控制中学习到流量控制涉及对链路上的帧的发送速率的控制，以便使接收方能够有足够的缓冲时间来接收每一个帧。例如：在面向帧的自动重传请求系统中，当待确认帧的数量增加时，有可能就会超出缓冲存储空间而造成过载。此时流量控制的基本方法是由接收方控制发送方发送数据的速率，常见的方法有两种：①停止-等待协议②滑动窗口协议  停止-等待协议流量控制原理 在停止-等待协议中每发送一个帧，都">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210822144429.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210822155643.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210822155907.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210822155931.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210822151136.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210822161144.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210822161608.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210822145434.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210822145516.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210822163120.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210822163500.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210822155907.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210822172518.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210822192604.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210822194046.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20191113192200848.gif">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20191113192200848888.gif">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210822202353.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210822205608.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210823113218.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210823113531.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210823114203.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210823115001.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210823115847.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20191113201934575.gif">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20191113205433523.gif">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20210823122707.png">
<meta property="article:published_time" content="2023-01-28T07:59:49.920Z">
<meta property="article:modified_time" content="2023-01-28T07:59:49.920Z">
<meta property="article:author" content="Wenchong Lang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://langwenchong.gitee.io/figure-bed/20210822144429.png">
  
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="雨中•学圃堂" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="https://cdn.coolchong.cn/%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/langwenchong.png">
  

  
    
<link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/github.min.css">

  

  
    <link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
    <script defer src="https://fastly.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js" ></script>
    <script defer src="https://fastly.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
  


  
    
      <link href="https://fonts.font.im/css?family=Dancing+Script" rel="stylesheet">
    
      <link href="https://fastly.jsdelivr.net/gh/volantis-x/cdn-fontawesome-pro@master/css/all.min.css" rel="stylesheet">
    
      <link href="https://gcore.jsdelivr.net/gh/highlightjs/cdn-release@11.5.0/build/styles/github-dark.min.css">
    
  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='wiki'>
    

  




<div class="widgets"><widget class="widget-wrapper logo-wrap wiki"><div class="widget-body"><a style="filter: grayscale(100%)" class="wiki-home cap" href="/wiki"><svg aria-hidden="true" viewBox="0 0 16 16" width="1rem" height="1rem" fill="currentColor"><path fill-rule="evenodd" d="M7.78 12.53a.75.75 0 01-1.06 0L2.47 8.28a.75.75 0 010-1.06l4.25-4.25a.75.75 0 011.06 1.06L4.81 7h7.44a.75.75 0 010 1.5H4.81l2.97 2.97a.75.75 0 010 1.06z"></path></svg>所有笔记</a><a class="title" href="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html"><div class="main" ff="title">ComputerNetwork</div><div class="sub cap">数据是如何进行通信的呢？</div></a></div></widget>
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/wiki/计算机网络笔记/" placeholder="想找点什么？"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">好像并未找到什么！</div></div></div></widget>




<widget class="widget-wrapper toc multi" id="data-toc"><div class="widget-header cap dis-select"><span class="name">计网概述</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html#start"><span class="toc-text">什么是计算机网络</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82/index.html"><span class="toc-text">计算机网络分层</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E5%B8%B8%E8%A7%81%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/index.html"><span class="toc-text">常见分层结构</span></a></div></div><div class="widget-header cap dis-select"><span class="name">物理层</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/index.html"><span class="toc-text">通信基础</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E4%B8%8E%E4%BA%A4%E6%8D%A2/index.html"><span class="toc-text">数据生成与交换</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8%E4%B8%8E%E8%AE%BE%E5%A4%87/index.html"><span class="toc-text">传输介质与设备</span></a></div></div><div class="widget-header cap dis-select"><span class="name">数据链路层</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/DL%E5%B1%82%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BB%84%E5%B8%A7/index.html"><span class="toc-text">DL层功能与组帧</span></a></div><div class="doc-tree active"><a class="doc-tree-link active" href="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/index.html"><span class="toc-text">流量传输与可靠传输</span></a><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text"> 流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2-%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-text"> 停止-等待协议流量控制原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E5%B7%B2%E7%BB%8F%E6%9C%89%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6%E4%BA%86%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E5%81%9C-%E7%AD%89%E5%8D%8F%E8%AE%AE"><span class="toc-text"> 思考：已经有差错检测机制了，为什么还需要停-等协议？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E7%A0%94%E7%A9%B6%E5%81%9C-%E7%AD%89%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%89%8D%E6%8F%90%E5%AE%83%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%80%E5%B1%82%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-text"> 思考：研究停-等协议的前提？它属于哪一层的协议？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E5%81%9C-%E7%AD%89%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%87%A0%E7%A7%8D%E5%BA%94%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-text"> 思考：停-等协议有几种应用情况?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E8%BF%98%E6%9C%89%E6%B2%A1%E6%9C%89%E5%85%B6%E4%BB%96%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E5%B7%AE%E9%94%99%E6%83%85%E5%86%B5"><span class="toc-text"> 思考：还有没有其他可能出现的差错情况？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E5%81%9C-%E7%AD%89%E5%8D%8F%E8%AE%AE%E4%BB%85%E4%BB%85%E4%BD%BF%E7%94%A8%E4%BA%860%E5%92%8C1%E5%8F%AF%E4%BB%A5%E5%AE%8C%E6%88%90%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B8%A7%E7%9A%84%E4%BC%A0%E8%BE%93%E5%90%97"><span class="toc-text"> 思考：停-等协议仅仅使用了0和1可以完成所有的数据帧的传输吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E5%BA%8F%E5%88%97%E5%8F%B7%E7%9B%B8%E5%90%8C%E7%9A%84%E5%B8%A7%E6%95%B0%E6%8D%AE%E4%B8%80%E5%AE%9A%E7%9B%B8%E5%90%8C"><span class="toc-text"> 思考：序列号相同的帧数据一定相同？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E6%8E%A5%E6%94%B6%E5%8F%8C%E6%96%B9%E7%9A%84%E7%89%B9%E5%AE%9A%E6%80%BB%E7%BB%93"><span class="toc-text"> 思考：接收双方的特定总结？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E5%B0%86%E6%95%B0%E6%8D%AE%E5%B8%A7%E4%BF%A1%E6%81%AF%E9%94%99%E8%AF%AF%E7%9A%84%E6%83%85%E5%86%B5%E6%94%B9%E8%BF%9B%E4%B8%BA%E4%B8%8B%E9%9D%A2%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%98%AF%E5%90%A6%E5%90%88%E7%90%86"><span class="toc-text"> 思考：将数据帧信息错误的情况改进为下面这种方式是否合理？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E5%81%9C-%E7%AD%89%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text"> 思考：停-等协议的优缺点？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-text"> 例题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-text"> 滑动窗口协议流量控制原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8D%8F%E8%AE%AE"><span class="toc-text"> 流水线协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%85%A5%E4%BA%86%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%9C%BA%E5%88%B6%E5%90%8E%E5%92%8C%E5%81%9C-%E7%AD%89%E5%8D%8F%E8%AE%AE%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text"> 思考：滑动窗口协议加入了流水线机制后和停-等协议有什么区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE"><span class="toc-text"> 滑动窗口协议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6"><span class="toc-text"> 可靠传输机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%B8%A7%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%81%9C%E6%AD%A2-%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE"><span class="toc-text"> 单帧滑动窗口与停止-等待协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%B8%A7%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%90%8E%E9%80%80n%E5%B8%A7%E5%8D%8F%E8%AE%AEgbn"><span class="toc-text"> 多帧滑动窗口与后退N帧协议（GBN）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%96%B9%E7%AA%97%E5%8F%A3%E5%88%92%E5%88%86"><span class="toc-text"> 发送方窗口划分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#gbn%E5%8F%91%E9%80%81%E6%96%B9%E5%BF%85%E9%A1%BB%E5%93%8D%E5%BA%94%E7%9A%84%E4%B8%89%E4%BB%B6%E4%BA%8B"><span class="toc-text"> GBN发送方必须响应的三件事</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#gbn%E6%8E%A5%E6%94%B6%E6%96%B9%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B"><span class="toc-text"> GBN接收方要做的事</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%9B%BE%E8%AE%B2%E8%A7%A3"><span class="toc-text"> 静态图讲解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%9B%BE%E8%AE%B2%E8%A7%A3"><span class="toc-text"> 动态图讲解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%84%E5%BE%8B%E6%80%BB%E7%BB%93"><span class="toc-text"> 规律总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%96%B9%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE"><span class="toc-text"> 发送方状态转换图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE"><span class="toc-text"> 接收方状态转换图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6"><span class="toc-text"> 发送窗口大小限制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#gbn%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text"> GBN性能分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-2"><span class="toc-text"> 例题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%B8%A7%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0%E5%8D%8F%E8%AE%AEsr"><span class="toc-text"> 多帧滑动窗口与选择重传协议（SR）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%96%B9-%E6%8E%A5%E6%94%B6%E6%96%B9%E7%AA%97%E5%8F%A3%E5%88%92%E5%88%86"><span class="toc-text"> 发送方、接收方窗口划分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sr%E5%8F%91%E9%80%81%E6%96%B9%E5%BF%85%E9%A1%BB%E5%93%8D%E5%BA%94%E7%9A%84%E4%B8%89%E4%BB%B6%E4%BA%8B"><span class="toc-text"> SR发送方必须响应的三件事</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sr%E6%8E%A5%E6%94%B6%E6%96%B9%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B"><span class="toc-text"> SR接收方要做的事</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%9B%BE%E8%AE%B2%E8%A7%A3-2"><span class="toc-text"> 静态图讲解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%9B%BE%E8%AE%B2%E8%A7%A3-2"><span class="toc-text"> 动态图讲解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%84%E5%BE%8B%E6%80%BB%E7%BB%93-2"><span class="toc-text"> 规律总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E4%B8%8E%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6"><span class="toc-text"> 发送窗口与接收窗口大小限制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-3"><span class="toc-text"> 例题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text"> 性能分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text"> 总结</span></a></li></ol></li></ol></div></div></widget>



<widget class="widget-wrapper related"><div class="widget-header cap theme dis-select"><span class="name">更多计算机基础</span></div><div class="widget-body related-posts"><a class="item wiki" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html"><span class="title">操作系统笔记</span><span class="excerpt">操作系统是每一名计算机科班生都必会的基础内容之一，借着考研的机会我参考王道图书重新学习了操作系统并记录下了我的一些浅显理解。</span></a><a class="item wiki" href="/wiki/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E6%9C%AC%E5%85%83%E4%BB%B6/index.html"><span class="title">数字逻辑与数字系统笔记</span><span class="excerpt">本门课程是由我最喜欢的王立老师精编的原创课程，深入浅出的讲解带领我们从零开始自己尝试设计一个指令集架构，还不进来看一看？</span></a><a class="item wiki" href="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/index.html"><span class="title">计算机组成原理笔记</span><span class="excerpt">计算机组成原理是每一名计算机科班生都必会的基础内容之一，借着考研的机会我参考王道图书重新学习了操作系统并记录下了我的一些浅显理解。</span></a><a class="item wiki" href="/wiki/%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/index.html"><span class="title">手撕算法笔记</span><span class="excerpt">程序=数据结构+算法,世界上最优秀的程序一定使用了最先进优雅的算法，让我们一同进入算法的世界中学习，感受编程的魅力吧！</span></a></div></widget>
</div>


    </aside>
    <div class='l_main'>
      

      <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?fc63ac4843a697431e3d43c4d48b99de";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
</script>



  
  
<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" id="home" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" id="menu" href="/wiki/">笔记</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">ComputerNetwork</a></div><div id="post-meta">更新于&nbsp;<time datetime="2023-01-28T07:59:49.920Z">2023-01-28</time></div></div>

  <article class='md-text content wiki reveal'>
  <h1 class="article-title"><span>流量传输与可靠传输</span></h1>
  <h3 id="流量控制"><a class="markdownIt-Anchor" href="#流量控制"></a> 流量控制</h3>
<p>我们在前面的流量控制中学习到流量控制涉及对链路上的帧的发送速率的控制，以便使接收方能够有足够的缓冲时间来接收每一个帧。例如：在面向帧的自动重传请求系统中，当待确认帧的数量增加时，有可能就会超出缓冲存储空间而造成过载。此时流量控制的基本方法是由接收方控制发送方发送数据的速率，常见的方法有两种：①停止-等待协议②滑动窗口协议</p>
<h4 id="停止-等待协议流量控制原理"><a class="markdownIt-Anchor" href="#停止-等待协议流量控制原理"></a> 停止-等待协议流量控制原理</h4>
<p>在停止-等待协议中每发送一个帧，都要等待接收方的应答信号，之后才能发送下一个帧，<strong>接收方每接收一个正确信息的帧，都要反馈一个应答信号</strong>，表示可以接收下一个帧，如果接收方不反馈应答信号或者应答信号在传输过程中丢失，那么发送方就必须一直等待应答信号。这种协议的原理很简单，每次只允许发送一个帧，然后就陷入等待接收方确认信息的过程中，因此传输的效率很低。</p>
<div class="tag-plugin note" color="yellow"><div class="title">一定要牢记上面接收方的特点，他说明了以下几种情况：</div><div class="body"><ol><li>接收方只要收到数据正确的帧，就发送一次ACK并且发送的ACK所携带的序列号是最近一次接收到的正确的帧的序列号 2. 接收方当收到数据错误的帧时，不会发送任何应答信息，<code>保持沉默</code> 3. 接收方收到重传的已经接收过的正确数据帧时，会丢弃这个重传帧，并且发送应答信息</li></ol></div></div>
<h5 id="思考已经有差错检测机制了为什么还需要停-等协议"><a class="markdownIt-Anchor" href="#思考已经有差错检测机制了为什么还需要停-等协议"></a> 思考：已经有差错检测机制了，为什么还需要停-等协议？</h5>
<p>帧除了出现比特差错（可以直接被校验和检测）以外，还可能出现帧错，即底层信道出现了丢包问题，此时需要停-等协议来实现流量控制。</p>
<div class="tag-plugin note" color="yellow"><div class="body"><p>丢包：物理线路故障、设备故障、病毒攻击、路由信息错误等原因都会导致数据包的丢失</p></div></div>
<h5 id="思考研究停-等协议的前提它属于哪一层的协议"><a class="markdownIt-Anchor" href="#思考研究停-等协议的前提它属于哪一层的协议"></a> 思考：研究停-等协议的前提？它属于哪一层的协议？</h5>
<p>虽然现在常用全双工通信方式，即双方可以同时发送消息，但是这里为了方便讨论，仅考虑一方发送数据（发送方）和接收数据（接收方）。因为是在讨论可靠传输的原理，因此并不考虑数据是在哪一个层次上传送。在不同的参考书中，停-等协议以及滑动窗口协议被分别划分到了数据链路层、网络层或者传输层等。</p>
<h5 id="思考停-等协议有几种应用情况"><a class="markdownIt-Anchor" href="#思考停-等协议有几种应用情况"></a> 思考：停-等协议有几种应用情况?</h5>
<p>两种：①无差错情况②有差错情况。所谓的无差错情况就是理想情况，即传送的帧不会丢失并且数据必定无错误，此时的传送情况如下图：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210822144429.png" alt="" /></p>
<p>而在实际的传输中，经常会伴随着差错的出现因此有差错情况的传送更加普遍：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210822155643.png" alt="" /></p>
<p>我们从上图可以看出在有差错情况下的停-等协议中加入了计时器功能，<strong>当发送帧在中途丢失时或者接收的数据帧有错误时接收方都不会发送应答信息</strong>，当经过一个时钟周期后计时器可以报错给发送方请求重发从而解决收发双方陷入死循环的情况。</p>
<p>同时帧到达接收方后可能发生了数据的错误而被接收方丢弃，此时帧也需要重发，因此发送方在发送了一个帧后并不会立刻丢弃这个副本，而是保留这个帧的副本以便重发之需，只有当接收到应答信息ACK后才会丢弃这个已发送帧的副本。</p>
<div class="tag-plugin note" color="yellow"><div class="body"><p>我们要特别特别注意接收方的特点，当发生帧错或者比特错误时接收方都不会发送应答信息，当双方会保持一段时间的<code>僵局</code>（即双方都等待对方的消息），然后计时器超时发送方打破<code>僵局</code>重传刚刚发送的帧。</p></div></div>
<h5 id="思考还有没有其他可能出现的差错情况"><a class="markdownIt-Anchor" href="#思考还有没有其他可能出现的差错情况"></a> 思考：还有没有其他可能出现的差错情况？</h5>
<p>当然有，可能ACK会发生丢失，此时如下图：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210822155907.png" alt="" /></p>
<p>或者还有可能出现ACK迟到的问题：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210822155931.png" alt="" /></p>
<p>此时发送方已经成功接收到了重传以后的0帧的ACK0了并且开始下一个1帧的发送了，此时却刚刚收到之前迟到的ACK0，此时发现要等待接收的应答消息ACK序列号和接收到的应答信息ACK序列号不同那么就丢弃继续等待正确的ACK序列号。</p>
<h5 id="思考停-等协议仅仅使用了0和1可以完成所有的数据帧的传输吗"><a class="markdownIt-Anchor" href="#思考停-等协议仅仅使用了0和1可以完成所有的数据帧的传输吗"></a> 思考：停-等协议仅仅使用了0和1可以完成所有的数据帧的传输吗？</h5>
<p>当然可以，因为在停-等协议中我们是一帧一帧的发送，因此我们只需要将当前帧和下一个帧区分开即可，因此一个用0一个用1就可以完美的区分当前帧和下一帧。</p>
<h5 id="思考序列号相同的帧数据一定相同"><a class="markdownIt-Anchor" href="#思考序列号相同的帧数据一定相同"></a> 思考：序列号相同的帧数据一定相同？</h5>
<p>很明显不是。我们要透彻理解序列号的作用，他不是一个独一无二的标识唯一帧的标志，而仅仅是区分当前发送帧和下一个要发送帧的。比如现在有如下帧A,B,C,D，我们从0开始标号，那么它们的序列号分别是0(A)，1(B)，0©，1(D)即A和D的序列号都是0，因此序列号不同的数据帧数据可能是不同的。ACK的序列号同理。</p>
<div class="tag-plugin note" color="yellow"><div class="body"><p>由于每次传输只涉及当前帧和下一帧两个状态，因此序列号相同而数据不同的帧不可能在一个停-等传输过程中同时出现。如A和D不可能出现在一个传输RTT中，因此0和1序列号就可以完美实现停-等协议的功能了。</p></div></div>
<h5 id="思考接收双方的特定总结"><a class="markdownIt-Anchor" href="#思考接收双方的特定总结"></a> 思考：接收双方的特定总结？</h5>
<ul>
<li>接收方必须是收到正确数据的帧时才会发送应答信息，当收到重复的正确帧时丢弃重复的帧并且由于此时这个重复帧也是正确的数据，因此接收方也会发送应答信息</li>
<li>接收方每次发送的应答信息都是最近一次成功接收到的正确数据帧的序列号</li>
<li>发送方有以下状态
<ol>
<li>发送一个帧后会先保留帧的副本，然后等待与发送帧的序列号相同的ACK，当收到的ACK序列号和要等待的相同，那么发送成功，丢弃这个刚刚发送的帧的副本</li>
<li>发送一个帧后会先保留帧的副本，然后等待与发送帧的序列号相同的ACK，当发生了帧丢失或者帧数据错误时，由于接收方会<code>保持沉默</code>，因此计时器超时后发送方重发刚刚的帧</li>
<li>发送一个帧后会先保留帧的副本，然后等待与发送帧的序列号相同的ACK，当收到的ACK序列号和要等待的不同时，说明此时出现了<code>ACK迟到</code>的情况，因此这个序列号不对的ACK是上一个已经成功完成传输的帧的应答信息，发送方直接丢弃这个序列号不对的ACK，继续等待正确的ACK抵达</li>
</ol>
</li>
</ul>
<h5 id="思考将数据帧信息错误的情况改进为下面这种方式是否合理"><a class="markdownIt-Anchor" href="#思考将数据帧信息错误的情况改进为下面这种方式是否合理"></a> 思考：将数据帧信息错误的情况改进为下面这种方式是否合理？</h5>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210822151136.png" alt="" /></p>
<p>我们发现在帧发生比特错误的情况下接收方并不会应答导致了很长时间的等待出现，那么我们能不能将其改进，让接收方应答，此时收发双方的特点变成了这样，请问是否合理？</p>
<ul>
<li>接收方无论是否接收到了正确的帧数据，都要传达一个应答信息，这个应答信息是他最近接收到的正确的帧的序列号</li>
<li>接收方只有对正确无误的数据帧进行接收，而对于由比特错误的帧要丢弃，但是仍然会发送一个应答信息，显然这个应答信息是上一个正确的数据帧的序列号</li>
<li>发送方有两个状态：
<ol>
<li>等待接收的ACK序列号和已发送的帧的序列号相同时，说明刚刚发送的帧无错误在抵达接收方后被成功接收了</li>
<li>等待接收的ACK序列号和已发送的帧的序列号不同时，说明刚刚发送的帧有错误在抵达接收方后被丢弃了，此时需要重传刚刚发送的帧</li>
</ol>
</li>
</ul>
<p>我们乍一看感觉没有毛病呀😀，这种对策可以有效减少因比特翻转导致的帧数据错误时的等待时间，但是实际上上面这种策略时有很大缺陷的，即他会导致和下面的<code>ACK迟到</code>情况区分不开而造成一系列的错误链式反应：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210822161144.png" alt="" /></p>
<p>如果按照上面的策略，那么此时发送方接收到这个迟到的ACK0时会误认为刚刚发送的1帧错误了而导致发送方又要重传1帧。而对于之前的策略，发送方接收到这个迟到的ACK时是直接丢弃的，这样就不会出现发送方重传1帧的情况了，因此这种优化策略是错误的。<strong>即接收方收到错误的数据帧时保持沉默是必要且正确的最优策略</strong>。</p>
<div class="tag-plugin note" color="yellow"><div class="body"><p>一定要注意上面刚刚所介绍的改进策略是错误的，不要和前面所讲的停-等协议的策略混淆</p></div></div>
<h5 id="思考停-等协议的优缺点"><a class="markdownIt-Anchor" href="#思考停-等协议的优缺点"></a> 思考：停-等协议的优缺点？</h5>
<p>很明显停-等协议的优点就是原理简单，实现起来很容易，但是缺点过于明显，无论是帧丢失还是帧的数据错误都会触发很长时间的<code>等待僵局</code>从而造成信道利用率过低：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210822161608.png" alt="" /></p>
<p>信道利用率公式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>信道利用率</mtext><mo>=</mo><mtext>传输时间</mtext><mi mathvariant="normal">/</mi><mtext>传输周期</mtext></mrow><annotation encoding="application/x-tex">信道利用率=传输时间/传输周期
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">道</span><span class="mord cjk_fallback">利</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">率</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord">/</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">周</span><span class="mord cjk_fallback">期</span></span></span></span></span></p>
<p>即</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>信道利用率</mtext><mo>=</mo><mtext>（</mtext><mi>L</mi><mi mathvariant="normal">/</mi><mi>R</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>T</mi><mo>=</mo><msub><mi>T</mi><mi>D</mi></msub><mi mathvariant="normal">/</mi><msub><mi>T</mi><mi>D</mi></msub><mo>+</mo><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><msub><mi>T</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">信道利用率=（L/R)/T=T_D/T_D+RTT+T_A
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">道</span><span class="mord cjk_fallback">利</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">率</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>这里我们从时间角度对信道利用率进行了定义：即对发送方而言，值指发送方在一个发送周期的时间内，有效的发送数据所需要的时间占整个发送周期的比率。并且信道吞吐率与信道利用率有如下关系：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>信道吞吐率</mtext><mo>=</mo><mtext>信道利用率</mtext><mo>×</mo><mtext>发送方的发送速率</mtext></mrow><annotation encoding="application/x-tex">信道吞吐率=信道利用率×发送方的发送速率
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">道</span><span class="mord cjk_fallback">吞</span><span class="mord cjk_fallback">吐</span><span class="mord cjk_fallback">率</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">道</span><span class="mord cjk_fallback">利</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">率</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">发</span><span class="mord cjk_fallback">送</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">发</span><span class="mord cjk_fallback">送</span><span class="mord cjk_fallback">速</span><span class="mord cjk_fallback">率</span></span></span></span></span></p>
<h5 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h5>
<p>一个信道的数据传输了为4kb/s，单向传播时延为30ms，如果使停止-等待协议的信道最大利用率达到80%，要求数据帧的长度至少为多少字节？</p>
<p>我们设数据帧的长度为L，那么有以下公式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>80</mn><mi mathvariant="normal">%</mi><mo>=</mo><mo stretchy="false">(</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>4</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>4</mn><mo>+</mo><mn>2</mn><mo>×</mo><mn>30</mn><mi>m</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">80\%=(L/4)/(L/4+2×30ms)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">8</span><span class="mord">0</span><span class="mord">%</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord">4</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></span></p>
<p>可以解得L=960bit=120B,因此数据帧的长度至少为120字节。</p>
<h4 id="滑动窗口协议流量控制原理"><a class="markdownIt-Anchor" href="#滑动窗口协议流量控制原理"></a> 滑动窗口协议流量控制原理</h4>
<p>我们思考一下能否对停-等协议进行优化，上面的策略之所以传输效率低有两方面的原因：①一次性只传输一个帧导致效率低②错误全依赖于计时器超时重发机制，接收方不会主动报错造成长时间的等待。</p>
<p>我们前面讲过了接收方对于错误信息不能主动报错这是为了和<code>迟到ACK</code>加以区分，因此我们只能着眼于第一个缺陷加以优化，此时我们可以借鉴流水线的机制：</p>
<h5 id="流水线协议"><a class="markdownIt-Anchor" href="#流水线协议"></a> 流水线协议</h5>
<p>在停-等协议中并没有使用流水线机制，因此传输的过程图如下图，传输效率低：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210822145434.png" alt="" /></p>
<p>而我们可以引入流水线机制如下图，此时传输效率就大大提升了：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210822145516.png" alt="" /></p>
<p>可以看到效率提升了将近40倍，因此我们再引入了流水线机制后就提出了一个新的流量控制策略–<code>滑动窗口协议</code></p>
<h5 id="思考滑动窗口协议加入了流水线机制后和停-等协议有什么区别"><a class="markdownIt-Anchor" href="#思考滑动窗口协议加入了流水线机制后和停-等协议有什么区别"></a> 思考：滑动窗口协议加入了流水线机制后和停-等协议有什么区别？</h5>
<p>在介绍滑动窗口之前，首先我们从序列号和收发双方的缓冲区大小就可以比较出区别了。由于停-等协议一次只发送一个帧，因此只有当前发送的一个帧和下一个要发送的帧需要加以区分，因此只需要序列号0和1即可，但是很明显在滑动窗口中由于使用了流水线机制，一个RTT中会有许多个帧在同时传输，因此仅仅用0和1肯定是不够的了，我们需要扩充序列号范围，相应的收发双方的缓冲区大小也要从1扩大。</p>
<h5 id="滑动窗口协议"><a class="markdownIt-Anchor" href="#滑动窗口协议"></a> 滑动窗口协议</h5>
<p>在任意时刻，发送方都维持一组连续的允许发送的帧的序号，称为<code>发送窗口</code>，同时接收方也维持一组连续的允许接收帧的序号，称为<code>接收窗口</code>。发送窗口用来对发送方进行流量控制，而发送窗口的大小<code>Wt</code>代表在还未收到对方确认信息的情况下发送方最多还可以发送多少个数据帧。同理，在接收端设置接收窗口是为了控制可以接收那些数据帧和不可以接收那些数据帧。在接收方，只有收到的数据正确的帧的序号落入接收窗口内时，才允许将该数据帧收下。如果接收到的数据正确的帧在接收窗口之外或者接收到的帧数据发生了错误，则一律丢弃。如下图：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210822163120.png" alt="" /></p>
<p>对于接收方窗口，大小可以自定义，这里我们给出接收窗口大小<code>Wr</code>为1的图:</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210822163500.png" alt="" /></p>
<p>发送端每收到一个确认帧，发送窗口就向前滑动一个帧的位置，当发送窗口内没有可以发送的帧（即窗口内的帧全部都是已发送但未收到确认的帧）时，发送方就会停止发送，直到收到接收方发送的确认帧使窗口一移动，窗口内有可以发送的帧后，才开始继续发送。而接收端收到正确数据帧后，将窗口向后移动一个位置，并发回确认帧，若收到的正确数据帧落在接收窗口外，一律丢弃。</p>
<div class="tag-plugin note" color="yellow"><div class="body"><p>发送方的窗口不是在发送帧后滑动，而是在收到待确认的信息后滑动。接收方的窗口不是在接收到帧时滑动，而是在接收到正确数据的且序列号在接收窗口的帧时滑动并发送应答信息。</p></div></div>
<p>我们还可以总结出如下规律：</p>
<ul>
<li>只有接收窗口向前滑动（同时接收方发送了确认帧）时，发送窗口才有可能（只有发送方收到确认帧后才一定）向前滑动</li>
<li>从滑动窗口的概念看，停止-等待协议、后退N帧协议（GBN）和选择重传协议（SR）都是滑动窗口协议的一种形式，只是窗口大小和确认帧的形式上有所区别
<ol>
<li>停止-等待协议：发送窗口大小=1，接收窗口大小=1</li>
<li>后退N帧协议：发送窗口大小&gt;1，接收窗口大小=1</li>
<li>选择重传协议：发送窗口大小&gt;1，接收窗口大小&gt;1</li>
</ol>
</li>
<li>接收窗口大小为1时，可以保证帧的有序接收</li>
<li>数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的（一定要注意与传输层的滑动窗口区分开来，传输层的滑动窗口大小是动态变化的）</li>
</ul>
<h3 id="可靠传输机制"><a class="markdownIt-Anchor" href="#可靠传输机制"></a> 可靠传输机制</h3>
<p>数据链路层的可靠传输通常使用确认个超时重传两种机制来完成。确认是一种无数据的控制帧，这种控制帧使得接收方可以让发送方知道那些内容被正确接收。有些情况下为了提高传输效率，将确认捎带在一个回复帧中，称为稍待确认。超时重传是指发送方在发送某个数据帧后就开启一个计时器，在一定时间内如果没有得到发送的数据帧的确认帧，那么就重新发送该数据帧，知道发送成功为止。</p>
<p>自动重传请求（ARQ）通过接收方请求发送方重传出错的数据帧来恢复出错的帧，是通信中用于处理信道所带来差错的方法之一。传统的自动重传请求分为3种，即①停止-等待ARQ②后退N帧ARQ③选择重传ARQ。后两种协议是滑动窗口技术与请求重发技术的结合，由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称为<code>连续ARQ协议</code>。在数据链路层，流量控制和可靠传输是交织在一起的。</p>
<h4 id="单帧滑动窗口与停止-等待协议"><a class="markdownIt-Anchor" href="#单帧滑动窗口与停止-等待协议"></a> 单帧滑动窗口与停止-等待协议</h4>
<p>前面我们已经详细的介绍了停-等协议的运作原理了，实际上就是单帧滑动窗口的工作过程，他的发送窗口大小和接收窗口大小都为1。</p>
<p>对于帧的丢失和帧的数据错误的情况，停-等协议中接收方都是<code>保持沉默</code>不发送任何消息，待计时器超时后自动触发发送方重传帧。而对于已经成功接收的帧，窗口会向前滑动一个帧的位置，但是此时如果他有接收到正确的重复的该帧，那么由于此时这个帧的序列号已经不再接收窗口内部了，因此他会丢弃这个帧，但是同时这也意味着之前的确认帧并没有正确的被发送方接收，为了能够保证发送方的窗口能够正常滑动，接收方需要重发一下之前的确认帧：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210822155907.png" alt="" /></p>
<p>由于单帧滑动滑动窗口中每次只发送一个帧，因此序列号仅用0和1两个数即可，也就是序列号占用1bit二进制位即可，因此此时的帧的序列标志位长度为1bit。</p>
<p>在停止-等待协议中，如果连续出现相同发送序号的数据帧时，说明发送端进行了超时重传，意味着①数据帧在传输信道中丢失了或者②确认帧在传输信道中丢失了亦或者是③信道中干扰太大，很不幸发送的数据帧一直连续在传输信道中出现数据错误。</p>
<p>在停止-等待协议中，如果连续出现相同序号的确认帧时，表示接收端一直在收到重复的数据正确的帧，那么也就意味着确认帧一直没能正确的抵达发送方。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210822172518.png" alt="" /></p>
<p>由于此协议的信道利用率过低，因此为了克服这一个缺点，产生了另外两个更加高效的后退N帧协议和选择重传协议。</p>
<h4 id="多帧滑动窗口与后退n帧协议gbn"><a class="markdownIt-Anchor" href="#多帧滑动窗口与后退n帧协议gbn"></a> 多帧滑动窗口与后退N帧协议（GBN）</h4>
<p>在后退N帧式ARQ中，发送方无须在收到上一个帧的ACK后才能开始发送下一帧，而是可以连续发送帧。当接收方检测出失序的信息帧后，要求发送方重发最后一个正确接收的信息帧之后的所有未被确认的帧。或者当发送方发送了N个帧后，如果发现N个帧的前一个帧在计时器超时后仍未返回确认信息，则该帧被判定为出错或者丢失，此时发送方不得不重传该出错帧及随后的N个帧。也就是说，<strong>接收方只允许按顺序接收帧</strong>。</p>
<div class="tag-plugin note" color="yellow"><div class="body"><p>其实很好理解GBN为何是按顺序接收帧，毕竟他的接收窗口大小仅仅为1，必须接收到当前顺序抵达的帧才能下滑到下一个接收帧位置，因此GBN一定是顺序接收帧的。</p></div></div>
<h5 id="发送方窗口划分"><a class="markdownIt-Anchor" href="#发送方窗口划分"></a> 发送方窗口划分</h5>
<p>我们来规定一下后面讲解时GBN发送方窗口的定义：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210822192604.png" alt="" /></p>
<p>在GBN发送方窗口中我们将其分成四个区域，其中send_base指向的是窗口的最末端，nextseqnum指向的是窗口的最前端。两者之间（包括这两个边缘端存储的帧）时窗口的大小，内部的黄色部分是已经发送出去的帧但是还没有收到确认帧的部分，而蓝色部分是还可以发送帧的部分。send_base左端的绿色部分是已经成功发送并且收到确认消息的部分，而nextseqnum右侧的白色部分就是暂时存储到发送方缓存区等待发送的部分，只有当窗口滑动到这部分时，这部分白色区域会变成蓝色区域即有资格等待发送了。而黄色部分伴随着窗口滑动会变成绿色部分即收到确认帧后的部分。</p>
<h5 id="gbn发送方必须响应的三件事"><a class="markdownIt-Anchor" href="#gbn发送方必须响应的三件事"></a> GBN发送方必须响应的三件事</h5>
<p>在了解GBN协议实现的过程之前，我们先来说明GBN发送方必须响应的三件事：</p>
<ol>
<li>上层的调用：上层要发送数据时，发送方先检查发送窗口是否已满，如果未满，则产生一个帧并将其发送，如果窗口已满，那么发送方只需将数据返回给上层，暗示上层窗口已满，请上层等待一段时间后在发送。（但是在实际的实现中，发送方是可以缓存这些数据的即上面图示中的白色区域，窗口不满时在发送帧）</li>
<li>收到一个ACK(n)：在GBN协议中，对n号帧的确认采用<code>累积确认</code>的方式，即ACK(n)表示接收方已经顺序接收到n号帧及他以前的全部帧。</li>
<li>超时时间：协议的名字为后退N帧，来源于出现丢失和时延过长帧时发送方的行为，就像在停-等协议中一样，定时器会再次用于恢复数据帧或确认帧的丢失。如果确认出现超时，<strong>发送方会重传所有已发送但是还未被确认的帧</strong>。</li>
</ol>
<div class="tag-plugin note" color="yellow"><div class="body"><p>一定要注意超时后发送方并不是发送所有帧，而是所有已发送过一次但是未被确认的帧，即窗口滑动后新进入的帧此时仍然不能发送，只能等待下一波。</p></div></div>
<h5 id="gbn接收方要做的事"><a class="markdownIt-Anchor" href="#gbn接收方要做的事"></a> GBN接收方要做的事</h5>
<p>同样的GBN协议中接收方也有必须响应的事情：</p>
<ol>
<li>如果正确到n号帧，并且按序，那么接收方为n帧发送一个ACK(n)确认帧给发送方改制发送方前n号帧（包括第n号帧)都已经成功接收，并将该帧中的数据部分交付给上层。</li>
<li>其余情况下错误或者未按序抵达的帧一律丢弃，并为最近按序接收的帧重新发送ACK，接收方无需缓存任何失序帧（毕竟他的接收窗口仅为1），只需要维护一个信息：expectdseqnum(下一个按序接收的帧序号)</li>
</ol>
<div class="tag-plugin note" color="yellow"><div class="body"><p>我们要注意GBN协议规定接收方不一定每收到一个数据很就要发送一个ACK确认信息，而可以在连续收到好几个正确的数据帧后，才对最后一个数据帧发送确认消息。或者在自己有数据要发送时才将对以前正确收到的帧加以捎带确认发送给发送方。</p></div></div>
<h5 id="静态图讲解"><a class="markdownIt-Anchor" href="#静态图讲解"></a> 静态图讲解</h5>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210822194046.png" alt="" /></p>
<p>如上图是一个GBN协议的具体工作图，这里假设的发送窗口大小是9，那么上图所演示的工作步骤如下：</p>
<ol>
<li>首先发送方一次性发送窗口内所有未发送的帧即0-8号帧（上图从左往右看时间线，因此算一次性发送但是还是有顺序的，0-8号帧肯定是0号帧先出窗口，然后1,2…8）</li>
<li>然后接收方进行接收，他陆续的接收0,1，然后发现抵达的2号帧数据错误，因此会像停-等协议中的发送方一样丢弃错误的2号帧后<code>保持沉默</code>，但是一段时间接收方检查发现1号之前的帧都以按序成功接收，因此发送ACK(1)。(这里为了方便演示，每一次成功接收都发送ACK。)</li>
<li>紧接着3,4,5,6,7,8都陆续抵达，但是由于接收方为正确收到2号帧，因此接收方的窗口就停在了2号位置，又因为接收窗口大小仅为1，因此后面陆续抵达的帧都不能被缓存起来，只能全部被丢弃。</li>
<li>然后就陷入了<code>僵局</code>，双方都在等待对方的消息，接收方等待发送方的正确的2号帧，发送方收到了之前接收方发送的ACK(1)后知道0和1都已经成功被接收，因此窗口向前滑动2个帧，即此时send_base指向了2，nextseqnum指向了10，然后继续等待收到的ACK确认帧。</li>
<li>长时间没有ACK消息，用来记录第一组帧的发送计时器超时了此时发送方必须相应打破<code>僵局</code>，他发现此时send_base指向了2，因此他发送此时窗口内部所有已发送未被确认的帧即2-8号帧，<strong>一定要注意9和10号帧虽然此时也已经进入了发送端的滑动窗口内，但是仍然不能发送只能等待下一组发送</strong>。</li>
<li>接收方如愿以偿接收到了正确的2号帧，然后继续接收3-10号帧，在一段时间检查后发现前10个帧都已经顺序接收了因此又发送ACK(10)。</li>
<li>发送方收到ACK(10)，知道0-10都已经成功的发送，窗口继续滑动，send_base指向11，nextseqnum指向了19，然后发送方重置计时器发送11-19号帧</li>
</ol>
<h5 id="动态图讲解"><a class="markdownIt-Anchor" href="#动态图讲解"></a> 动态图讲解</h5>
<p>可能上面的不太好理解，这里我们再给出一种动图的讲解：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20191113192200848.gif" alt="" /></p>
<p>我们这里演示的时候假设发送方的发送窗口大小为4，我们可以看到起初发送0-4帧，而2号帧丢失了，那么此时接收方的接收窗口停在了2号帧的位置，即使收到了正确的3和4号帧也是直接抛弃的。然后发送了ACK(1)因此发送方窗口滑动，起始端移动到了2号帧，待计时器超时后发送方重新发送之前发送过但是未确认的2-4号帧**，一定要注意即使此时5,6号帧在发送方发送窗口内也是不能跟着这组发送的，必须等待下一组**。然后接收方正确接收了2-4号帧后发送了ACK(4)，发送方接收到ACK(4)以后发送窗口继续向前滑动，此时send_base指向了5，nextseqnum指向了8，然后发送方此时重置计时器后再次发送新的一组帧即5-8号。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20191113192200848888.gif" alt="" /></p>
<p>之前所讲解是发送方发送的2号帧丢失的情况，而现在上图所演示的在接收方全部正常接收0-4号帧以后，返还的ACK2丢失的情况，我们可以看到虽然ACK2丢失了，但是ACK3和ACK4都成功抵达了发送方，根据GBN协议对ACK是累计确认的机制，发送方可以判断出0-4号帧都已经被成功接收了，因此<code>sned_base</code>直接滑动到了5号。</p>
<h5 id="规律总结"><a class="markdownIt-Anchor" href="#规律总结"></a> 规律总结</h5>
<p>我们从上面的步骤中可以总结出一下几个特点：</p>
<ol>
<li>接收方仍然是在收到错误帧<code>保持沉默</code>，不会主动报告发送方错误帧序列号，而是选择使用超时机制解决这种情况，原因和之前讲解的停-等协议一样为了能够与<code>ACK迟到</code>情况区分</li>
<li>GBN协议一次性发送一组帧，但是实际上这组帧并不是同时抵达接收方，还是有一定的时间差，而接收方也刚好利用这段时间差为每一个抵达的帧进行接收前的差错检测和丢弃错误帧、发送ACK等操作。但是从宏观角度上来看好像发送方一次性&quot;同时&quot;发送了许多帧，而接收方一次性&quot;同时&quot;接收了许多帧，但是微观上实际接收窗口仅为1，只是在不断的滑动而已。</li>
<li>GBN协议中个发送方仅仅需要使用一个计时器为每一次一组的帧计时即可再ACK的帮助下和send_base指引下顺利找到下一次发送一组帧的起始序列号</li>
<li>接收方发送的确认消息携带的序列号是按序抵达的最大的帧的序列号</li>
</ol>
<h5 id="发送方状态转换图"><a class="markdownIt-Anchor" href="#发送方状态转换图"></a> 发送方状态转换图</h5>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210822202353.png" alt="" /></p>
<p>上图是发送方的一次传输的状态转换图，我们来再分析一下伪代码描述的过程：</p>
<ol>
<li>首先一开始send_base为1，nextseqnum也为1，即此时发送方还没有收到上层传递下来的数据，因此并不需要缓冲任何数据</li>
<li>然后顺时针看，<code>rdt_send(data)</code>表示上层向数据链路层的发送方传递了数据data,发送方进行判断发现窗口的<code>nextsqnum&lt;send_base+N</code>,则说明窗口还没有放足够的数据（这里的N是窗口大小）即还有蓝色区域可以盛放数据，因此发送方接收上层传递的数据并且存储到蓝色区域即等待发送的区域并对数据帧进行编号,然后发送这些数据，并且此时<code>send_base==nextseqnum==1</code>即发送方窗口还在起始状态，此时他发送了数据data因此需要启动计时器<code>start_timer</code>同时将<code>nextseqnum++</code>因为此时data占据了一个帧位，nextseqnum不再为1。否则说明窗口不够大或者已满，即蓝色区域不能盛放上层传递下来的数据，那么发送方暂时拒绝接收数据暗示上层窗口暂时已满无法承载了<code>refuse_data(data)</code>等待一段时间后再重复此步骤。</li>
<li>然后到达第三个状态，即不断的发送许多组数据帧，并且每次发送一组帧的时候都需要重启计时器<code>start_timer</code>，如果超时了那么就重复此步骤，由于nextseqnum再次状态过程中并未发生变化，因此这个状态表示的是发送方不断重传发送但是还未被确认的帧</li>
<li>当收到确认消息<code>rdt_rcv(rcvpkt)</code>并且确认消息正确无误<code>notcorrupt(rcvpkt)</code>，那么窗口就可以滑动了即<code>base=getacknum(rcvpkt)+1</code>。如果<code>base==nextseqnum</code>，那么说明所有已发送待确认的帧都已经成功接收，即又一波帧全部完成了传输，那么就可以停止计时器了<code>stop_timer</code>，否则还要继续重传那些发送带还没有被确认的分组并且重启计时器<code>start_timer</code></li>
<li>最终就是所有的帧都已经成功发送并被接收端接收</li>
</ol>
<div class="tag-plugin note" color="yellow"><div class="body"><p>GBN协议中发送方的窗口滑动只可能发生在接收到确认帧的时候即<code>send_base</code>起始端移动的时候，而<code>nextseqnum</code>增大时未必<code>send_base</code>发生变化即窗口可能不滑动仅仅是蓝色区域增多而已，但是无论多大都不可能超过<code>send_base+N</code></p></div></div>
<h5 id="接收方状态转换图"><a class="markdownIt-Anchor" href="#接收方状态转换图"></a> 接收方状态转换图</h5>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210822205608.png" alt="" /></p>
<p>上图是接收方的一次传输的状态转换图，我们来再分析一下伪代码描述的过程：</p>
<ol>
<li>起初期待的接收帧的序列号就是1即<code>expectedseqnum=1</code>同时制作ACK(1)的消息，由于ACK也可能发生位数反转等错误，因此在制作ACK的时候也需要加上校验和<code>sndpkt=make_pkt(expectedseqnum,ACK,chksum)</code></li>
<li>然后就是在一段时间后默认<code>default</code>自动发送ACK消息给发送方<code>udt_send(sndpkt)</code></li>
<li>当接收到帧<code>rdt_rcv(rcvpkt)</code>并且帧无损坏<code>notcurrupt(rcvpkt)</code>并且抵达的帧的序列号是期望的序列号即按该帧的序列号是按序抵达的在接收窗口内的<code>hasseqnum(rcvpkt,expectedseqnum)</code>那么接收方就整理最近接收到的顺序的帧数据并打包<code>extract(rcvpkt,data)</code>然后交付给上层<code>deliver_data(data)</code>同时继续制作ACK确认消息<code>sndpkt=make_pkt(expectedseqnum,ACK,chksum)</code>并发送给发送方<code>udt_send(sndpkt)</code>同时滑动接收窗口<code>expectedseqnum++</code></li>
</ol>
<h5 id="发送窗口大小限制"><a class="markdownIt-Anchor" href="#发送窗口大小限制"></a> 发送窗口大小限制</h5>
<p>我们知道在GBN协议中接收窗口就是1，那么发送窗口大小可以随便定义吗，实际上是不可以的。如果采用n比特二进制位对帧进行编号，那么发送窗口的大小应该始终小于等于编号标志位所能表示的最大值2^n-1，即有以下公式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>W</mi><mi>T</mi></msub><mo>+</mo><mn>1</mn><mo>≤</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">1≤W_T+1≤2^n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></p>
<div class="tag-plugin note" color="yellow"><div class="body"><p>我们可以用一句话概括即窗口内永远不能出现两个相同序号的帧或者<strong>发送窗口大小+接收窗口大小不得超过编号标志位所能表示的最大值</strong>，因此就有上图规律。</p></div></div>
<h6 id="思考为什么要满足上式规律"><a class="markdownIt-Anchor" href="#思考为什么要满足上式规律"></a> 思考：为什么要满足上式规律？</h6>
<p>如果不满足上面的公式，那么就会造成接收方无法分辨新帧和旧帧，比如假设用3位来对帧序号编码，那么最大值就是7，因此发送窗口的最大值为7，但是假设此时发送窗口大小为8。那么初始时发送方一次性发送0-7号八个数据帧，因为发送窗口已满，因此暂停发送。假设这8个数据帧都已经正确到达接收端，并且对每一个数据帧，接收端都能发送出确认帧，那么现在下面这两种情况将无法区分：</p>
<ul>
<li>第一种情况：所有确认帧都能够正确的到达发送端，那么此时发送端滑动窗口后将会发送新的8个数据，但是编号还是0-7。</li>
<li>第二种情况：所有确认帧都丢失了，那么经过一段时间后计时器超时，发送端重发之前发送的8个旧数据帧序号也是0-7。</li>
</ul>
<p>显然这两种情况的0-7编号的数据帧所包含的数据时不同的，但是接收方此时却不能区分，因此不满足上面的规律是不行的。假设此时满足规律将窗口大小设为了7，那么此时第一种情况新发送的数据帧编号将不再是0-7而是8,0,1,2,3,4,5,6显然就可以和第二种情况的0-7区分开来了。</p>
<h5 id="gbn性能分析"><a class="markdownIt-Anchor" href="#gbn性能分析"></a> GBN性能分析</h5>
<p>首先我们不难看出后退N帧协议通过连续发送数据帧肯定是提高了信道的利用率同时仅仅需要一个计时器实现起来比较简单，但是另一方面在重传时必须把原来已经传送正确的数据帧进行重传（仅仅因为这些数据帧的前面有一个数据帧出了错），这种做法既使传送效率降低了同时又造成了极大的资源郎芬。由此可见当信道的传输质量很差导致误码率较大时，GBN协议并不是最优策略，可能性能上还不如停止-等待协议。为了解决这一缺陷，又提出了选择重传机制。</p>
<h5 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h5>
<p>数据链路层采用了后退N帧（GBN）协议，发送方已经发送了编号为0-7的帧，如果发送方只收到了0,2,3号帧的确认，则发送方需要重放的帧数是？</p>
<p>重发帧数是4，即序号为4,5,6,7的帧。虽然此时窗口滑动后8,9,10,11已经在窗口内部的待发区域，但是超时造成的重传只会重传发送过但还未被确认的帧即4,5,6,7号帧。</p>
<h4 id="多帧滑动窗口与选择重传协议sr"><a class="markdownIt-Anchor" href="#多帧滑动窗口与选择重传协议sr"></a> 多帧滑动窗口与选择重传协议（SR）</h4>
<p>为了进一步提高信道的利用率，可以设法只重传出现错误的数据帧或者计时器超时的数据帧，但是此时我们就必须加大接受窗口大小，以便接收方可以暂时缓存收下那些序号不连续但是仍然处在接受窗口的数据帧（即错误帧后面的正确数据帧不会被丢弃了，而是可以被暂时存储在接受窗口内部）。当等待所缺的序号的数据帧收到后就可以和后面暂时存储的数据帧组成一组连续序号的帧组了，此时接收方再将其一并上交给上层，这就是选择重传ARQ协议。</p>
<p>很明显，此时再使用一个计时器肯定是不够的了，选择重传ARQ协议要对每一个数据帧单独计时，因此需要很多个计时器，一般计时器的数量与发送窗口大小相同。并且在选择重传协议中使用了一个更加有效的差错处理策略，即一旦接收方怀疑帧出错，就会发送一个NAK给发送方，要求发送方对NAK指定的数据帧进行重传（<strong>了解即可，一般讲解和做题时还是默认接收方对错误帧保持沉默</strong>）。</p>
<h5 id="发送方-接收方窗口划分"><a class="markdownIt-Anchor" href="#发送方-接收方窗口划分"></a> 发送方、接收方窗口划分</h5>
<p>在讲解GBN协议中我们只介绍了发送方窗口的划分，这是因为GBN协议中的接收方窗口大小仅仅为1，但是在SR协议中发送方和接收方窗口大小都不为1，并且通常情况下发送窗口和接收窗口大小相同，下面是SR协议对窗口的区域划分：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210823113218.png" alt="" /></p>
<p>在SR协议中发送窗口的划分和GBN的发送窗口划分规则相同，不再介绍。这里我们详细了解一下接受窗口的划分，同样的，接受窗口也划分为4部分，其中<code>rcv_base</code>指向的是缺少的希望获得的序号的数据帧。而离散形势的红色部分是乱序到达，即在错误帧或者丢失帧序号后面的正确帧存储。蓝色部分是还可以接收的乱序帧的区域。白色区域就是不能接收的区域。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210823113531.png" alt="" /></p>
<p>上图是另一种形式对窗口功能的介绍。</p>
<h5 id="sr发送方必须响应的三件事"><a class="markdownIt-Anchor" href="#sr发送方必须响应的三件事"></a> SR发送方必须响应的三件事</h5>
<p>在了解SR协议实现的过程之前，我们先来说明GBN发送方必须响应的三件事：</p>
<ol>
<li>
<p>上层的调用：从上层收到数据后，SR发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送该帧。否则就像GBN一样要么暂时缓存数据，要么返回给上层暗示上层窗口暂时已满。</p>
</li>
<li>
<p>收到一个ACK：在SR中对ACK采取<code>单一确认</code>机制，即ACKn只表示第n号帧被成功接收。如果发送方收到了ACKn，且该帧号n在窗口内，则SR发送方将那个被确认的帧标记为已接收然后丢弃这个帧的副本。如果这个帧序号是窗口的下界（最左边第一个窗口的序号），那么窗口向前滑动到具有最小序号未被确认的帧处。如果窗口移动了以后并且有序号在窗口内的等待发送的帧，那么就发送这些帧。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210823114203.png" alt="" /></p>
</li>
<li>
<p>超时事件：每一个帧都有自己的定时器，一个超时事件只会触发该超时帧的重传。</p>
</li>
</ol>
<h6 id="思考gbn和sr发送方触发重传的响应事件相同吗"><a class="markdownIt-Anchor" href="#思考gbn和sr发送方触发重传的响应事件相同吗"></a> 思考：GBN和SR发送方触发重传的响应事件相同吗？</h6>
<p>不相同，在GBN中窗口滑动后即使内部有可以发送的待发送帧，也不会发送，而是必须等待之前的那一组发送的帧全部被确认后才会再发送一组新的帧，当窗口滑动后还有之前发送后未被确认的帧，那么超时后就只重传之前未被确认的帧，新加入的帧必须等待下一波发送。而在SR协议中，只要窗口滑动后内部有新的待发送帧出现，就可以发送了，而当有某个帧超时时也只是重传超时帧而已。我们可以用下面的语句概括两者的特点：GBN<code>一组一组</code>发送，SR<code>一个一个</code>发送。</p>
<h5 id="sr接收方要做的事"><a class="markdownIt-Anchor" href="#sr接收方要做的事"></a> SR接收方要做的事</h5>
<p>同样的SR协议中接收方也有必须响应的事情，SR接收方将确认一个正确接受的帧而不管这个帧是否按序抵达。失序的帧将被缓存，并返回给发送方一个该帧的确认帧即<code>收谁确认谁</code>，知道所有帧（即序号最小的帧）皆被收到为止，这时才将一批帧按序交付给上层，然后向前滑动窗口。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210823115001.png" alt="" /></p>
<p>如果收到了窗口序号外（小于窗口下界的帧），那么就意味着出现了<code>确认帧ACK丢失</code>的情况，因此导致了发送方误以为接收方还没有成功接收该帧因此出现了这种情况，此时只需要返回一个该帧的ACK即可。</p>
<h6 id="思考为什么停-等协议和sr协议在ack丢失时要重传ack而gbn却不需要"><a class="markdownIt-Anchor" href="#思考为什么停-等协议和sr协议在ack丢失时要重传ack而gbn却不需要"></a> 思考：为什么停-等协议和SR协议在ACK丢失时要重传ACK而GBN却不需要？</h6>
<p>原因很简单，SR和停-等协议都是<code>单帧确认</code>机制，而GBN是<code>累计确认</code>机制，即GBN中接收方即使ACKn没有成功抵达发送方，但是ACK(n+1)抵达发送方时也可以向发送方传达n号帧被成功接收。但是在停-等协议和SR中只有ACKn抵达发送方才能想发送方传达n号帧被接收。</p>
<h5 id="静态图讲解-2"><a class="markdownIt-Anchor" href="#静态图讲解-2"></a> 静态图讲解</h5>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210823115847.png" alt="" /></p>
<p>上图是一个发送窗口和接受窗口都为4的SR工作流程，我们具体分析一下：</p>
<ol>
<li>首先发送方发送0-3号帧，但是2号帧在信道传输过程中丢失了，但是0,1,3号帧都成功抵达了，此时接受窗口接收0,1,3号帧并且发送ACK0,ACK1和ACK3同时窗口向前滑动但是只能滑动到<code>rcv_base</code>指向2号帧的位置，因此接收方还没有成功接收到2号帧</li>
<li>发送方收到3个确认帧以后同样进行窗口滑动滑动到<code>send_base</code>指向2的位置并且将1,3号帧的位置标记为已接收确认帧状态，因为2号帧的确认消息还没有接收到，但是此时窗口内又加入了新的等待发送的4号和5号帧，因此4和5号号帧可以发送了，发送方发送4号和5号帧</li>
<li>接收方还有位置可以接收4号和5号帧，因此接收4号和5号帧并返还ACK4和ACK5，但是由于期待的2号帧还是没有接收到，因此窗口仍然不会滑动并且此时窗口已经满了，此时即使抵达6,7…号帧，接收方也不会再接收了只能等待2号帧了</li>
<li>发送方收到了4号帧和5号帧的确认消息后发现窗口也已经满了并且由于2号帧的确认消息还是没有抵达因此<code>send_base</code>还是只能呆在2号帧位置，此时他的发送窗口也已经满了不能继续发送新的帧了，因此发送方只能等待2号帧的确认帧了</li>
<li>双方陷入<code>僵局</code>，都在等待对方的消息</li>
<li>一段时间后2号计时器超时，触发发送方重传2号帧，发送方重新发送2号帧打破<code>僵局</code></li>
<li>接收方收到2号帧，将2-5号帧一并上交给上层，同时滑动窗口，<code>rcv_base</code>移动到了6号帧的位置等待接收6,7,…号帧</li>
<li>发送方终于收到了2号帧的确认消息，滑动窗口向前滑动到<code>send_base</code>指向6号帧的位置同时发送6,7,8,9号帧</li>
<li>最终一直循环上面的过程完成所有数据帧的传输</li>
</ol>
<h5 id="动态图讲解-2"><a class="markdownIt-Anchor" href="#动态图讲解-2"></a> 动态图讲解</h5>
<p>我们同样给出SR的动态图演示：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20191113201934575.gif" alt="" /></p>
<p>上图演示的是在发送过程2号帧丢失的过程，我们可以看见接收方还是接收了丢失帧2号帧后面抵达的3号帧，而不是像GBN一样直接丢弃3号帧。发送方收到确认帧滑动窗口后有可以发送的新的帧就会立刻发送也不会像GBN那样必须等待所有之前发送的帧都被确认后才能发送新的待确认的帧。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20191113205433523.gif" alt="" /></p>
<p>上图演示的是SR中ACK2丢失的情况，此时发送方即使收到了ACK3和ACK4也不能确认2号帧被成功接收，因此窗口滑动只能移动到2号帧的位置，待超时后重传2号帧。</p>
<h5 id="规律总结-2"><a class="markdownIt-Anchor" href="#规律总结-2"></a> 规律总结</h5>
<p>我们从上面的步骤中可以总结出一下几个特点：</p>
<ol>
<li>接收方仍然是在收到错误帧<code>保持沉默</code>，不会主动报告发送方错误帧序列号，而是选择使用超时机制解决这种情况</li>
<li>SR协议一次性发送一组帧，但是实际上这组帧并不是同时抵达接收方，还是有一定的时间差，而接收方也刚好利用这段时间差为每一个抵达的帧进行接收前的差错检测和丢弃错误帧、发送ACK等操作。但是从宏观角度上来看好像发送方一次性&quot;同时&quot;发送了许多帧，而接收方一次性&quot;同时&quot;接收了许多帧。</li>
<li>SR协议中发送方需要为每一和帧都单独设置一个计时器，然后借助ACK消息判断未被确认的帧，并且在超时时只重传某个出错帧或者某个超时帧</li>
<li>接收方发送的确认消息携带的序列已接收的帧的序号，未必是按序抵达的</li>
</ol>
<h5 id="发送窗口与接收窗口大小限制"><a class="markdownIt-Anchor" href="#发送窗口与接收窗口大小限制"></a> 发送窗口与接收窗口大小限制</h5>
<p>同样的，在SR中发送窗口和接收窗口的大小也不能随便定义，需要满足一定的规律。他们需要满足的规律就是发送方和接收方的窗口内部都不能出现序列号相同而数据不同的帧，因此有以下规律：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>W</mi><mi>T</mi></msub><mo>+</mo><msub><mi>W</mi><mi>R</mi></msub><mo>≤</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">1≤W_T+W_R≤2^n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>如果Wt==Wr，那么我们可以进一步推得如下规律：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>W</mi><mrow><mi>T</mi><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><msub><mi>W</mi><mrow><mi>R</mi><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">W_{Tmax}=W_{Rmax}=2^{n-1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.864108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<div class="tag-plugin note" color="yellow"><div class="body"><p>我们可以用一句话概括即窗口内永远不能出现两个相同序号的帧或者<strong>发送窗口大小+接收窗口大小不得超过编号标志位所能表示的最大值</strong>，因此就有上图规律。</p></div></div>
<h6 id="思考为什么要满足上式规律-2"><a class="markdownIt-Anchor" href="#思考为什么要满足上式规律-2"></a> 思考：为什么要满足上式规律？</h6>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20210823122707.png" alt="" /></p>
<p>原理和GBN中介绍的一样。如果不满足上式，就会出现接收方无法区分旧帧和新帧，如上图编号最大值为4，但是收发窗口大小却设置为了3，那么此时</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>W</mi><mi>T</mi></msub><mo>+</mo><msub><mi>W</mi><mi>R</mi></msub><mo>=</mo><mn>6</mn><mo>&gt;</mo><mn>4</mn><mo>=</mo><mtext>窗口极限值</mtext></mrow><annotation encoding="application/x-tex">W_T+W_R=6&gt;4=窗口极限值
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">窗</span><span class="mord cjk_fallback">口</span><span class="mord cjk_fallback">极</span><span class="mord cjk_fallback">限</span><span class="mord cjk_fallback">值</span></span></span></span></span></p>
<p>很明显没有满足限制公式，因此此时上图的这两种情况第二个0号帧接收方将无法辨别是旧帧还是新帧。左图0号帧是重传的旧帧，而右图是新的数据不同的0号帧，但是在接收方视角接收方都将按照新帧来接收这明显会造成灾难性的结果。</p>
<h5 id="例题-3"><a class="markdownIt-Anchor" href="#例题-3"></a> 例题</h5>
<p>数据链路层采用了选择重传（SR）协议，发送方发送了0-3号帧，现在已经收到了1号帧的确认，而0,2号帧依次超时，则发送方需要重传的帧数是多少？</p>
<p>需要重传0号和2号两个帧。所以重传帧数是2。</p>
<h5 id="性能分析"><a class="markdownIt-Anchor" href="#性能分析"></a> 性能分析</h5>
<p>选择重传协议可以避免重复传送那些本可以正确到达接收端的数据帧，但是在接收端即需要设置具有相当容量的缓冲区来暂存那些未能按序正确收到的帧。虽然SR相对于GBN减少了帧的重传数量从而减少了资源的浪费，但是相应的他需要额外的接受窗口容量以及更多的单帧计时器。因此SR和GBN两者各有优劣点。</p>
<h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4>
<p>我们在学习完了三种可靠传输的机制后进行一个简单的对比总结。</p>
<table>
<thead>
<tr>
<th style="text-align:center">协议</th>
<th style="text-align:center">窗口大小</th>
<th style="text-align:center">效率</th>
<th style="text-align:center">显著特点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">停止-等待协议</td>
<td style="text-align:center">单帧窗口</td>
<td style="text-align:center">低</td>
<td style="text-align:center">原理简单，只需要一位的序列号</td>
</tr>
<tr>
<td style="text-align:center">回退N帧协议</td>
<td style="text-align:center">多帧窗口但是接受窗口大小为1</td>
<td style="text-align:center">较高</td>
<td style="text-align:center">流水线机制，累计确认</td>
</tr>
<tr>
<td style="text-align:center">选择重传协议</td>
<td style="text-align:center">多帧窗口</td>
<td style="text-align:center">高</td>
<td style="text-align:center">流水线机制，单帧确认</td>
</tr>
</tbody>
</table>
<p>我们发现实际上SR本质上相当于许多个并行执行的停止-等待协议，从单个帧的角度上来看实际上SR和停止-等待协议很相似。而GBN的重传机制很特别，<strong>一定要特别注意GBN重传时只重传那些已经发送过但是还未被确认的帧</strong>。</p>

  


  </article>
  
<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">回顾上一篇</div><a href="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/DL%E5%B1%82%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BB%84%E5%B8%A7/index.html">DL层功能与组帧</a></div><div class="item" id="next"></div></section></div>

  

  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      快来参与讨论吧
    </section>
    <section class='body cmt-body waline'>
      

<div id="waline_container" class="waline_thread" comment_id="ComputerNetwork"><svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg></div>

    </section>
  </div>




      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客</span><a href="/">随想录</a><a href="/intro">言堂序</a><a href="/archives">归档册</a></div><div class="sitemap-group"><span class="fs14">笔记</span><a href="/wiki/tags/%E7%AC%AC%E4%B9%9D%E8%89%BA%E6%9C%AF">第九艺术</a><a href="/wiki/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80">计算基础</a><a href="/wiki/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80">语言基础</a><a href="/wiki/tags/%E8%BF%9B%E9%98%B6%E6%8A%80%E8%83%BD">进阶技能</a></div><div class="sitemap-group"><span class="fs14">便笺</span><a href="/notes/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0">科研学习</a><a href="/notes/%E5%BB%BA%E7%AB%99%E5%BF%85%E5%A4%87">建站必备</a><a href="/notes/%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7">建站必备</a></div><div class="sitemap-group"><span class="fs14">更多</span><a target="_blank" rel="noopener" href="https://coolchong.cn">个人主页</a><a target="_blank" rel="noopener" href="https://blog.coolchong.cn/friends.html">友情链接</a></div></div><div class="text"><div class="github-badge">
  <a style="color: #fff"  href="https://coolchong.cn/" target="_blank" title="由 Langwenchong 搭建运营">
    <span class="badge-subject">Built</span><span class="badge-value bg-blue">雨中 @2022-2023</span>
  </a>
  <a style="color: #fff" href="https://www.qiniu.com//" target="_blank" title="静态资源托管于 七牛云" >
    <span class="badge-subject">Powered</span><span class="badge-value bg-orange">七牛云</span>
  </a>
  <a style="color: #fff" href="https://xaoxuu.com/wiki/stellar/" target="_blank" title="站点使用 Stellar 主题" >
    <span class="badge-subject">Theme</span><span class="badge-value bg-brightgreen">Stellar</span>
  </a>
  <a style="color: #fff" href="https://beian.miit.gov.cn/)" target="_blank" title="网站已备案授权开放">
    <span class="badge-subject">Record</span><span class="badge-value bg-red">津ICP备2021009044</span>
  </a>
</div>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.18.5';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://fastly.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://fastly.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://fastly.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function load_comment(){
    if(!document.getElementById("waline_container"))return;
    stellar.loadCSS('https://unpkg.com/@waline/client@2.14.1/dist/waline.css');
    stellar.loadScript('https://unpkg.com/@waline/client@2.14.1/dist/waline.js', {defer:true}).then(function () {
      const el = document.getElementById("waline_container");
      var path = el.getAttribute('comment_id');
      if (!path) {
        path = decodeURI(window.location.pathname);
      }
      Waline.init(Object.assign({"js":"https://unpkg.com/@waline/client@2.14.1/dist/waline.js","css":"https://unpkg.com/@waline/client@2.14.1/dist/waline.css","serverURL":"https://waline.coolchong.cn","commentCount":true,"pageview":false,"emoji":["https://fastly.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/","https://unpkg.com/@waline/emojis@1.1.0/tw-emoji","https://unpkg.com/@waline/emojis@1.1.0/bilibili","https://unpkg.com/@waline/emojis@1.1.0/alus","https://unpkg.com/@waline/emojis@1.1.0/bmoji"],"locale":{"reactionTitle":null,"placeholder":"任何想法畅所欲言，记得填写邮箱方便及时收到回复哦~"},"reaction":["https://fastly.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatheart.png","https://fastly.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatattentionreverse.png","https://fastly.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatrainbow.png","https://fastly.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatwave.png","https://fastly.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/blobcatalt.png","https://fastly.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/blobcatscared.png"]}, {
        el: '#waline_container',
        path: path,
      }));
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
    console.log('DOM fully loaded and parsed');
    load_comment();
  });

</script>




<!-- inject -->


  </div>
</body>
</html>
