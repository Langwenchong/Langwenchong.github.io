<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>OS：虚拟内存管理 - 雨中•学圃堂</title>

  
    <meta name="description" content="请求式分页管理方式前面我们介绍了虚拟内存，并且介绍了请求式管理的由来，那么接下来就详细介绍一下请求式分页管理方式。请求分页存储管理与基本分页存储管理的主要区别是在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息调入内存（这里操作系统要提供请求调页功能把缺失页面从外存调入内存）后继续执行程序。如果内存空间不足，由操作系统负责将内存中暂时用不到的信息换出到外存。（操作系统要提供页面置">
<meta property="og:type" content="website">
<meta property="og:title" content="虚拟内存管理">
<meta property="og:url" content="https://scholar.coolchong.cn/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="雨中•学圃堂">
<meta property="og:description" content="请求式分页管理方式前面我们介绍了虚拟内存，并且介绍了请求式管理的由来，那么接下来就详细介绍一下请求式分页管理方式。请求分页存储管理与基本分页存储管理的主要区别是在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息调入内存（这里操作系统要提供请求调页功能把缺失页面从外存调入内存）后继续执行程序。如果内存空间不足，由操作系统负责将内存中暂时用不到的信息换出到外存。（操作系统要提供页面置">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20201229150245.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20201229151202.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20201229151246.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20201229152210.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20201229152741.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20201229152825.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20201229153116.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20201229153849.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20201229155134.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20201229162345.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20201229162636.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20201229164503.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20201229164520.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20201229171411.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20201229171545.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20201229195451.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20201229201151.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20201229201444.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20201229201606.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20201229201926.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20201229202213.png">
<meta property="article:published_time" content="2023-01-27T07:32:57.600Z">
<meta property="article:modified_time" content="2023-01-27T07:32:57.600Z">
<meta property="article:author" content="Wenchong Lang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://langwenchong.gitee.io/figure-bed/20201229150245.png">
  
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="雨中•学圃堂" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="https://cdn.coolchong.cn/%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/langwenchong.png">
  

  

  
    <link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
    <script defer src="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js" ></script>
    <script defer src="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
  


  
    
      <link href="https://fonts.font.im/css?family=Dancing+Script" rel="stylesheet">
    
      <link href="https://fastly.jsdelivr.net/gh/volantis-x/cdn-fontawesome-pro@master/css/all.min.css" rel="stylesheet">
    
  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='wiki'>
    

  




<div class="widgets"><widget class="widget-wrapper logo-wrap wiki"><div class="widget-body"><a style="filter: grayscale(100%)" class="wiki-home cap" href="/wiki"><svg aria-hidden="true" viewBox="0 0 16 16" width="1rem" height="1rem" fill="currentColor"><path fill-rule="evenodd" d="M7.78 12.53a.75.75 0 01-1.06 0L2.47 8.28a.75.75 0 010-1.06l4.25-4.25a.75.75 0 011.06 1.06L4.81 7h7.44a.75.75 0 010 1.5H4.81l2.97 2.97a.75.75 0 010 1.06z"></path></svg>所有笔记</a><a class="title" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html"><div class="main" ff="title">OS</div><div class="sub cap">不会操作系统的工程师不是优秀的工程师</div></a></div></widget>
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/wiki/操作系统笔记/" placeholder="想找点什么？"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">好像并未找到什么！</div></div></div></widget>




<widget class="widget-wrapper toc multi" id="data-toc"><div class="widget-header cap dis-select"><span class="name">操作系统简介</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html#start"><span class="toc-text">什么是操作系统</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/index.html"><span class="toc-text">操作系统的运行环境</span></a></div></div><div class="widget-header cap dis-select"><span class="name">进程管理</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B/index.html"><span class="toc-text">什么是进程</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B/index.html"><span class="toc-text">什么是线程</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/index.html"><span class="toc-text">处理机调度</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/index.html"><span class="toc-text">进程调度算法</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/index.html"><span class="toc-text">同步与互斥</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98(1)/index.html"><span class="toc-text">信号量与经典同步问题(1)</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98(2)/index.html"><span class="toc-text">经典同步问题(2)</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E7%AE%A1%E7%A8%8B%E4%B8%8E%E6%AD%BB%E9%94%81/index.html"><span class="toc-text">管程与死锁</span></a></div></div><div class="widget-header cap dis-select"><span class="name">内存管理</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/index.html"><span class="toc-text">内存管理概念</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E6%97%A9%E6%9C%9F%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/index.html"><span class="toc-text">早期分配管理方式</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/index.html"><span class="toc-text">基本页式存储管理</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%A6%82%E5%BF%B5/index.html"><span class="toc-text">段页式管理与虚拟内存概念</span></a></div><div class="doc-tree active"><a class="doc-tree-link active" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html"><span class="toc-text">虚拟内存管理</span></a><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%BC%8F%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">请求式分页管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E6%9C%BA%E6%9E%84"><span class="toc-text">页表机构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%9C%BA%E6%9E%84"><span class="toc-text">缺页中断机构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%86%85%E5%AD%98%E5%9D%97%E6%AD%A4%E6%97%B6%E6%98%AF%E6%BB%A1%E7%9A%84%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">思考：如果内存块此时是满的怎么办？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9A%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E5%B1%9E%E4%BA%8E%E5%86%85%E4%B8%AD%E6%96%AD%E7%9A%84%E5%93%AA%E4%B8%80%E7%B1%BB%EF%BC%9F"><span class="toc-text">思考：缺页中断属于内中断的哪一类？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-text">地址变换机构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E6%9F%A5%E6%85%A2%E8%A1%A8%E5%92%8C%E6%9F%A5%E5%BF%AB%E8%A1%A8%E4%B8%80%E8%B5%B7%E8%BF%9B%E8%A1%8C%EF%BC%9F"><span class="toc-text">思考：为什么没有查慢表和查快表一起进行？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BD%93%E6%9C%89%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%97%B6%E4%BC%9A%E9%80%9A%E8%BF%87%E5%BF%AB%E8%A1%A8%E5%91%BD%E4%B8%AD%EF%BC%9F"><span class="toc-text">思考：为什么当有缺页中断时会通过快表命中？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88OPT%EF%BC%89"><span class="toc-text">最佳置换算法（OPT）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%AA%E4%BD%BF%E7%94%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88NRU%EF%BC%89"><span class="toc-text">最近未使用页面置换算法（NRU）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9A%E9%97%AE%E4%BB%80%E4%B9%88%E7%AC%AC2%E7%B1%BB%E6%AF%94%E7%AC%AC3%E7%B1%BB%E4%BC%98%E5%85%88%E8%A2%AB%E6%B7%98%E6%B1%B0%EF%BC%9F"><span class="toc-text">思考：问什么第2类比第3类优先被淘汰？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88FIFO%EF%BC%89"><span class="toc-text">先进先出页面置换算法（FIFO）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88SC%EF%BC%89"><span class="toc-text">第二次机会页面置换算法（SC）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9ANRU%E5%92%8CSC%E9%83%BD%E6%9C%89R%E4%BD%8D%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">思考：NRU和SC都有R位有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88CLOCK%EF%BC%89"><span class="toc-text">时钟页面置换算法（CLOCK）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9A%E8%83%BD%E5%90%A6%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96CLOCK%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">思考：能否进一步优化CLOCK算法？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E5%9E%8B%E7%9A%84%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88CLOCK-v2-0"><span class="toc-text">改进型的时钟置换算法（CLOCK v2.0)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9A%E6%94%B9%E8%BF%9B%E5%9E%8BCLOCK%E5%92%8CCLOCK%E6%9C%80%E5%A4%A7%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">思考：改进型CLOCK和CLOCK最大的区别是什么？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88LRU%EF%BC%89"><span class="toc-text">最近最少使用页面置换算法（LRU）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%B8%8D%E5%B8%B8%E7%94%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88NFU%EF%BC%89"><span class="toc-text">最不常用页面置换算法（NFU）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%81%E5%8C%96%E7%AE%97%E6%B3%95"><span class="toc-text">老化算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-WS"><span class="toc-text">工作集页面置换算法(WS)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A5%E4%BD%9C%E9%9B%86%EF%BC%9F"><span class="toc-text">思考：什么是工作集？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%A0%E7%B0%B8%E7%8E%B0%E8%B1%A1%EF%BC%9F"><span class="toc-text">思考：什么是颠簸现象？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5%EF%BC%9F%E9%A2%A0%E7%B0%B8%E7%8E%B0%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%A2%91%E7%B9%81%E5%87%BA%E7%8E%B0%EF%BC%9F"><span class="toc-text">思考：什么是请求调页？颠簸现象什么时候频繁出现？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9A%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%A8%8B%E5%BA%8F%E5%88%9D%E6%9C%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E9%A2%A0%E7%B0%B8%E7%8E%B0%E8%B1%A1%EF%BC%9F"><span class="toc-text">思考：怎么解决程序初期运行的颠簸现象？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9A%E7%BA%AF%E5%88%86%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%9B%86%E5%92%8C%E8%AF%B7%E6%B1%82%E5%BC%8F%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%9B%86%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">思考：纯分页式管理的工作集和请求式分页管理的工作集的区别？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-text">页面分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E3%80%81%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-text">页面分配、置换策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A9%BB%E7%95%99%E9%9B%86"><span class="toc-text">驻留集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-1"><span class="toc-text">页面分配策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-text">页面置换策略</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-text">调入页面的时机</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E8%B0%83%E9%A1%B5%E7%AD%96%E7%95%A5"><span class="toc-text">预调页策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5%E7%AD%96%E7%95%A5"><span class="toc-text">请求调页策略</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-text">调入页面的区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%A0%E7%B0%B8-%E6%8A%96%E5%8A%A8-%E7%8E%B0%E8%B1%A1"><span class="toc-text">颠簸(抖动)现象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="toc-text">工作集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="widget-header cap dis-select"><span class="name">文件管理</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%9B%AE%E5%BD%95/index.html"><span class="toc-text">文件系统基础与目录</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/index.html"><span class="toc-text">文件存储与基本操作</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4/index.html"><span class="toc-text">文件共享与保护</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E7%A3%81%E7%9B%98/index.html"><span class="toc-text">磁盘</span></a></div></div><div class="widget-header cap dis-select"><span class="name">I/O管理</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/I/O%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/index.html"><span class="toc-text">I/O管理概述</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6/index.html"><span class="toc-text">设备独立性软件</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E7%BC%93%E5%86%B2%E5%8C%BA&%E7%BB%93%E6%9D%9F%E8%AF%AD/index.html"><span class="toc-text">缓冲区&结束语</span></a></div></div></widget>



<widget class="widget-wrapper related"><div class="widget-header cap theme dis-select"><span class="name">更多计算机基础</span></div><div class="widget-body related-posts"><a class="item wiki" href="/wiki/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E6%9C%AC%E5%85%83%E4%BB%B6/index.html"><span class="title">数字逻辑与数字系统笔记</span><span class="excerpt">本门课程是由我最喜欢的王立老师精编的原创课程，深入浅出的讲解带领我们从零开始自己尝试设计一个指令集架构，还不进来看一看？</span></a><a class="item wiki" href="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/index.html"><span class="title">计算机组成原理笔记</span><span class="excerpt">计算机组成原理是每一名计算机科班生都必会的基础内容之一，借着考研的机会我参考王道图书重新学习了操作系统并记录下了我的一些浅显理解。</span></a><a class="item wiki" href="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html"><span class="title">计算机网络笔记</span><span class="excerpt">计算机网络是每一名计算机科班生都必会的基础内容之一，借着考研的机会我参考王道图书重新学习了操作系统并记录下了我的一些浅显理解。</span></a><a class="item wiki" href="/wiki/%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/index.html"><span class="title">手撕算法笔记</span><span class="excerpt">程序=数据结构+算法,世界上最优秀的程序一定使用了最先进优雅的算法，让我们一同进入算法的世界中学习，感受编程的魅力吧！</span></a></div></widget>
</div>


    </aside>
    <div class='l_main'>
      

      

  
  
<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" id="home" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" id="menu" href="/wiki/">笔记</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">OS</a></div><div id="post-meta">更新于&nbsp;<time datetime="2023-01-27T07:32:57.600Z">2023-01-27</time></div></div>

  <article class='md-text content wiki reveal'>
  <h1 class="article-title"><span>虚拟内存管理</span></h1>
  <h3 id="请求式分页管理方式"><a href="#请求式分页管理方式" class="headerlink" title="请求式分页管理方式"></a>请求式分页管理方式</h3><p>前面我们介绍了虚拟内存，并且介绍了请求式管理的由来，那么接下来就详细介绍一下请求式分页管理方式。请求分页存储管理与基本分页存储管理的主要区别是在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息调入内存（这里操作系统要提供请求调页功能把缺失页面从外存调入内存）后继续执行程序。如果内存空间不足，由操作系统负责将内存中暂时用不到的信息换出到外存。（操作系统要提供页面置换的功能，将暂时用不到的页面换出外存).这里会涉及到页面机制，缺页中断机构和地址变换机构，我们在下面一一进行介绍。</p>
<h4 id="页表机构"><a href="#页表机构" class="headerlink" title="页表机构"></a>页表机构</h4><p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是够已经掉入内存，如果还没有调入内存，那么也需要知道该页面在外存中存放的位置。并且当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面（页面置换算法），有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，需要将外存中的旧数据覆盖，因此操作系统需要记录各个页面是否被修改的信息。如下：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20201229150245.png" alt=""></p>
<p>从上图我们可以看出请求分页存储管理的页表中存储了所有的页表，即使没有放入到内存中页记录在一个页表项。例如x现在就没有在内存中。</p>
<h4 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h4><p>假设现在某进程要使访问的逻辑地址为（页号，页内偏移量）=（0，1024），那么经过查表发现此时0号页不在页表中，所以产生一个缺页中断，然后然后由操作系统对缺页中断进行处理。首先是将缺页的进程阻塞，然后放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。如果内存中还有空闲块，那么就为进程分配一个空闲块，将所缺页面装入该快，并修改页表中相应的页表项。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20201229151202.png" alt=""></p>
<p>如上图就是将0号页表项内存块号修改为a并且状态为1，并且还要将x号块内的页面装入内存中去：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20201229151246.png" alt=""></p>
<h5 id="思考：如果内存块此时是满的怎么办？"><a href="#思考：如果内存块此时是满的怎么办？" class="headerlink" title="思考：如果内存块此时是满的怎么办？"></a>思考：如果内存块此时是满的怎么办？</h5><p>那么就会调用页面置换算法将一些符合调出条件的页面写回外存，所以只有内存满的时候才会触发调换算法（其实很容易理解，写回外存肯定是有时间开销的，所以只有满的时候迫不得已了才会增加时间开销为新来的页腾地儿），类似的实际上TLB等快表也有这个调出暂时长时间不命中的页表项的算法。并且如果内存满了，调出某个页面时，如果这个页面在内存期间被修改过，那么需要将其写回外存覆盖旧数据，否则未修改过的页面就不用了写回外存了，直接淘汰掉就好。毕竟外存块x处还存有旧数据的页，所以我们也可以看出调入是从外存快复制一份页面进入内存块，调出的意思是从内存淘汰的意思，当修改过的时候，这个被淘汰的页面还肩负着通知外存块更新数据的使命所以还需要写回外存（当然肯定是有额外的时间开销的），当没有被修改过（不意味着没被使用，可能在内存期间一直在在被读也发挥作用了）那么就直接扔出内存即可。</p>
<h5 id="思考：缺页中断属于内中断的哪一类？"><a href="#思考：缺页中断属于内中断的哪一类？" class="headerlink" title="思考：缺页中断属于内中断的哪一类？"></a>思考：缺页中断属于内中断的哪一类？</h5><p>我们知道缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断。一条指令在执行期间，可能会产生多次缺页中断（如copy A to B,即将逻辑地址A的数据复制到逻辑地址B，而A,B属于不同的页面，就可能产生两次中断，即A的页不在内存中，B的页也不再内存中，可能会产生两次中断）。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20201229152210.png" alt=""></p>
<p>我们可以看出缺页中断属于内中断中的故障，但是是可以被程序处理恢复的。</p>
<h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p>因为不能保证逻辑地址访问的页在内存中，所以我们首先是需要确定页是否在页表中，如果不在还需要调入页面并修改表项，当然如果内存满了，那么还需要页面置换。所以新增的步骤有：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20201229152741.png" alt=""></p>
<p>当然后面的步骤就是根据页号找到内存块号了，然后拼接物理地址最后再访问目标内存单元。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20201229152825.png" alt=""></p>
<p>这里我们尤其要注意TLB的机制，他只存放现在在内存中的刚刚被访问过得页表项，所以TLB里的页一定是存在的。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20201229153116.png" alt=""></p>
<p>这里面的一些小细节直接用图片给出，这里我们一定要注意绿框中的提示要点。我们可以看出当产生缺页中断时换出旧页面并调入新的页面到内存块后发生了几个重要的事件：</p>
<ol>
<li>快表直接加上新的表项</li>
<li>不是直接通过慢表拼接出了物理地址然后访存，而是又重新来了一遍这次快表命中了，然后通过快表拼接出了物理地址进行访存。</li>
</ol>
<h5 id="思考：为什么没有查慢表和查快表一起进行？"><a href="#思考：为什么没有查慢表和查快表一起进行？" class="headerlink" title="思考：为什么没有查慢表和查快表一起进行？"></a>思考：为什么没有查慢表和查快表一起进行？</h5><p>可以，但是没必要，因为此时慢表大概率会慢于快表（如果不是还要TLB作甚）并且查慢表还会出现缺页中断，并行查询也快不了多少。</p>
<h5 id="思考：为什么当有缺页中断时会通过快表命中？"><a href="#思考：为什么当有缺页中断时会通过快表命中？" class="headerlink" title="思考：为什么当有缺页中断时会通过快表命中？"></a>思考：为什么当有缺页中断时会通过快表命中？</h5><p>这就是进程中断的原理了，当在某一个指令处中断时如果进程阻塞了PCB会记录上次停止的位置，然后当进程再次执行时PCB会恢复到上一次停止的指令处然后重新执行中断的指令（大部分情况下），所以此时还会再执行一遍这个指令的逻辑地址但是此时就会通过快表命中了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20201229153849.png" alt=""></p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>这部分超级重要，我会做适当的扩充，毕竟王道讲的实在是太少了。一定要透彻了解并且会计算。首先我们明确一个目的，由于页面的换入换出需要磁盘I/O，会有较大的开销，因此优秀的页面置换算法应该追求更少的缺页率。</p>
<h4 id="最佳置换算法（OPT）"><a href="#最佳置换算法（OPT）" class="headerlink" title="最佳置换算法（OPT）"></a>最佳置换算法（OPT）</h4><p>也叫作最优置换算法（OPT,Optimal):每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样就可以保证最低的缺页率。这里我们知道肯定是最理想的情况，因为这个算法要求我们需要提前知道未来这个所要被调出的页面就是最长时间或者永久不可能再被使用的页面，但是未来不可预测，所以这个算法实际中不可能实现，但是我们需要学习算法思想（毕竟万一未来我们量子预测到未来这个算法那不就可以实现了吗😝）</p>
<p>例题：假设系统为某进程分配了三个内存块，并考虑有以下页面号引用串（会依次访问这些页面）：7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0,1</p>
<p>那么最终的过程如下：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20201229155134.png" alt=""></p>
<p>首先不用想，第一次填入时肯定都是缺页的（这个很重要容易被忽视）所以内存块填入7,0,1就先缺页3次，然后接下来到2，我们需要调出一个页面，此时我们看一下未来的访页顺序发现7最长时间不会被访问了，所以调出7接入2又缺页1次，继续执行到3发现又该调出了，还是看未来的顺序，调出1,….一直这样看未来顺序调出页面最终缺页率还是可观的才45%。这里我们可以看出缺页率的计算公式：</p>
<script type="math/tex; mode=display">
缺页率=缺页中断次数/页面引用次数</script><h4 id="最近未使用页面置换算法（NRU）"><a href="#最近未使用页面置换算法（NRU）" class="headerlink" title="最近未使用页面置换算法（NRU）"></a>最近未使用页面置换算法（NRU）</h4><p>最近未使用页面置换算法（Not Recently Used)和OPT很相似，既然我不能知道未来的顺序，那么我就往回看，根据经验分析和局部性原理我们知道如果一个页面很久没有被是用来，那么大概率他就会很长时间或者不会再被使用了（根据历史经验推测未来），所以我们每次都选择调出最近未使用的页面。这里我们的做法如下：</p>
<p>当一个页面被访问(读)时设置R(read)位，页面被写入(修改)时设置M(modificate)位。</p>
<p>当启动一个进程时，它的所有页面的两个位都由操作系统初始化为0，R会被定期地（比如在每次时钟中断时）清零以区别最近没有被访问和被访问的页面。</p>
<p>那么当发生缺页中段时就会检查页面，其中页面可以分为4类：</p>
<ul>
<li>第0类：没有被访问也没有被修改过的页面（R=M=0)</li>
<li>第1类：没有被访问但是已被修改过的页面（R=0,M=1）</li>
<li>第2类：已被访问过但是没有被修改过的页面（R=1,M=0）</li>
<li>第3类：已经被访问过并且也被修改过的页面（R=M=1）</li>
</ul>
<p>每次都是从类编号小的非空类中随机挑选一个页面淘汰。</p>
<h5 id="思考：问什么第2类比第3类优先被淘汰？"><a href="#思考：问什么第2类比第3类优先被淘汰？" class="headerlink" title="思考：问什么第2类比第3类优先被淘汰？"></a>思考：问什么第2类比第3类优先被淘汰？</h5><p>首先请读一下算法名字，他强调的就是最近未使用，所以重在根据是否最近被访问过来决定页面的重要性，所以2类先被淘汰，毕竟在一个时间嘀嗒中（大约20ms）淘汰一个没有被访问过的已被修改过的页面比淘汰一个被频繁使用的“干净”（没被修改过）的页面好，所以是否“干净”（即是够被修改过）只是一个次级判断条件。其实NRU这种算法优点就是易于理解和有效实现并且虽然性能不是最好的但是已经够用了。</p>
<h4 id="先进先出页面置换算法（FIFO）"><a href="#先进先出页面置换算法（FIFO）" class="headerlink" title="先进先出页面置换算法（FIFO）"></a>先进先出页面置换算法（FIFO）</h4><p>同样借鉴了NRU的思路，既然每次都淘汰最近未被使用的页面，那么大多数情况先来的一般会在内存中待较长的时间，根据时间局部性原理，一般他就是那个最近未被使用的页面。所以FIFO算法就是每次选择淘汰的页面是最早进入内存的页面。</p>
<p>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列（FIFO队列），需要换出页面时就选择队头页面即可。所以队列的最大长度取决于操作系统为进程分配了多少个内存块。</p>
<p>例题：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20201229162345.png" alt=""></p>
<p>缺页率=9/12=75%,说实话优点小高。那么你一定想到了如果多分几个内存块是不是缺页次数会变得更少，答案是未必，如下：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20201229162636.png" alt=""></p>
<p>缺页率=10/12=83%缺页率反而更大了。只有FIFO会产生这种Belady异常现象，所以FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律是不适应的，因为先进入的页面也有可能经常被访问，所以算法性能差，不推荐使用。</p>
<h4 id="第二次机会页面置换算法（SC）"><a href="#第二次机会页面置换算法（SC）" class="headerlink" title="第二次机会页面置换算法（SC）"></a>第二次机会页面置换算法（SC）</h4><p>第二次机会页面置换算法（Second Chance)是对FIFO算法进行的一种优化改进。修改的思路其实很简单，就是避免将最先进来的页面却被访问的页面优先调出，所以只需要设置一位R位，如果是0那么这个页面就是既老还没有被使用，可以直接置换掉。如果是1那么就说明这个页面虽然老但是被访问过，所以将R为置为0然后把这个页面放到队尾修改装入的时间就好像它刚被装入一样（即拥有了第二次机会），然后继续搜索队头直至R=0的页面换出。</p>
<p>第二次机会算法就是在寻找一个最近的时钟间隔内没有被访问过的页面。如果所有的页面都被访问过了，即队列中所有的页面R都是1了，那么这个算法就是纯FIFO算法了，所以为了避免这种情况此时操作系统会一个接一个地将每一个页面都移动到队尾并将R设置为0。最后又回到原来的表头页面并且此时R位都是0，因此这个页面会被淘汰，所以这个算法总是可以结束不会出现死循环的。</p>
<h5 id="思考：NRU和SC都有R位有什么区别？"><a href="#思考：NRU和SC都有R位有什么区别？" class="headerlink" title="思考：NRU和SC都有R位有什么区别？"></a>思考：NRU和SC都有R位有什么区别？</h5><p>NRU和SC的R位都是被访问的意思，但是NRU的R位是最近被访问的概念，而SC的R为只是表示被访问过的意思，所以NRU需要一个时间嘀嗒来设置R在一个时间段后清零，而SC就不需要只是当队列全是1时所有页面都在绕一圈然后R都变为0。</p>
<h4 id="时钟页面置换算法（CLOCK）"><a href="#时钟页面置换算法（CLOCK）" class="headerlink" title="时钟页面置换算法（CLOCK）"></a>时钟页面置换算法（CLOCK）</h4><p>对第二次机会算法的改进，我们发现第二次机会算法总是需要在链表中移动页面，这很低效没必要。所以更好的做法是把所有的页面都保存在一个类似钟面的环形链表中，一个表指针指向最老的页面（即最先进入内存的页面）。当发生缺页中断时，首先检查指针指向的页面，如果R位是0，那么就淘汰该页面，并把新的页面插入到这个位置，然后把表指针移到下一个页面，如果R位是1就将R位置为0然后检验下一个位置，重复这个过程一直到找到一个R位为0的页面为止。当所有的R位都是1时，则指针转一圈将所有的页面的R位都清为0。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20201229164503.png" alt=""></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20201229164520.png" alt=""></p>
<p>我们发现实际上CLOCK算法和SC算法思想一模一样，只不过是换了一个数据结构来减少操作的开销。并且我们发现简单的CLOCK算法选择淘汰一个页面最多经过两轮扫描。</p>
<h5 id="思考：能否进一步优化CLOCK算法？"><a href="#思考：能否进一步优化CLOCK算法？" class="headerlink" title="思考：能否进一步优化CLOCK算法？"></a>思考：能否进一步优化CLOCK算法？</h5><p>我们发现NRU不止讨论了是否最近被访问过的问题，还加了一个是否被修改过的判断指标，当都没有被访问时优先会淘汰没有被修改过的页面，这是因为毕竟修改过的页面被淘汰时还需要写回外存有更大的开销不如再等一等万一他一会被访问了不就不用写回外存了嘛。所以优先淘汰的是R=M=0的，那么CLOCK算法也可以借鉴这种思想。</p>
<h4 id="改进型的时钟置换算法（CLOCK-v2-0"><a href="#改进型的时钟置换算法（CLOCK-v2-0" class="headerlink" title="改进型的时钟置换算法（CLOCK v2.0)"></a>改进型的时钟置换算法（CLOCK v2.0)</h4><p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件均相同时，应该优先淘汰没有被修改过得页面，避免I/O操作。这就是改进型的时钟置换算法的思想。所以也是有下面这四类：</p>
<ul>
<li>第0类：没有被访问也没有被修改过的页面（R=M=0)</li>
<li>第1类：没有被访问但是已被修改过的页面（R=0,M=1）</li>
<li>第2类：已被访问过但是没有被修改过的页面（R=1,M=0）</li>
<li>第3类：已经被访问过并且也被修改过的页面（R=M=1）</li>
</ul>
<p>页面的状态用（R,M）表示，所以（1,1）表示最近被访问过且被修改过。</p>
<p>算法规则：将所有可能被置换的页面排成一个钟面型的循环队列。</p>
<p>第一轮：从当前位置开始扫描到第一个（0,0)的帧用于替换，本轮扫描结束。</p>
<p>第二轮：前提是第一轮扫描失败（即没有(0,0)），那么重新扫描，查找第一个（0,1)的帧用于替换。本轮会将所有扫描过得帧访问位设置为0（即第二轮扫描后（1,0)-&gt;(0,0),(1,1)-&gt;(0,1)。</p>
<p>第三轮：前提是第二轮扫描失败（即没有(0,0)和（0,1)），那么重新扫描，查找第一个（0,0）（此时的(0,0)是原先的(1,0)）的帧用于替换。本轮不修改任何标志位。</p>
<p>第四轮：前提是第三轮扫描失败（即没有(0,0),(0,1)和(1,0)），那么重新扫描，查找第一个（0,1)（此时的(0,1)是原先的(1,1)）的帧用于替换。并且此轮一定会扫描成功。</p>
<p>由于第二轮已经将所有的访问位设置为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK算法选择一个淘汰页面最多会进行四轮扫描。</p>
<h5 id="思考：改进型CLOCK和CLOCK最大的区别是什么？"><a href="#思考：改进型CLOCK和CLOCK最大的区别是什么？" class="headerlink" title="思考：改进型CLOCK和CLOCK最大的区别是什么？"></a>思考：改进型CLOCK和CLOCK最大的区别是什么？</h5><p>我们仔细对比一下两者的算法思想，我们发现虽然都是使用类似钟的循环队列数据结构，但是算法思想却截然不同，对于简单的CLOCK使用的是SC的思想，而改进型的时钟页面置换算法使用的是NRU+CS的算法思想但是更贴向NRU。</p>
<h4 id="最近最少使用页面置换算法（LRU）"><a href="#最近最少使用页面置换算法（LRU）" class="headerlink" title="最近最少使用页面置换算法（LRU）"></a>最近最少使用页面置换算法（LRU）</h4><p>最近最少使用页面置换算法（LRU，Least Recently Used）：每次淘汰的页面是最近最久未使用的页面。</p>
<p>实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t，当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。很明显这个非常的科学。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20201229171411.png" alt=""></p>
<p>我们以一道例题讲解，假设某系统为某进程分配了4个内存块，并考虑到有以下页面号引用串：1,8,1,7,8,2,7,1,8,3,8,2,1,3,1,7,1,3,7</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20201229171545.png" alt=""></p>
<p>缺页率=6/20=33%很小。在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在逆向扫描过程中最后一个出现的页号就是要淘汰的页面。我们发现这个方法太好啦，就用这个吧，但是实际上这个算法不常见，因为需要专门的硬件支持且实现困难，开销极大。</p>
<h4 id="最不常用页面置换算法（NFU）"><a href="#最不常用页面置换算法（NFU）" class="headerlink" title="最不常用页面置换算法（NFU）"></a>最不常用页面置换算法（NFU）</h4><p>最不常用页面置换算法（NFU,Not Frequently Used）:用一个软件模拟LRU，该算法将每个页面与一个软件计数器相关联，计数器的初始值为0，每次时钟中断时，由操作系统扫描内存中的所有页面，将每个页面的R位（他是0或1）加到计数器上。这个计数器大体上跟踪了各个页面被访问的频繁程度。当发生缺页中断时，则置换计数器上数值最小的页面。</p>
<p>我们发现NFU不忘记任何事情，比如一个页面之前被频繁访问，导致这个计数器很大，但是后来不访问他了，但是由于计数器的值太大，他也一直不会被置换出去，这个缺点太严重，所以也不推荐。</p>
<h4 id="老化算法"><a href="#老化算法" class="headerlink" title="老化算法"></a>老化算法</h4><p>老化算法是对NFU算法的修改，其修改包括两个部分，首先，在R位被加进之前将计数器（二进制数）右移一位（相当于除以2）然后将新来的R位的数加在计数器的最左端的位（即次数最大最优决定权）。这样老化算法的计数器中只有有限位数，如果时钟滴答是20ms,8位一般足够了，加入一个页面160ms都没有被访问过，那么他很有可能就不重要了。</p>
<h4 id="工作集页面置换算法-WS"><a href="#工作集页面置换算法-WS" class="headerlink" title="工作集页面置换算法(WS)"></a>工作集页面置换算法(WS)</h4><p>在讲解算法的实现之前，我们先了解一下几个概念：</p>
<h5 id="思考：什么是工作集？"><a href="#思考：什么是工作集？" class="headerlink" title="思考：什么是工作集？"></a>思考：什么是工作集？</h5><p>工作集：一个进程当前正在使用的页面的集合称为工作集</p>
<h5 id="思考：什么是颠簸现象？"><a href="#思考：什么是颠簸现象？" class="headerlink" title="思考：什么是颠簸现象？"></a>思考：什么是颠簸现象？</h5><p>颠簸现象：程序每执行几条指令就产生一次缺页中断</p>
<h5 id="思考：什么是请求调页？颠簸现象什么时候频繁出现？"><a href="#思考：什么是请求调页？颠簸现象什么时候频繁出现？" class="headerlink" title="思考：什么是请求调页？颠簸现象什么时候频繁出现？"></a>思考：什么是请求调页？颠簸现象什么时候频繁出现？</h5><p>请求调页：在单纯的分页系统中，刚启动进程时，在内存中是没有页面的，所以当cpu尝试读取第一条指令时就会产生一次缺页中断，使操作系统装入含有第一条指令的页面，其他由访问全局数据和堆栈引起的缺页中断通常会紧接着发生。一段时间后，该进程需要的大部分页面都已经在内存中了，进程开始在较少缺页中断的情况下运行</p>
<h5 id="思考：怎么解决程序初期运行的颠簸现象？"><a href="#思考：怎么解决程序初期运行的颠簸现象？" class="headerlink" title="思考：怎么解决程序初期运行的颠簸现象？"></a>思考：怎么解决程序初期运行的颠簸现象？</h5><p>有不少分页系统会设法跟踪进程的工作集，以确保进程运行以前，他的工作集就已经在内存中了，这样运行初期就不会频繁发生颠簸了。这种方法就叫做工作集模型，大大减少了缺页中断率。在进程前装入其工作集页面也称为预先调页。所以工作集随着时间变化的。</p>
<p>实际上大多数的程序会任意访问一小部分页面，工作集缓慢变化。当程序重新开始时，就有可能根据它上次结束时的工作集对要用到的页面作一个合理的推测，预先调页就是在程序IXUS运行之前预先装入推测的工作集的页面。</p>
<h5 id="思考：纯分页式管理的工作集和请求式分页管理的工作集的区别？"><a href="#思考：纯分页式管理的工作集和请求式分页管理的工作集的区别？" class="headerlink" title="思考：纯分页式管理的工作集和请求式分页管理的工作集的区别？"></a>思考：纯分页式管理的工作集和请求式分页管理的工作集的区别？</h5><p>那么按照以前的方法定义工作集为前1000万次内存访问所使用过的页面的集合，那么现在在请求式分页管理中就应该定义为过去10ms中的内存访问所用到的页面的集合。这样的模型更合适和容易实现。并且要注意每个进程都只会计算自己执行的时间，所以当一个进程在T时刻开始然后在T+100ms的时间段内使用了40ms的CPU，那么对于工作集来说就是40ms。一个程序从他开始执行到当前所实际使用处理机的时间总数就是当前实际运行时间。我们通过这个近似的方法定义进程的工作集就是在过去的t秒实际运行时间中他所访问过的页面的集合。</p>
<p>那么现在我们再来探讨下基于工作集的页面置换算法：就是找出一个不在进程工作集中的页面淘汰他。</p>
<p>每个表项至少要包含两条信息：</p>
<ol>
<li>上次使用该页面的近似时间</li>
<li>最近是否访问过的R位</li>
</ol>
<p>过程如下：</p>
<p>扫描所有的页面检查R位。</p>
<ul>
<li>如果R==1：那么设置上次使用时间为当前实际时间，以表示缺页中断时该页面正在被使用</li>
<li>如果R==0&amp;&amp;生存时间&gt;t:那么表示最近没有被访问过且已经不再工作集了，那么就移除这个页面，用新的页面置换它。扫描会继续进行以更新剩余的表项。所以这次扫描后所有不在工作集的页面都会被淘汰掉。</li>
<li>如果R==0&amp;&amp;生存时间\&lt;=t:那么表示这个页面没有被访问过但是却还在工作集中，那么就记录下最长生存时间（就是当前时间-最早被使用时间即已经在呆工作集中的时间）。如果最后没有找到任何一个可以淘汰的即所有页面都是1情况除了现在被扫描的这个页面那么就淘汰这个页面，如果有多个3这种情况的即（1,3都有的情况）那么就淘汰生存时间最长的。如果最终所有页面都是1的情况（包括现在被扫描的这个也是1的情况）那么虽然都满足无需淘汰的条件，但是总是得出去一个，那么就尽可能随机淘汰一个“干净”（没有被修改过的）页面这样就无需进行I/O操作了节省开销。</li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>以上涵盖了大部分置换算法，这里列表总结</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">页面置换算法</th>
<th style="text-align:center">算法规则</th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">最佳置换算法（OPT）</td>
<td style="text-align:center">优先淘汰最长时间内不会被访问到的页面</td>
<td style="text-align:center">缺页率小，性能最好</td>
<td style="text-align:center">预测未来，无法实现</td>
</tr>
<tr>
<td style="text-align:center">最近未使用置换算法（NRU）</td>
<td style="text-align:center">优先淘汰最近未被访问且干净的页面（需要R,M）</td>
<td style="text-align:center">性能优秀，实现简便</td>
<td style="text-align:center">————</td>
</tr>
<tr>
<td style="text-align:center">先进先出置换算法（FIFO）</td>
<td style="text-align:center">优先淘汰最先进入内存的页面</td>
<td style="text-align:center">实现简单</td>
<td style="text-align:center">性能差，与规律相悖，可能出现Belady异常</td>
</tr>
<tr>
<td style="text-align:center">第二次机会置换算法（SC)</td>
<td style="text-align:center">FIFO改良版，对于最近被访问过得放到队尾获得第二次机会</td>
<td style="text-align:center">合理，性能适中</td>
<td style="text-align:center">链表操作复杂</td>
</tr>
<tr>
<td style="text-align:center">时钟置换算法（CLOCK）</td>
<td style="text-align:center">SC的时钟循环链表形式，规则同上</td>
<td style="text-align:center">合理，性能适中</td>
<td style="text-align:center">未考虑干净页面的I/O开销</td>
</tr>
<tr>
<td style="text-align:center">改进型的时钟置换算法（CLOCK v2.0)</td>
<td style="text-align:center">和NRU思路规则相似使用的是时钟循环链表形式</td>
<td style="text-align:center">合理，性能适中，考虑了I/O开销</td>
<td style="text-align:center">有时候扫描次数有点多</td>
</tr>
<tr>
<td style="text-align:center">最近最少使用页面置换算法（LRU）</td>
<td style="text-align:center">每次都淘汰上一次被访问时间最早的页</td>
<td style="text-align:center">性能好，科学合理</td>
<td style="text-align:center">实现复杂，需要特殊地硬件支持，开销大</td>
</tr>
<tr>
<td style="text-align:center">最不常用页面置换算法（NFU）</td>
<td style="text-align:center">计数器记录R的和来表示被访问频率，每次淘汰访问频率小的页面</td>
<td style="text-align:center">实现简单</td>
<td style="text-align:center">之前访问频率大但是最近不怎么访问的页面迟迟不能被置换</td>
</tr>
<tr>
<td style="text-align:center">老化算法</td>
<td style="text-align:center">NFU改良版</td>
<td style="text-align:center">实现适中，性能适中</td>
<td style="text-align:center">————</td>
</tr>
<tr>
<td style="text-align:center">工作集算法（WS）</td>
<td style="text-align:center">每次都淘汰不在工作集的或者在工作集时间最长的干净的页面</td>
<td style="text-align:center">实现适中，性能适中</td>
<td style="text-align:center">————</td>
</tr>
</tbody>
</table>
</div>
<h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><h4 id="页面分配、置换策略"><a href="#页面分配、置换策略" class="headerlink" title="页面分配、置换策略"></a>页面分配、置换策略</h4><h5 id="驻留集"><a href="#驻留集" class="headerlink" title="驻留集"></a>驻留集</h5><p>指请求分页存储管理中给进程分配的物理块的集合。在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。如果驻留集太大，就失去了虚拟存储技术的应用意义，导致多道程序并发度下降，资源利用率降低。如果驻留集太小，会导致缺页颠簸，系统需要花费大量时间处理缺页。所以驻留集的大小要合适。</p>
<p>我们考虑一个极端的情况，如果一个进程共有100个页，那么如果驻留集大小为100，那么进程可以全部放入内存运行期间也就不会再发生缺页了，如果驻留集为1，则进程运行期间必定会频繁的缺页。</p>
<h5 id="页面分配策略-1"><a href="#页面分配策略-1" class="headerlink" title="页面分配策略"></a>页面分配策略</h5><p>固定分配：操作系统为每个进程分配一组固定数目的物理块，在运行期间各个进程的驻留集大小不变。</p>
<p>可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即驻留集大小动态变化。</p>
<h5 id="页面置换策略"><a href="#页面置换策略" class="headerlink" title="页面置换策略"></a>页面置换策略</h5><p>局部置换：发生缺页时只能选进程自己的物理块进行置换。</p>
<p>全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。</p>
<h6 id="思考：分配策略和置换策略的关系？"><a href="#思考：分配策略和置换策略的关系？" class="headerlink" title="思考：分配策略和置换策略的关系？"></a>思考：分配策略和置换策略的关系？</h6><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20201229195451.png" alt=""></p>
<p>固定分配局部置换：系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略缺点是很难在刚开始就确定应该为每个进程分配多少个物理块才算合理。（采用这种策略的系统可以根据进程大小，优先级，或是根据程序猿给出的参数来确定为一个进程分配的内存块数）</p>
<p>可变分配全局置换：刚开始为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某个进程发生缺页时，从空闲物理块中取出一块分配给该进程，如果已经没有空闲物理块了，则可以选择一个未锁定的页面换出外存（注意，并不是所有的页面都可以换出外存，比如系统会锁定一些页面，这些页面中的内容不能置出外存比如重要的内核数据等），再将物理块分配给缺页的进程。如果采取这种策略，那么只要进程发生缺页，都将先获得空闲的物理块，只有空闲物理块也没有的时候系统会调出一些其他进程未锁定的页面（这个页可能是任何一个进程的页），然后将腾出的物理块分配给这个缺页的进程。因此这个被选中的进程拥有的物理块会减少，缺页率会增加。</p>
<p>可变分配局部置换：刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</p>
<h6 id="思考：可变分配全局置换和可变分配局部置换的区别？"><a href="#思考：可变分配全局置换和可变分配局部置换的区别？" class="headerlink" title="思考：可变分配全局置换和可变分配局部置换的区别？"></a>思考：可变分配全局置换和可变分配局部置换的区别？</h6><p>可变分配全局置换是只要缺页系统就会给他分配新的物理块。</p>
<p>可变分配局部置换是根据发生缺页的频率动态增加或减少进程的物理块直至频率趋于稳定。</p>
<h4 id="调入页面的时机"><a href="#调入页面的时机" class="headerlink" title="调入页面的时机"></a>调入页面的时机</h4><h5 id="预调页策略"><a href="#预调页策略" class="headerlink" title="预调页策略"></a>预调页策略</h5><p>根据局部性原理（主要是空间局部性原理），一次调入若干个相邻的页面可能比一次调入一个页面更加高效。但是如果预先调入的页面大多数没有被访问，那么就会低效。因此可以预测不久之后可能访问到的页面，将他们预先调入内存，但是目前预测成功概率为50%。所以这种策略主要用于进程的首次调入，由程序猿指出应该调入那些部分。</p>
<h5 id="请求调页策略"><a href="#请求调页策略" class="headerlink" title="请求调页策略"></a>请求调页策略</h5><p>进程在运行期间发现缺页时才将页面调入内存。这种策略调入的页面一定会被访问，但是每次只能调入一页，而且每次调入都要磁盘I/O操作，所以开销大。</p>
<h4 id="调入页面的区域"><a href="#调入页面的区域" class="headerlink" title="调入页面的区域"></a>调入页面的区域</h4><p>当系统拥有足够的对换区空间：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20201229201151.png" alt=""></p>
<p>那么页面的调入和调出都是内存和对换区之间进行，这样可以保证页面的调入和调出速度很快，在进程运行前，需要将进程相关的数据从文件区复制到对换区。</p>
<p>当系统缺少足够的对换区空间：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20201229201444.png" alt=""></p>
<p>凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的 部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。</p>
<p>独特的UNIX方式：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20201229201606.png" alt=""></p>
<p>运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。</p>
<h4 id="颠簸-抖动-现象"><a href="#颠簸-抖动-现象" class="headerlink" title="颠簸(抖动)现象"></a>颠簸(抖动)现象</h4><p>刚刚换出的页面马上又换入内存，刚刚换入的内存又要换出内存，这种频繁的页面调度行为就是颠簸或抖动。产生的原因是划分给进程的驻留集太小。</p>
<h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h4><p>驻留集：在请求分页存储管理中给进程分配的物理块的集合。</p>
<p>工作集：在某段时间内，进程实际访问页面的集合。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20201229201926.png" alt=""></p>
<p>所以工作集大小可能会小于窗口尺寸，系统会根据工作集大小和窗口尺寸的关系动态更改驻留集。比如某个进程的窗口尺寸为5，但是一段时间的检测发现进程的工作集一般最大就是3，那么物理块大小更改为3即可满足需要。所以一般驻留集的大小不能小于工作集的大小，否则就会导致进程运行过程中频繁缺页。</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20201229202213.png"  /></p>

  


  </article>
  
<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">回顾上一篇</div><a href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%A6%82%E5%BF%B5/index.html">段页式管理与虚拟内存概念</a></div><div class="item" id="next"><div class="note">接下来阅读</div><a href="/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%9B%AE%E5%BD%95/index.html">文件系统基础与目录</a></div></section></div>

  

  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      快来参与讨论吧
    </section>
    <section class='body cmt-body waline'>
      

<div id="waline_container" class="waline_thread" comment_id="OS"><svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg></div>

    </section>
  </div>




      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客</span><a href="/">随想录</a><a href="/intro">言堂序</a><a href="/archives">归档册</a></div><div class="sitemap-group"><span class="fs14">笔记</span><a href="/wiki/tags/%E7%AC%AC%E4%B9%9D%E8%89%BA%E6%9C%AF">第九艺术</a><a href="/wiki/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80">计算基础</a><a href="/wiki/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80">语言基础</a><a href="/wiki/tags/%E8%BF%9B%E9%98%B6%E6%8A%80%E8%83%BD">进阶技能</a></div><div class="sitemap-group"><span class="fs14">便笺</span><a href="/notes/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0">科研学习</a><a href="/notes/%E5%BB%BA%E7%AB%99%E5%BF%85%E5%A4%87">建站必备</a><a href="/notes/%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7">建站必备</a></div><div class="sitemap-group"><span class="fs14">更多</span><a target="_blank" rel="noopener" href="https://coolchong.cn">个人主页</a><a target="_blank" rel="noopener" href="https://blog.coolchong.cn/friends.html">友情链接</a></div></div><div class="text"><div class="github-badge">
  <a style="color: #fff"  href="https://coolchong.cn/" target="_blank" title="由 Langwenchong 搭建运营">
    <span class="badge-subject">Built</span><span class="badge-value bg-blue">雨中 @2022-2023</span>
  </a>
  <a style="color: #fff" href="https://https://www.qiniu.com//" target="_blank" title="静态资源托管于 七牛云" >
    <span class="badge-subject">Powered</span><span class="badge-value bg-orange">七牛云</span>
  </a>
  <a style="color: #fff" href="https://xaoxuu.com/wiki/stellar/" target="_blank" title="站点使用 Stellar 主题" >
    <span class="badge-subject">Theme</span><span class="badge-value bg-brightgreen">Stellar</span>
  </a>
  <a style="color: #fff" href="https://beian.miit.gov.cn/)" target="_blank" title="网站已备案授权开放">
    <span class="badge-subject">Record</span><span class="badge-value bg-red">津ICP备2021009044</span>
  </a>
</div>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.18.5';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function load_comment(){
    if(!document.getElementById("waline_container"))return;
    stellar.loadCSS('https://unpkg.com/@waline/client@2.14.1/dist/waline.css');
    stellar.loadScript('https://unpkg.com/@waline/client@2.14.1/dist/waline.js', {defer:true}).then(function () {
      const el = document.getElementById("waline_container");
      var path = el.getAttribute('comment_id');
      if (!path) {
        path = decodeURI(window.location.pathname);
      }
      Waline.init(Object.assign({"js":"https://unpkg.com/@waline/client@2.14.1/dist/waline.js","css":"https://unpkg.com/@waline/client@2.14.1/dist/waline.css","serverURL":"https://waline.coolchong.cn","commentCount":true,"pageview":false,"emoji":["https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/","https://unpkg.com/@waline/emojis@1.1.0/tw-emoji","https://unpkg.com/@waline/emojis@1.1.0/bilibili","https://unpkg.com/@waline/emojis@1.1.0/alus","https://unpkg.com/@waline/emojis@1.1.0/bmoji"],"locale":{"reactionTitle":null,"placeholder":"任何想法畅所欲言，记得填写邮箱方便及时收到回复哦~"},"reaction":["https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatheart.png","https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatattentionreverse.png","https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatrainbow.png","https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatwave.png","https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/blobcatalt.png","https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/blobcatscared.png"]}, {
        el: '#waline_container',
        path: path,
      }));
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
    console.log('DOM fully loaded and parsed');
    load_comment();
  });

</script>




<!-- inject -->


  </div>
</body>
</html>
