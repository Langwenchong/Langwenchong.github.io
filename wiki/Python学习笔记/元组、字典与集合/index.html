<!DOCTYPE html>
<html lang='zh-CN'>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?fc63ac4843a697431e3d43c4d48b99de";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://fastly.jsdelivr.net'>
  <link rel="preconnect" href="https://fastly.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>Python：元组、字典与集合 - 雨中•学圃堂</title>

  
    <meta name="description" content="Python tuple元组详解 元组（tuple)是Python中另一个重要的序列结构，和列表类似，元组也是由一系列按特定顺序排列的元组组成。但是他和list列表又有所区别如下：  列表的元素是可以更改的，包括修改元素值，删除和插入元素，所以列表是可变序列； 而元组一旦被创建，它的元素就不可更改了，所以元组是不可变序列。  元组可以看成是不可变的列表，因此他不提供append()，remove">
<meta property="og:type" content="website">
<meta property="og:title" content="元组、字典与集合">
<meta property="og:url" content="https://scholar.coolchong.cn/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%83%E7%BB%84%E3%80%81%E5%AD%97%E5%85%B8%E4%B8%8E%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="雨中•学圃堂">
<meta property="og:description" content="Python tuple元组详解 元组（tuple)是Python中另一个重要的序列结构，和列表类似，元组也是由一系列按特定顺序排列的元组组成。但是他和list列表又有所区别如下：  列表的元素是可以更改的，包括修改元素值，删除和插入元素，所以列表是可变序列； 而元组一旦被创建，它的元素就不可更改了，所以元组是不可变序列。  元组可以看成是不可变的列表，因此他不提供append()，remove">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20220117152326.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20220117203958.png">
<meta property="article:published_time" content="2023-01-28T07:49:20.231Z">
<meta property="article:modified_time" content="2023-01-28T07:49:20.231Z">
<meta property="article:author" content="Wenchong Lang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://langwenchong.gitee.io/figure-bed/20220117152326.png">
  
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="雨中•学圃堂" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="https://cdn.coolchong.cn/%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/langwenchong.png">
  

  
    
<link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/github.min.css">

  

  
    <link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
    <script defer src="https://fastly.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js" ></script>
    <script defer src="https://fastly.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
  


  
    
      <link href="https://fonts.font.im/css?family=Dancing+Script" rel="stylesheet">
    
      <link href="https://fastly.jsdelivr.net/gh/volantis-x/cdn-fontawesome-pro@master/css/all.min.css" rel="stylesheet">
    
      <link href="https://gcore.jsdelivr.net/gh/highlightjs/cdn-release@11.5.0/build/styles/github-dark.min.css">
    
  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='wiki'>
    

  




<div class="widgets"><widget class="widget-wrapper logo-wrap wiki"><div class="widget-body"><a style="filter: grayscale(100%)" class="wiki-home cap" href="/wiki"><svg aria-hidden="true" viewBox="0 0 16 16" width="1rem" height="1rem" fill="currentColor"><path fill-rule="evenodd" d="M7.78 12.53a.75.75 0 01-1.06 0L2.47 8.28a.75.75 0 010-1.06l4.25-4.25a.75.75 0 011.06 1.06L4.81 7h7.44a.75.75 0 010 1.5H4.81l2.97 2.97a.75.75 0 010 1.06z"></path></svg>所有笔记</a><a class="title" href="/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/index.html"><div class="main" ff="title">Python</div><div class="sub cap">python是世界上最好的语言</div></a></div></widget>
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/wiki/Python学习笔记/" placeholder="想找点什么？"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">好像并未找到什么！</div></div></div></widget>




<widget class="widget-wrapper toc multi" id="data-toc"><div class="widget-header cap dis-select"><span class="name">语法基础</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/index.html#start"><span class="toc-text">变量类型和运算符</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%97%E8%A1%A8/index.html"><span class="toc-text">列表</span></a></div><div class="doc-tree active"><a class="doc-tree-link active" href="/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%83%E7%BB%84%E3%80%81%E5%AD%97%E5%85%B8%E4%B8%8E%E9%9B%86%E5%90%88/index.html"><span class="toc-text">元组、字典与集合</span></a><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#python-tuple%E5%85%83%E7%BB%84%E8%AF%A6%E8%A7%A3"><span class="toc-text"> Python tuple元组详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E5%88%9B%E5%BB%BA%E5%85%83%E7%BB%84"><span class="toc-text"> Python创建元组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E4%BD%BF%E7%94%A8%E5%88%9B%E5%BB%BA"><span class="toc-text"> 1）使用()创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E4%BD%BF%E7%94%A8tuple%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%85%83%E7%BB%84"><span class="toc-text"> 2)使用tuple()函数创建元组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E8%AE%BF%E9%97%AE%E5%85%83%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-text"> Python访问元组元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E4%BF%AE%E6%94%B9%E5%85%83%E7%BB%84"><span class="toc-text"> Python修改元组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E5%88%A0%E9%99%A4%E5%85%83%E7%BB%84"><span class="toc-text"> Python删除元组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E4%B8%AD%E5%85%83%E7%B4%A0%E5%92%8C%E5%88%97%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text"> Python中元素和列表的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python-dict%E5%AD%97%E5%85%B8"><span class="toc-text"> Python dict字典</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E5%88%9B%E5%BB%BA%E5%AD%97%E5%85%B8"><span class="toc-text"> Python创建字典</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E4%BD%BF%E7%94%A8%E5%88%9B%E5%BB%BA%E5%AD%97%E5%85%B8"><span class="toc-text"> 1）使用{}创建字典</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E9%80%9A%E8%BF%87fromkeys%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E5%AD%97%E5%85%B8"><span class="toc-text"> 2）通过fromkeys()方法创建字典</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E9%80%9A%E8%BF%87dict%E6%98%A0%E5%B0%84%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AD%97%E5%85%B8"><span class="toc-text"> 3）通过dict()映射函数创建字典</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E8%AE%BF%E9%97%AE%E5%AD%97%E5%85%B8"><span class="toc-text"> Python访问字典</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E5%88%A0%E9%99%A4%E5%AD%97%E5%85%B8"><span class="toc-text"> Python删除字典</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E5%AD%97%E5%85%B8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text"> Python字典基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E5%AD%97%E5%85%B8%E6%B7%BB%E5%8A%A0%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-text"> Python字典添加键值对</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E5%AD%97%E5%85%B8%E4%BF%AE%E6%94%B9%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-text"> Python字典修改键值对</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E5%AD%97%E5%85%B8%E5%88%A0%E9%99%A4%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-text"> Python字典删除键值对</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AD%97%E5%85%B8%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%8C%87%E5%AE%9A%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-text"> 判断字典中是否存在指定键值对</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E6%80%8E%E6%A0%B7%E5%88%A4%E6%96%AD%E5%AD%97%E5%85%B8%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%80%BC"><span class="toc-text"> 思考：怎样判断字典是否包含某个值？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E8%83%BD%E5%A4%9F%E6%A0%B9%E6%8D%AE%E5%80%BC%E6%89%BE%E5%88%B0%E5%AD%97%E5%85%B8%E4%B8%AD%E7%9A%84%E9%94%AE"><span class="toc-text"> 思考：能够根据值找到字典中的键？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python-dict%E5%AD%97%E5%85%B8%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-text"> Python dict字典其他方法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#keys-values%E5%92%8Citems%E6%96%B9%E6%B3%95"><span class="toc-text"> keys()、values()和items()方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E4%BD%BF%E7%94%A8list%E5%87%BD%E6%95%B0%E5%B0%86%E4%BB%96%E4%BB%AC%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E6%88%90%E5%88%97%E8%A1%A8"><span class="toc-text"> 1）使用list()函数，将他们返回的数据转换成列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E4%BD%BF%E7%94%A8for-in-%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E4%BB%96%E4%BB%AC%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text"> 2）使用for in 循环遍历他们的返回值</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#copy%E6%96%B9%E6%B3%95"><span class="toc-text"> copy()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update%E6%96%B9%E6%B3%95"><span class="toc-text"> update()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pop%E5%92%8Cpopitem%E6%96%B9%E6%B3%95"><span class="toc-text"> pop()和popitem(）方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83popitem%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text"> 思考：popitem()的底层原理？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setdefault%E6%96%B9%E6%B3%95"><span class="toc-text"> setdefault()方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E4%BD%BF%E7%94%A8%E5%AD%97%E5%85%B8%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text"> Python使用字典格式化字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python-set%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3"><span class="toc-text"> Python set集合详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E5%88%9B%E5%BB%BAset%E9%9B%86%E5%90%88"><span class="toc-text"> Python创建set集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E4%BD%BF%E7%94%A8%E5%88%9B%E5%BB%BA%E9%9B%86%E5%90%88"><span class="toc-text"> 1）使用{}创建集合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2set%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E9%9B%86%E5%90%88"><span class="toc-text"> 2）set()函数创建集合</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E8%AE%BF%E9%97%AEset%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0"><span class="toc-text"> Python访问set集合元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E5%88%A0%E9%99%A4set%E9%9B%86%E5%90%88"><span class="toc-text"> Python删除set集合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python-set%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-text"> Python set集合基础操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91set%E9%9B%86%E5%90%88%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-text"> 向set集合中添加元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8Eset%E9%9B%86%E5%90%88%E4%B8%AD%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text"> 从set集合中删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python-set%E9%9B%86%E5%90%88%E5%81%9A%E4%BA%A4%E9%9B%86-%E5%B9%B6%E9%9B%86-%E5%B7%AE%E9%9B%86%E8%BF%90%E7%AE%97"><span class="toc-text"> Python set集合做交集、并集、差集运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python-set%E9%9B%86%E5%90%88%E6%96%B9%E6%B3%95%E5%A4%A7%E5%85%A8"><span class="toc-text"> Python set集合方法大全</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python-frozenset"><span class="toc-text"> Python frozenset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E5%BA%95%E5%B1%82%E4%BA%86%E8%A7%A3python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88"><span class="toc-text"> 深入底层了解Python字典和集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text"> 字典和集合的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-text"> 哈希表插入数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE"><span class="toc-text"> 哈希表查找数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text"> 哈希表删除元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E8%AF%A6%E8%A7%A3"><span class="toc-text"> Python深拷贝和浅拷贝详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text"> Python浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%9E%84%E9%80%A0%E5%99%A8%E5%92%8C%E5%88%87%E7%89%87%E8%BF%94%E8%BF%98%E7%9A%84%E6%98%AF%E5%BC%95%E7%94%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%98%AF%E6%96%B0%E6%95%B0%E6%8D%AE"><span class="toc-text"> 思考：什么时候构造器和切片返还的是引用？什么时候是新数据？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E9%82%A3%E4%B9%88%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E8%AE%A9%E5%88%B0d2%E5%92%8Cd1%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E5%9C%B0%E5%9D%80%E5%91%A2"><span class="toc-text"> 思考：那么怎样才能让到d2和d1指向同一地址呢？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text"> Python深拷贝</span></a></li></ol></li></ol></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/index.html"><span class="toc-text">字符串</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/index.html"><span class="toc-text">流程控制</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/index.html"><span class="toc-text">函数基础</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/index.html"><span class="toc-text">函数进阶</span></a></div></div></widget>




</div>


    </aside>
    <div class='l_main'>
      

      <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?fc63ac4843a697431e3d43c4d48b99de";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
</script>



  
  
<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" id="home" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" id="menu" href="/wiki/">笔记</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/index.html">Python</a></div><div id="post-meta">更新于&nbsp;<time datetime="2023-01-28T07:49:20.231Z">2023-01-28</time></div></div>

  <article class='md-text content wiki reveal'>
  <h1 class="article-title"><span>元组、字典与集合</span></h1>
  <h3 id="python-tuple元组详解"><a class="markdownIt-Anchor" href="#python-tuple元组详解"></a> Python tuple元组详解</h3>
<p>元组（tuple)是Python中另一个重要的序列结构，和列表类似，元组也是由一系列按特定顺序排列的元组组成。但是他和list列表又有所区别如下：</p>
<ul>
<li>列表的元素是可以更改的，包括修改元素值，删除和插入元素，所以列表是可变序列；</li>
<li>而元组一旦被创建，它的元素就不可更改了，所以元组是不可变序列。</li>
</ul>
<p>元组可以看成是不可变的列表，<strong>因此他不提供append()，remove()等方法同时也不支持<code>del tuple[idx]</code>删除元组的方法</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>tup=(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> tup(<span class="hljs-number">0</span>)<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span><br>SyntaxError: cannot delete function call<br></code></pre></td></tr></table></figure>
<p>通常情况下，元组用于保存无需修改的内容。从形式上看，元组的所有元素都放在一对小括号<code>()</code>中，相邻元素之间用逗号<code>,</code>分隔，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(element1, element2, ... , elementn)<br></code></pre></td></tr></table></figure>
<p>其中 element1~elementn 表示元组中的各个元素，个数没有限制，只要是 Python 支持的数据类型就可以。<strong>因此元组中也可以存储若干个类型不同的数据，但是为了提高可读性，一般也存储相同类型的数据</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(<span class="hljs-string">&quot;c.biancheng.net&quot;</span>, <span class="hljs-number">1</span>, [<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;a&#x27;</span>], (<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-number">3.0</span>))<br></code></pre></td></tr></table></figure>
<div class="tag-plugin note" color="yellow"><div class="body"><p>要注意元组tuple和列表list是两种不同的数据结构，他们的type类型并不相同！</p></div></div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>( (<span class="hljs-string">&quot;c.biancheng.net&quot;</span>,<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;a&#x27;</span>],(<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-number">3.0</span>)) )<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;<br></code></pre></td></tr></table></figure>
<h4 id="python创建元组"><a class="markdownIt-Anchor" href="#python创建元组"></a> Python创建元组</h4>
<p>Python中元组的创建和list类似也有两种创建方法</p>
<h5 id="1使用创建"><a class="markdownIt-Anchor" href="#1使用创建"></a> 1）使用()创建</h5>
<p>通过()创建元组以后，一般使用<code>=</code>将它赋值给某个变量，具体格式为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tuplename = (element1, element2, ..., elementn)<br></code></pre></td></tr></table></figure>
<p>其中，tuplename表示变量名，element1~elementn表示元组存储的元素。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">num = (<span class="hljs-number">7</span>, <span class="hljs-number">14</span>, <span class="hljs-number">21</span>, <span class="hljs-number">28</span>, <span class="hljs-number">35</span>)<br>course = (<span class="hljs-string">&quot;Python教程&quot;</span>, <span class="hljs-string">&quot;http://coolchong.cn&quot;</span>)<br>abc = ( <span class="hljs-string">&quot;Python&quot;</span>, <span class="hljs-number">19</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], (<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">2.0</span>) )<br></code></pre></td></tr></table></figure>
<p>在Python中，元组通常都是使用一对小括号将所有元素包围起来的，但是小括号不是必须的，只要将各元素用逗号分隔，Python就会将其视为元组，如下也是元组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">course = <span class="hljs-string">&quot;Python教程&quot;</span>, <span class="hljs-string">&quot;http://coolchong.cn&quot;</span><br><span class="hljs-built_in">print</span>(course)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(<span class="hljs-string">&#x27;Python教程&#x27;</span>, <span class="hljs-string">&#x27;http://coolchong.cn&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p><strong>要特别注意，当创建的元组中只有一个字符串类型的元素时，该元素后面必须要加一个逗号<code>,</code></strong>，否则Python解释器会将它视为字符串，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a=(<span class="hljs-string">&quot;https://coolchong.cn/&quot;</span>,)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a))<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>b=(<span class="hljs-string">&quot;https://coolchong.cn/&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(b))<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br></code></pre></td></tr></table></figure>
<h5 id="2使用tuple函数创建元组"><a class="markdownIt-Anchor" href="#2使用tuple函数创建元组"></a> 2)使用tuple()函数创建元组</h5>
<p>除了使用<code>()</code>创建元组外，Python还提供了一个内置的函数tuple()，可以用来将其他数据类型转换为元组类型。tuple()的语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">tuple</span>(data)<br></code></pre></td></tr></table></figure>
<p>其中data表示可以转换为元组的数据，包含字符串、元组、range()对象等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#将字符串转换成元组</span><br>tup1 = <span class="hljs-built_in">tuple</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br><span class="hljs-built_in">print</span>(tup1)<br><span class="hljs-comment">#将列表转换成元组</span><br>list1 = [<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>]<br>tup2 = <span class="hljs-built_in">tuple</span>(list1)<br><span class="hljs-built_in">print</span>(tup2)<br><span class="hljs-comment">#将字典转换成元组</span><br>dict1 = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">100</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">42</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">9</span>&#125;<br>tup3 = <span class="hljs-built_in">tuple</span>(dict1)<br><span class="hljs-built_in">print</span>(tup3)<br><span class="hljs-comment">#将区间转换成元组</span><br>range1 = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)<br>tup4 = <span class="hljs-built_in">tuple</span>(range1)<br><span class="hljs-built_in">print</span>(tup4)<br><span class="hljs-comment">#创建空元组</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">tuple</span>())<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">(<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>)<br>(<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>)<br>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>()<br></code></pre></td></tr></table></figure>
<h4 id="python访问元组元素"><a class="markdownIt-Anchor" href="#python访问元组元素"></a> Python访问元组元素</h4>
<p>和列表一样，我们也可以使用索引(Index)访问元组的某个元素（得到的是一个元素的值），也可以使用切片访问元组的一组元素(得到的是一个新的子元组)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#访问单个元素</span><br>tuplename[i]<br><span class="hljs-comment">#访问一组元素</span><br>tuplename[start : end : step]<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">url = <span class="hljs-built_in">tuple</span>(<span class="hljs-string">&quot;http://c.biancheng.net/shell/&quot;</span>)<br><span class="hljs-comment">#使用索引访问元组中的某个元素</span><br><span class="hljs-built_in">print</span>(url[<span class="hljs-number">3</span>])  <span class="hljs-comment">#使用正数索引</span><br><span class="hljs-built_in">print</span>(url[-<span class="hljs-number">4</span>])  <span class="hljs-comment">#使用负数索引</span><br><span class="hljs-comment">#使用切片访问元组中的一组元素</span><br><span class="hljs-built_in">print</span>(url[<span class="hljs-number">9</span>: <span class="hljs-number">18</span>])  <span class="hljs-comment">#使用正数切片</span><br><span class="hljs-built_in">print</span>(url[<span class="hljs-number">9</span>: <span class="hljs-number">18</span>: <span class="hljs-number">3</span>])  <span class="hljs-comment">#指定步长</span><br><span class="hljs-built_in">print</span>(url[-<span class="hljs-number">6</span>: -<span class="hljs-number">1</span>])  <span class="hljs-comment">#使用负数切片</span><br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">p<br>e<br>(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>)<br>(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>)<br>(<span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>)<br></code></pre></td></tr></table></figure>
<h4 id="python修改元组"><a class="markdownIt-Anchor" href="#python修改元组"></a> Python修改元组</h4>
<p>前面我们已经介绍过元组是无法修改的，因此我们只能是为变量赋值一个新元素来改变变量的元组值如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">tup = (<span class="hljs-number">100</span>, <span class="hljs-number">0.5</span>, -<span class="hljs-number">36</span>, <span class="hljs-number">73</span>)<br><span class="hljs-built_in">print</span>(tup)<br><span class="hljs-comment">#对元组进行重新赋值</span><br>tup = (<span class="hljs-string">&#x27;Shell脚本&#x27;</span>,<span class="hljs-string">&quot;https://coolchong.cn/&quot;</span>)<br><span class="hljs-built_in">print</span>(tup)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">(<span class="hljs-number">100</span>, <span class="hljs-number">0.5</span>, -<span class="hljs-number">36</span>, <span class="hljs-number">73</span>)<br>(<span class="hljs-string">&#x27;Shell脚本&#x27;</span>, <span class="hljs-string">&#x27;https://coolchong.cn/&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>同时我们也可以使用<code>+</code>拼接元组生成一个新的元组，但是也不会改变原元组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">tup1 = (<span class="hljs-number">100</span>, <span class="hljs-number">0.5</span>, -<span class="hljs-number">36</span>, <span class="hljs-number">73</span>)<br>tup2 = (<span class="hljs-number">3</span>+<span class="hljs-number">12j</span>, -<span class="hljs-number">54.6</span>, <span class="hljs-number">99</span>)<br><span class="hljs-built_in">print</span>(tup1+tup2)<br><span class="hljs-built_in">print</span>(tup1)<br><span class="hljs-built_in">print</span>(tup2)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">100</span>, <span class="hljs-number">0.5</span>, -<span class="hljs-number">36</span>, <span class="hljs-number">73</span>, (<span class="hljs-number">3</span>+<span class="hljs-number">12j</span>), -<span class="hljs-number">54.6</span>, <span class="hljs-number">99</span>)<br>(<span class="hljs-number">100</span>, <span class="hljs-number">0.5</span>, -<span class="hljs-number">36</span>, <span class="hljs-number">73</span>)<br>((<span class="hljs-number">3</span>+<span class="hljs-number">12j</span>), -<span class="hljs-number">54.6</span>, <span class="hljs-number">99</span>)<br></code></pre></td></tr></table></figure>
<h4 id="python删除元组"><a class="markdownIt-Anchor" href="#python删除元组"></a> Python删除元组</h4>
<p>我们并不能删除元组中的某一个元素，但是我们可以删除不再使用的整个元组，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">tup = (<span class="hljs-string">&#x27;Java教程&#x27;</span>,<span class="hljs-string">&quot;http://coolchong.cn/&quot;</span>)<br><span class="hljs-built_in">print</span>(tup)<br><span class="hljs-keyword">del</span> tup<br><span class="hljs-built_in">print</span>(tup)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">(<span class="hljs-string">&#x27;Java教程&#x27;</span>, <span class="hljs-string">&#x27;http://coolchong.cn&#x27;</span>)<br>Traceback (most recent call last):<br>    File <span class="hljs-string">&quot;C:\Users\mozhiyan\Desktop\demo.py&quot;</span>, line <span class="hljs-number">4</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>        <span class="hljs-built_in">print</span>(tup)<br>NameError: name <span class="hljs-string">&#x27;tup&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined<br></code></pre></td></tr></table></figure>
<p>Python 自带垃圾回收功能，会自动销毁不用的元组，所以一般不需要通过 del 来手动删除。</p>
<h3 id="python中元素和列表的区别"><a class="markdownIt-Anchor" href="#python中元素和列表的区别"></a> Python中元素和列表的区别</h3>
<p>看完前面对元组和列表的介绍以后，我们可以发现两者有很多共同点，但是列表中的元素可以任意修改，就好比是用铅笔在纸上写的字，写错了还可以擦除重写，而元组中的元素无法修改，除非将元组整体替换掉，就好比是用圆珠笔写的字，写了就擦不掉除非换一张纸。</p>
<div class="tag-plugin note" color="yellow"><div class="body"><p>可以将元组tuple理解为一个只读版本的列表list即可</p></div></div>
<p>由于两者的存储特性不同，因此存储方式也是不同的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>listdemo = []<br><span class="hljs-meta">&gt;&gt;&gt; </span>listdemo.__sizeof__()<br><span class="hljs-number">40</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>tupleDemo = ()<br><span class="hljs-meta">&gt;&gt;&gt; </span>tupleDemo.__sizeof__()<br><span class="hljs-number">24</span><br></code></pre></td></tr></table></figure>
<p>可以看出虽然列表和元组都是空的，但是元组却比列表少占用了16个字节，这是因为列表是动态的，需要存储指针指向对应的元素（占用8个字节），另外，由于列表是可变的，所以需要额外存储已经分配的长度大小（占用8个字节）。但是对于元组，他由于不可变，长度固定 ，因此存储空间也是固定的，不需要指针和额外的空间因此相较于列表更加轻量级，性能也要略优于列表。</p>
<p>但是既然列表就可以实现元组的功能，我们为什么还要保留使用元组这个数据类型呢？这要从Python的垃圾回收机制讲起，在Python中如果一些变量不再使用，Python就会回收他们所占用的内存，返还给操作系统，以便其他变量或其他应用使用。但是对于一些静态变量，（比如元组），如果他占用的空间不大，那么Python会暂时缓存这些内存，这样的话，下一次再创建同样大小的元组时，Python就可以不用再向操作系统发出请求取寻找内存了，而是直接分配之前缓存的内存空间，大大提升程序的运行速度（大约快了5倍）。因此元组具有不可替代性。同时，<strong>元组还可以在映射（和集合的成员）中当做<code>键</code>使用，而列表是不行的。</strong></p>
<h3 id="python-dict字典"><a class="markdownIt-Anchor" href="#python-dict字典"></a> Python dict字典</h3>
<p>Python中字典(dict)是一种无序的、可变的序列，他的元组以<code>键值对(key-value)</code>的形式存储因此元素在底层并不是挨着存放的。相对地，列表和元组都是有序的序列，他们的元素在底层是挨着存放的。</p>
<p>字典类型是Python中<strong>唯一</strong>的映射类型，”映射“是数学中的术语，简单理解，他指的是元素之间相互对应的关系，即用过一个元素就可以唯一的找到另一个元素如下所示：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20220117152326.png" alt="" /></p>
<p>字典类型的特点就是：</p>
<table>
<thead>
<tr>
<th style="text-align:center">主要特征</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">通过键而不是通过索引来读取元素</td>
<td style="text-align:center">字典类型有时也称为关联数组或者散列表（hash）。它是通过键将一系列的值联系起来的，这样就可以通过键从字典中获取指定项，但不能通过索引来获取。</td>
</tr>
<tr>
<td style="text-align:center">字典是任意数据类型的无序集合</td>
<td style="text-align:center">和列表、元组不同，通常会将索引值 0 对应的元素称为第一个元素，而字典中的元素是无序的。</td>
</tr>
<tr>
<td style="text-align:center">字典是可变的，并且可以任意嵌套</td>
<td style="text-align:center">字典可以在原处增长或者缩短（无需生成一个副本），并且它支持任意深度的嵌套，即字典存储的值也可以是列表或其它的字典。</td>
</tr>
<tr>
<td style="text-align:center">字典中的键必须唯一</td>
<td style="text-align:center">字典中，不支持同一个键出现多次，否则只会保留最后一个键值对。</td>
</tr>
<tr>
<td style="text-align:center">字典中的键必须不可变</td>
<td style="text-align:center">字典中每个键值对的键是不可变的，只能使用数字、字符串或者元组，不能使用列表。</td>
</tr>
</tbody>
</table>
<div class="tag-plugin note" color="yellow"><div class="body"><p>Python中的字典类型相当于Java或者C<ins>中的Map对象，但是它比Map对象更加灵活，因为字典的键类型可以是任意的，而不像Java或者C</ins>中需要提前声明键的数据类型保证所有的键类型统一。</p></div></div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = &#123;<span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;three&#x27;</span>: <span class="hljs-number">3</span>&#125;  <span class="hljs-comment">#a是一个字典类型</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(a)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;dict&#x27;</span>&gt;<br></code></pre></td></tr></table></figure>
<h4 id="python创建字典"><a class="markdownIt-Anchor" href="#python创建字典"></a> Python创建字典</h4>
<h5 id="1使用创建字典"><a class="markdownIt-Anchor" href="#1使用创建字典"></a> 1）使用{}创建字典</h5>
<p>由于字典中每一个元素都包含两个部分，分别是键（key）和值（value），因此创建字典时、键和值之间使用冒号<code>:</code>分隔，相邻元素之间使用逗号<code>,</code>分隔，所有元素放在大括号<code>&#123;&#125;</code>中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dictname = &#123;<span class="hljs-string">&#x27;key&#x27;</span>:<span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>:<span class="hljs-string">&#x27;value2&#x27;</span>, ..., <span class="hljs-string">&#x27;keyn&#x27;</span>:valuen&#125;<br></code></pre></td></tr></table></figure>
<p>其中 dictname 表示字典变量名，keyn : valuen 表示各个元素的键值对。需要注意的是，同一字典中的各个键必须唯一，不能重复。<strong>当为已有键再次设定值的时候会将之前的值覆盖掉。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用字符串作为key</span><br>scores = &#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">92</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">84</span>&#125;<br><span class="hljs-built_in">print</span>(scores)<br><span class="hljs-comment">#使用元组和数字作为key</span><br>dict1 = &#123;(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>): <span class="hljs-string">&#x27;great&#x27;</span>, <span class="hljs-number">30</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]&#125;<br><span class="hljs-built_in">print</span>(dict1)<br><span class="hljs-comment">#创建空元组</span><br>dict2 = &#123;&#125;<br><span class="hljs-built_in">print</span>(dict2)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">92</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">84</span>&#125;<br>&#123;(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>): <span class="hljs-string">&#x27;great&#x27;</span>, <span class="hljs-number">30</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#125;<br>&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，字典的键可以是整数、字符串或者元组，只要符合唯一和不可变的特性就行；字典的值可以是 Python 支持的任意数据类型。</p>
<h5 id="2通过fromkeys方法创建字典"><a class="markdownIt-Anchor" href="#2通过fromkeys方法创建字典"></a> 2）通过fromkeys()方法创建字典</h5>
<p>在Python中我们还可以使用dict字典类型提供的fromkeys()方法创建带有默认值的字典，具体格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dictname = <span class="hljs-built_in">dict</span>.fromkeys(<span class="hljs-built_in">list</span>，value=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure>
<p>其中list参数表示字典中所有键的列表（因此必须各不相同），value参数表示所有值的默认值，如果不写，就会设置为空值None。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">knowledge = [<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]<br>scores = <span class="hljs-built_in">dict</span>.fromkeys(knowledge, <span class="hljs-number">60</span>)<br><span class="hljs-built_in">print</span>(scores)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">60</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">60</span>, <span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">60</span>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="3通过dict映射函数创建字典"><a class="markdownIt-Anchor" href="#3通过dict映射函数创建字典"></a> 3）通过dict()映射函数创建字典</h5>
<p>通过dict()函数创建字典的写法有多种，如下所示几种写法都是等价的创建了同一个字典a</p>
<table>
<thead>
<tr>
<th style="text-align:center">创建格式</th>
<th style="text-align:center">注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a = dict(str1=value1, str2=value2, str3=value3)</td>
<td style="text-align:center">str 表示字符串类型的键，value 表示键对应的值。使用此方式创建字典时，字符串不能带引号。<strong>这种方式创建会导致键都是统一的字符串类型</strong></td>
</tr>
<tr>
<td style="text-align:center">#方式1<br/>demo = [(‘two’,2), (‘one’,1), (‘three’,3)]<br/>#方式2<br/>demo = [[‘two’,2], [‘one’,1], [‘three’,3]]<br/>#方式3<br/>demo = ((‘two’,2), (‘one’,1), (‘three’,3))<br/>#方式4<br/>demo = ([‘two’,2], [‘one’,1], [‘three’,3])<br/>a = dict(demo)</td>
<td style="text-align:center">向 dict() 函数传入列表或元组，而它们中的元素又各自是包含 2 个元素的列表或元组，其中第一个元素作为键，第二个元素作为值。</td>
</tr>
<tr>
<td style="text-align:center">eys = [‘one’, ‘two’, ‘three’] #还可以是字符串或元组<br/>values = [1, 2, 3] #还可以是字符串或元组<br/>a = dict( zip(keys, values) )</td>
<td style="text-align:center">通过应用 dict() 函数和 zip() 函数，可将前两个列表转换为对应的字典。</td>
</tr>
</tbody>
</table>
<div class="tag-plugin note" color="yellow"><div class="body"><p>注意，无论采用以上哪种方式创建字典，字典中各元素的键都只能是字符串、元组或者数字，<strong>不能是列表，因为列表是可变的，不能作为键。</strong></p></div></div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a=<span class="hljs-built_in">dict</span>(name=<span class="hljs-string">&quot;langwenchong&quot;</span>,height=<span class="hljs-number">190</span>,age=<span class="hljs-number">20</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>pring(a)<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;langwenchong&#x27;</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">190</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>demo=([<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;one&#x27;</span>],[<span class="hljs-string">&#x27;two&#x27;</span>,<span class="hljs-number">2</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>b=<span class="hljs-built_in">dict</span>(demo)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(b)<br>&#123;<span class="hljs-number">1</span>: <span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>keys=((<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>),<span class="hljs-string">&#x27;height&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>values=[<span class="hljs-string">&quot;langwenchong+20&quot;</span>,<span class="hljs-number">190</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>c=<span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(keys,values))<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(c)<br>&#123;(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>): <span class="hljs-string">&#x27;langwenchong+20&#x27;</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">190</span>&#125;<br></code></pre></td></tr></table></figure>
<p>如果不为dict()函数传入任何参数，那么代表创建一个空的字典，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建空的字典</span><br>d = <span class="hljs-built_in">dict</span>()<br><span class="hljs-built_in">print</span>(d)<br></code></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;&#125;<br></code></pre></td></tr></table></figure>
<h4 id="python访问字典"><a class="markdownIt-Anchor" href="#python访问字典"></a> Python访问字典</h4>
<p>列表和元组都是通过下表索引来访问元素的，而字典不同，他可以通过键来访问对应的值。因为字典中的元素都是无序的，每一个元素的位置都是不固定的，因此字典也不能像列表和元组那样，采用切片的方式一次性访问多个元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">tup = ([<span class="hljs-string">&#x27;two&#x27;</span>,<span class="hljs-number">26</span>], [<span class="hljs-string">&#x27;one&#x27;</span>,<span class="hljs-number">88</span>], [<span class="hljs-string">&#x27;three&#x27;</span>,<span class="hljs-number">100</span>], [<span class="hljs-string">&#x27;four&#x27;</span>,-<span class="hljs-number">59</span>])<br>dic = <span class="hljs-built_in">dict</span>(tup)<br><span class="hljs-built_in">print</span>(dic[<span class="hljs-string">&#x27;one&#x27;</span>])  <span class="hljs-comment">#键存在</span><br><span class="hljs-built_in">print</span>(dic[<span class="hljs-string">&#x27;five&#x27;</span>])  <span class="hljs-comment">#键不存在</span><br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">88</span><br>Traceback (most recent call last):<br>    File <span class="hljs-string">&quot;C:\Users\mozhiyan\Desktop\demo.py&quot;</span>, line <span class="hljs-number">4</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>        <span class="hljs-built_in">print</span>(dic[<span class="hljs-string">&#x27;five&#x27;</span>])  <span class="hljs-comment">#键不存在</span><br>KeyError: <span class="hljs-string">&#x27;five&#x27;</span><br></code></pre></td></tr></table></figure>
<p>除了上面这种方式访问字典，Python更推荐使用get()方法来获取指定键对应的值，当指定的键不存在时，get()方法不会抛出异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dictname.get(key[,default]) <br></code></pre></td></tr></table></figure>
<p>其中，dictname 表示字典变量的名字；key 表示指定的键；default 用于指定要查询的键不存在时，此方法返回的默认值，<strong>如果不手动指定，会返回 None</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-built_in">dict</span>(two=<span class="hljs-number">0.65</span>, one=<span class="hljs-number">88</span>, three=<span class="hljs-number">100</span>, four=-<span class="hljs-number">59</span>)<br><span class="hljs-built_in">print</span>( a.get(<span class="hljs-string">&#x27;one&#x27;</span>) )<br><span class="hljs-built_in">print</span>( a.get(<span class="hljs-string">&#x27;five&#x27;</span>) )<br><span class="hljs-built_in">print</span>( a.get(<span class="hljs-string">&#x27;five&#x27;</span>, <span class="hljs-string">&#x27;该键不存在&#x27;</span>) )<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">88</span><br><span class="hljs-literal">None</span><br>该键不存在<br></code></pre></td></tr></table></figure>
<h4 id="python删除字典"><a class="markdownIt-Anchor" href="#python删除字典"></a> Python删除字典</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-built_in">dict</span>(two=<span class="hljs-number">0.65</span>, one=<span class="hljs-number">88</span>, three=<span class="hljs-number">100</span>, four=-<span class="hljs-number">59</span>)<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-keyword">del</span> a<br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">0.65</span>, <span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">88</span>, <span class="hljs-string">&#x27;three&#x27;</span>: <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;four&#x27;</span>: -<span class="hljs-number">59</span>&#125;<br>Traceback (most recent call last):<br>    File <span class="hljs-string">&quot;C:\Users\mozhiyan\Desktop\demo.py&quot;</span>, line <span class="hljs-number">4</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>        <span class="hljs-built_in">print</span>(a)<br>NameError: name <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined<br></code></pre></td></tr></table></figure>
<h3 id="python字典基本操作"><a class="markdownIt-Anchor" href="#python字典基本操作"></a> Python字典基本操作</h3>
<p>字典是一个可变序列，因此我们可以添加、修改、删除字典中的键值对，常见的字典操作有以下几种：</p>
<ul>
<li>向现有字典中添加新的键值对。</li>
<li>修改现有字典中的键值对。</li>
<li>从现有字典中删除指定的键值对。</li>
<li>判断现有字典中是否存在指定的键值对。</li>
</ul>
<h4 id="python字典添加键值对"><a class="markdownIt-Anchor" href="#python字典添加键值对"></a> Python字典添加键值对</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dictname[key] = value<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">a = &#123;<span class="hljs-string">&#x27;数学&#x27;</span>:<span class="hljs-number">95</span>&#125;<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-comment">#添加新键值对</span><br>a[<span class="hljs-string">&#x27;语文&#x27;</span>] = <span class="hljs-number">89</span><br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-comment">#再次添加新键值对</span><br>a[<span class="hljs-string">&#x27;英语&#x27;</span>] = <span class="hljs-number">90</span><br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>&#125;<br>&#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">89</span>&#125;<br>&#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">90</span>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="python字典修改键值对"><a class="markdownIt-Anchor" href="#python字典修改键值对"></a> Python字典修改键值对</h4>
<p>Python字典中的键的名字是不能被修改的，但是我们可以修改键对应的值。由于字典中各元素的键是唯一的，因此，如果新添加元素的键与已存在的元素的键相同，那么键所对应的值就会被新的值替换掉，以此达到修改元素值的目的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = &#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">90</span>&#125;<br><span class="hljs-built_in">print</span>(a)<br>a[<span class="hljs-string">&#x27;语文&#x27;</span>] = <span class="hljs-number">100</span><br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">90</span>&#125;<br>&#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">90</span>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="python字典删除键值对"><a class="markdownIt-Anchor" href="#python字典删除键值对"></a> Python字典删除键值对</h4>
<p>如果要删除字典中的键值对，还是可以使用del语句</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用del语句删除键值对</span><br>a = &#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">90</span>&#125;<br><span class="hljs-keyword">del</span> a[<span class="hljs-string">&#x27;语文&#x27;</span>]<br><span class="hljs-keyword">del</span> a[<span class="hljs-string">&#x27;数学&#x27;</span>]<br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">90</span>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="判断字典中是否存在指定键值对"><a class="markdownIt-Anchor" href="#判断字典中是否存在指定键值对"></a> 判断字典中是否存在指定键值对</h4>
<p>我们只能通过<code>in</code>和<code>noe in</code>运算符对键进行判断，而无法判断值是否在字典中即只能判断是否为字典的键而不能判断是否为字典的值，如下都是基于键key的判断</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">a = &#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">90</span>&#125;<br><span class="hljs-comment"># 判断 a 中是否包含名为&#x27;数学&#x27;的key</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;数学&#x27;</span> <span class="hljs-keyword">in</span> a) <span class="hljs-comment"># True</span><br><span class="hljs-comment"># 判断 a 是否包含名为&#x27;物理&#x27;的key</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;物理&#x27;</span> <span class="hljs-keyword">in</span> a) <span class="hljs-comment"># False</span><br><span class="hljs-comment"># 这个判断是判断95是否为字典的键</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">95</span> <span class="hljs-keyword">in</span> a) <span class="hljs-comment">#False</span><br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<h5 id="思考怎样判断字典是否包含某个值"><a class="markdownIt-Anchor" href="#思考怎样判断字典是否包含某个值"></a> 思考：怎样判断字典是否包含某个值？</h5>
<p>我们可以通过dict.keys()和dict.values()获取所有的键和所有的值，这样我们可以使用in和dict.values()来实现值的查找</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>d = &#123;<span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-string">&#x27;three&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>: <span class="hljs-string">&#x27;five&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>: <span class="hljs-string">&#x27;four&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;one&#x27;</span> <span class="hljs-keyword">in</span> d.values()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<h5 id="思考能够根据值找到字典中的键"><a class="markdownIt-Anchor" href="#思考能够根据值找到字典中的键"></a> 思考：能够根据值找到字典中的键？</h5>
<p>可以代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>d = &#123;<span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-string">&#x27;three&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>: <span class="hljs-string">&#x27;five&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>: <span class="hljs-string">&#x27;four&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(d.keys())[<span class="hljs-built_in">list</span>(d.values()).index(<span class="hljs-string">&#x27;one&#x27;</span>)]   <span class="hljs-comment">#根据字典值  返回对应的key</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;1&#x27;</span><br></code></pre></td></tr></table></figure>
<div class="tag-plugin note" color="yellow"><div class="body"><p>根据上面的代码我们可以得出一个结论，即dict的键中的第k个键与值中的第k个值正好可以组成字典中的第k个键值对，即键和值的相对位置是对应的。</p></div></div>
<h3 id="python-dict字典其他方法详解"><a class="markdownIt-Anchor" href="#python-dict字典其他方法详解"></a> Python dict字典其他方法详解</h3>
<p>前面我们学习了fromkeys()和get()，这里再介绍剩余的函数。</p>
<h4 id="keys-values和items方法"><a class="markdownIt-Anchor" href="#keys-values和items方法"></a> keys()、values()和items()方法</h4>
<p>将这三个放在一起介绍，是因为他们都用来获取字典中特定数据：</p>
<ul>
<li>eys() 方法用于返回字典中的所有键（key）；</li>
<li>values() 方法用于返回字典中所有键对应的值（value）；</li>
<li>items() 用于返回字典中所有的键值对（key-value）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">scores = &#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">90</span>&#125;<br><span class="hljs-built_in">print</span>(scores.keys())<br><span class="hljs-built_in">print</span>(scores.values())<br><span class="hljs-built_in">print</span>(scores.items())<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dict_keys([<span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>])<br>dict_values([<span class="hljs-number">95</span>, <span class="hljs-number">89</span>, <span class="hljs-number">90</span>])<br>dict_items([(<span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-number">95</span>), (<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-number">89</span>), (<span class="hljs-string">&#x27;英语&#x27;</span>, <span class="hljs-number">90</span>)])<br></code></pre></td></tr></table></figure>
<p>要注意，<strong>keys()、values()和items()返回值类型分别为dic_keys、dict_values、dict_items而并不是列表list或元组tuple或集合set</strong>。这是因为Python并不希望我们用户能直接操作这几个方法的返回值。</p>
<p>为了能够使用这三个方法返回的数据进行操作，我们有以下几种方案，但是无一例外都是使用的新数据，而并没有操作原字典 数据，即操作并不会影响改变字典</p>
<h5 id="1使用list函数将他们返回的数据转换成列表"><a class="markdownIt-Anchor" href="#1使用list函数将他们返回的数据转换成列表"></a> 1）使用list()函数，将他们返回的数据转换成列表</h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = &#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">90</span>&#125;<br>b = <span class="hljs-built_in">list</span>(a.keys())<br><span class="hljs-built_in">print</span>(b)a = &#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">90</span>&#125;<br>b = <span class="hljs-built_in">list</span>(a.keys())<br><span class="hljs-built_in">print</span>(b)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>]<br></code></pre></td></tr></table></figure>
<h5 id="2使用for-in-循环遍历他们的返回值"><a class="markdownIt-Anchor" href="#2使用for-in-循环遍历他们的返回值"></a> 2）使用for in 循环遍历他们的返回值</h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">a = &#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">90</span>&#125;<br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> a.keys():<br>    <span class="hljs-built_in">print</span>(k,end=<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n---------------&quot;</span>)<br><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> a.values():<br>    <span class="hljs-built_in">print</span>(v,end=<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n---------------&quot;</span>)<br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> a.items():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;key:&quot;</span>,k,<span class="hljs-string">&quot; value:&quot;</span>,v)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">数学 语文 英语<br>---------------<br><span class="hljs-number">95</span> <span class="hljs-number">89</span> <span class="hljs-number">90</span><br>---------------<br>key: 数学  value: <span class="hljs-number">95</span><br>key: 语文  value: <span class="hljs-number">89</span><br>key: 英语  value: <span class="hljs-number">90</span><br></code></pre></td></tr></table></figure>
<h4 id="copy方法"><a class="markdownIt-Anchor" href="#copy方法"></a> copy()方法</h4>
<p>copy()方法返回一个字典的拷贝，也即返回一个具有相同键值对的新字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = &#123;<span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;three&#x27;</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]&#125;<br>b = a.copy()<br><span class="hljs-built_in">print</span>(b)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;three&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#125;<br></code></pre></td></tr></table></figure>
<p>但是我们要注意此时copy()方法只是浅拷贝，即只是对最表层的键值对进行了深拷贝，也就是说它会再申请一块内存用来存放<code>&#123;'one':1,'two':2,'three':[]&#125;</code>,而对于某些列表类型的值来说，此方法对其做的是浅拷贝，也就是说，b中的[1,2,3]的值不是自己独有的， 而是和a共有指向的统一内存单元。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">a = &#123;<span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;three&#x27;</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]&#125;<br>b = a.copy()<br><span class="hljs-comment">#向 a 中添加新键值对，由于b已经提前将 a 所有键值对都深拷贝过来，因此 a 添加新键值对，不会影响 b。</span><br>a[<span class="hljs-string">&#x27;four&#x27;</span>]=<span class="hljs-number">100</span><br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(b)<br><span class="hljs-comment">#由于 b 和 a 共享[1,2,3]（浅拷贝），因此移除 a 中列表中的元素，也会影响 b。</span><br>a[<span class="hljs-string">&#x27;three&#x27;</span>].remove(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(b)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;three&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-string">&#x27;four&#x27;</span>: <span class="hljs-number">100</span>&#125;<br>&#123;<span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;three&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#125;<br>&#123;<span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;three&#x27;</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-string">&#x27;four&#x27;</span>: <span class="hljs-number">100</span>&#125;<br>&#123;<span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;three&#x27;</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#125;<br></code></pre></td></tr></table></figure>
<p>从运行结果不难看出，对a增加新键值对，b不变；而修改a某键值对中列表内的元素，b也会相应改变。</p>
<h4 id="update方法"><a class="markdownIt-Anchor" href="#update方法"></a> update()方法</h4>
<p>update()方法可以使用一个字典所包含的键值对来更新已有的字典。在执行update()方法时，如果被更新的字典已包含对应的键值对，那么value会被覆盖，如果被更新的字典中不包含对应的键值对，那么键值对被添加进去。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = &#123;<span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;three&#x27;</span>: <span class="hljs-number">3</span>&#125;<br>a.update(&#123;<span class="hljs-string">&#x27;one&#x27;</span>:<span class="hljs-number">4.5</span>, <span class="hljs-string">&#x27;four&#x27;</span>: <span class="hljs-number">9.3</span>&#125;)<br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">4.5</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;three&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;four&#x27;</span>: <span class="hljs-number">9.3</span>&#125;<br></code></pre></td></tr></table></figure>
<p>从运行结果可以看出，由于被更新的字典已经包含key为&quot;one&quot;的键值对，因此更改时键值对的value被改写，而被更新的字典中不包含key为“four&quot;的键值对，所以更新时会为原字典增加一个新的键值对。</p>
<h4 id="pop和popitem方法"><a class="markdownIt-Anchor" href="#pop和popitem方法"></a> pop()和popitem(）方法</h4>
<p>pop和popitem()都用来删除字典中的键值对，不同的是，pop()用来删除指定的键值对，而popitem()用来随机删除一个键值对，他们得语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">dictname.pop(key)<br>dictname.popitem()<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a = &#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">90</span>, <span class="hljs-string">&#x27;化学&#x27;</span>: <span class="hljs-number">83</span>, <span class="hljs-string">&#x27;生物&#x27;</span>: <span class="hljs-number">98</span>, <span class="hljs-string">&#x27;物理&#x27;</span>: <span class="hljs-number">89</span>&#125;<br><span class="hljs-built_in">print</span>(a)<br>a.pop(<span class="hljs-string">&#x27;化学&#x27;</span>)<br><span class="hljs-built_in">print</span>(a)<br>a.popitem()<br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">90</span>, <span class="hljs-string">&#x27;化学&#x27;</span>: <span class="hljs-number">83</span>, <span class="hljs-string">&#x27;生物&#x27;</span>: <span class="hljs-number">98</span>, <span class="hljs-string">&#x27;物理&#x27;</span>: <span class="hljs-number">89</span>&#125;<br>&#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">90</span>, <span class="hljs-string">&#x27;生物&#x27;</span>: <span class="hljs-number">98</span>, <span class="hljs-string">&#x27;物理&#x27;</span>: <span class="hljs-number">89</span>&#125;<br>&#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">90</span>, <span class="hljs-string">&#x27;生物&#x27;</span>: <span class="hljs-number">98</span>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="思考popitem的底层原理"><a class="markdownIt-Anchor" href="#思考popitem的底层原理"></a> 思考：popitem()的底层原理？</h5>
<p>其实，说popitem()随机删除字典中的一个键值对是不准确的，虽然字典时一种无序的列表，但是键值对在底层也是有存储顺序的，popitem()总是弹出底层的最后一个key-value，这和列表的pop()方法类似，都实现了数据结构中的“出栈”的操作。</p>
<h4 id="setdefault方法"><a class="markdownIt-Anchor" href="#setdefault方法"></a> setdefault()方法</h4>
<p>setdefault()方法用来返回字典中某个key对应的value值，但是他在返回前会进行以下操作：</p>
<ul>
<li>如果该 key 存在，那么直接返回该 key 对应的 value；</li>
<li>如果该 key 不存在，那么先为该 key 设置默认的 defaultvalue（可以理解为插入了一个新的键值对，key-defaultvalue），然后再返回该 key 对应的 defaultvalue。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">a = &#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">90</span>&#125;<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-comment">#key不存在，指定默认值</span><br>a.setdefault(<span class="hljs-string">&#x27;物理&#x27;</span>, <span class="hljs-number">94</span>)<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-comment">#key不存在，不指定默认值</span><br>a.setdefault(<span class="hljs-string">&#x27;化学&#x27;</span>)<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-comment">#key存在，指定默认值</span><br>a.setdefault(<span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-number">100</span>)<br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">90</span>&#125;<br>&#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">90</span>, <span class="hljs-string">&#x27;物理&#x27;</span>: <span class="hljs-number">94</span>&#125;<br>&#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">90</span>, <span class="hljs-string">&#x27;物理&#x27;</span>: <span class="hljs-number">94</span>, <span class="hljs-string">&#x27;化学&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br>&#123;<span class="hljs-string">&#x27;数学&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;语文&#x27;</span>: <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;英语&#x27;</span>: <span class="hljs-number">90</span>, <span class="hljs-string">&#x27;物理&#x27;</span>: <span class="hljs-number">94</span>, <span class="hljs-string">&#x27;化学&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br></code></pre></td></tr></table></figure>
<p>我们发现由于前两次调用setdefault()时传入的键都是在字典中不存在的，因此会在字典中加入这个新的键值对，值就是defaultvalue可以自定义或者默认为None，但是如果穿入的键存在，那么后面的defaultvalue将没有任何作用，直接返还字典key对应的value值。</p>
<h3 id="python使用字典格式化字符串"><a class="markdownIt-Anchor" href="#python使用字典格式化字符串"></a> Python使用字典格式化字符串</h3>
<p>之前我们学习过使用转换说明符来格式化输出字符串，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name=<span class="hljs-string">&quot;小明&quot;</span><br>age = <span class="hljs-number">8</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s已经%d岁了！&quot;</span> % (name,age))<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">小明已经<span class="hljs-number">8</span>岁了！<br></code></pre></td></tr></table></figure>
<p>但是这是变量比较少的情况，如果变量非常多，那么此时我们再使用这种形式格式化字符串就变得异常麻烦，因此我们接下来学习使用字典来格式化字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"> 字符串模板中使用key<br>temp = <span class="hljs-string">&#x27;教程是:%(name)s, 价格是:%(price)010.2f, 出版社是:%(publish)s&#x27;</span><br>book = &#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;Python基础教程&#x27;</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">99</span>, <span class="hljs-string">&#x27;publish&#x27;</span>: <span class="hljs-string">&#x27;C语言中文网&#x27;</span>&#125;<br><span class="hljs-comment"># 使用字典为字符串模板中的key传入值</span><br><span class="hljs-built_in">print</span>(temp % book)<br>book = &#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;C语言小白变怪兽&#x27;</span>, <span class="hljs-string">&#x27;price&#x27;</span>:<span class="hljs-number">159</span>, <span class="hljs-string">&#x27;publish&#x27;</span>: <span class="hljs-string">&#x27;C语言中文网&#x27;</span>&#125;<br><span class="hljs-comment"># 使用字典为字符串模板中的key传入值</span><br><span class="hljs-built_in">print</span>(temp % book)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">教程是:Python基础教程, 价格是:<span class="hljs-number">0000099.00</span>, 出版社是:C语言中文网<br>教程是:C语言小白变怪兽, 价格是:<span class="hljs-number">0000159.00</span>, 出版社是:C语言中文网<br></code></pre></td></tr></table></figure>
<div class="tag-plugin note" color="yellow"><div class="body"><p>要注意对应的键是写在百分号<code>%</code>和转换符字母之间的，比如%(price)010.2f表示的是此处输出的字典中price键对应的值价钱应为一个小数，并且最小宽度为10（不足就前面补0），同时保留两位小数。</p></div></div>
<h3 id="python-set集合详解"><a class="markdownIt-Anchor" href="#python-set集合详解"></a> Python set集合详解</h3>
<p>Python中的集合，与数学中的和概念一致，用来保存不重复的元素，即集合中的元素都是唯一的，互不相同。从形式上看，和字典类似，Python集合会将所有元素放在一对大括号<code>&#123;&#125;</code>中，相邻元素使用逗号<code>,</code>分开</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;element1,element2,...,elementn&#125;<br></code></pre></td></tr></table></figure>
<p>集合可以存储无限多个元素。**从内容上看，集合只能存储不可变的数据类型，包括整型、浮点型、字符型、元组。但是无法存储列表、字典、集合这些可变的数据类型，否则Python解释器就会抛出TypeError错误。**比如说：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>&#123;&#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>&#125;&#125;<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;pyshell#8&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    &#123;&#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>&#125;&#125;<br>TypeError: unhashable <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;dict&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>&#123;[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]&#125;<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;pyshell#9&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    &#123;[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]&#125;<br>TypeError: unhashable <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;list&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;&#125;<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;pyshell#10&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;&#125;<br>TypeError: unhashable <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;set&#x27;</span><br></code></pre></td></tr></table></figure>
<p>要注意集合中的元素是唯一的，<strong>对于重复出现的数据元素，只会保留一份</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)&#125;<br></code></pre></td></tr></table></figure>
<p>由于Python中的set集合是无序的，因此每一次输出元素的排列顺序都是不同的。</p>
<div class="tag-plugin note" color="yellow"><div class="body"><p>其实Python中有两种集合类型，一种是set类型的集合，另一种是frozenset类型的集合，他们的唯一区别就是set类型集合可以做添加、删除元素的操作，而frozenset类型集合不行。</p></div></div>
<h4 id="python创建set集合"><a class="markdownIt-Anchor" href="#python创建set集合"></a> Python创建set集合</h4>
<p>Python提供了2种创建set集合的方法，分别是使用{}创建和使用set()函数将列表、元组等类型数据转换为集合。</p>
<h5 id="1使用创建集合"><a class="markdownIt-Anchor" href="#1使用创建集合"></a> 1）使用{}创建集合</h5>
<p>在Python中，创建set集合可以像列表、元素和字典一样，直接将集合赋值给变量，从而实现创建集合的目的，其语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">setname = &#123;element1,element2,...,elementn&#125;<br></code></pre></td></tr></table></figure>
<p>其中，setname 表示集合的名称，起名时既要符合 Python 命名规范，也要避免与 Python 内置函数重名。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = &#123;<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">1</span>,(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-string">&#x27;c&#x27;</span>&#125;<br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;c&#x27;</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)&#125;<br></code></pre></td></tr></table></figure>
<h5 id="2set函数创建集合"><a class="markdownIt-Anchor" href="#2set函数创建集合"></a> 2）set()函数创建集合</h5>
<p>set()函数为Python的内置函数，其功能是将字符串、列表、元组、range()对象等可迭代对象转换成集合，该函数的语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">setname = <span class="hljs-built_in">set</span>(iteration)<br></code></pre></td></tr></table></figure>
<p>其中，iteration 就表示字符串、列表、元组、range 对象等数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">set1 = <span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;c.biancheng.net&quot;</span>)<br>set2 = <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br>set3 = <span class="hljs-built_in">set</span>((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;set1:&quot;</span>,set1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;set2:&quot;</span>,set2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;set3:&quot;</span>,set3)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">set1: &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>&#125;<br>set2: &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>set3: &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>注意如果要创建空集合，只能使用set()函数实现，因为直接使用一对{}，Python解释器会将其视为一个空字典。</strong></p>
<h4 id="python访问set集合元素"><a class="markdownIt-Anchor" href="#python访问set集合元素"></a> Python访问set集合元素</h4>
<p>由于集合中的元素是无序的，因此无法像列表那样使用下表索引来访问元素，Python中，访问集合元素最常用的方法就是使用循环结构，将集合的数据逐一读取出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = &#123;<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">1</span>,(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-string">&#x27;c&#x27;</span>&#125;<br><span class="hljs-keyword">for</span> ele <span class="hljs-keyword">in</span> a:<br>    <span class="hljs-built_in">print</span>(ele,end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span> c (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>
<h4 id="python删除set集合"><a class="markdownIt-Anchor" href="#python删除set集合"></a> Python删除set集合</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = &#123;<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">1</span>,(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-string">&#x27;c&#x27;</span>&#125;<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-keyword">del</span>(a)<br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;c&#x27;</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)&#125;<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;C:\Users\mengma\Desktop\1.py&quot;</span>, line <span class="hljs-number">4</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    <span class="hljs-built_in">print</span>(a)<br>NameError: name <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined<br></code></pre></td></tr></table></figure>
<h3 id="python-set集合基础操作"><a class="markdownIt-Anchor" href="#python-set集合基础操作"></a> Python set集合基础操作</h3>
<h4 id="向set集合中添加元素"><a class="markdownIt-Anchor" href="#向set集合中添加元素"></a> 向set集合中添加元素</h4>
<p>我们要注意，使用add()方法向set集合添加元素时，只能是数字，字符串，元组或者布尔类型，不能添加列表、元组或者集合这些可变的数据，否则Python解释器会报TypeError错误。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>a.add((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(a)<br>a.add([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;C:\Users\mengma\Desktop\1.py&quot;</span>, line <span class="hljs-number">4</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    a.add([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br>TypeError: unhashable <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;list&#x27;</span><br></code></pre></td></tr></table></figure>
<h4 id="从set集合中删除元素"><a class="markdownIt-Anchor" href="#从set集合中删除元素"></a> 从set集合中删除元素</h4>
<p>使用remove()可以删除集合中的元素，但是我们要注意如果被删除的元素不包含在集合中，那么这个方法会抛出KeyError错误，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>a.remove(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(a)<br>a.remove(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;C:\Users\mengma\Desktop\1.py&quot;</span>, line <span class="hljs-number">4</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    a.remove(<span class="hljs-number">1</span>)<br>KeyError: <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>如果使用此方法删除集合中元素，需要注意的是，如果被删除的元素就不包含在集合中，那么此方法就会抛出KeyError异常，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>a.remove(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(a)<br>a.remove(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;C:\Users\mengma\Desktop\1.py&quot;</span>, line <span class="hljs-number">4</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    a.remove(<span class="hljs-number">1</span>)<br>KeyError: <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>为了避免这种报错，我们可以哈斯用discard()方法，此方法和remove()方法的用法完全相同，唯一的区别就是当删除集合中元素失败时，此方法不会抛出任何错误。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>a.remove(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(a)<br>a.discard(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="python-set集合做交集-并集-差集运算"><a class="markdownIt-Anchor" href="#python-set集合做交集-并集-差集运算"></a> Python set集合做交集、并集、差集运算</h4>
<p>集合最常用的操作就是交集、并集、差集以及对称差集运算，如下所示：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20220117203958.png" alt="" /></p>
<p>我们可以使用如下代码实现不同的集合运算：</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算操作</th>
<th style="text-align:center">Python运算符</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">交集</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">取两集合公共的元素</td>
<td style="text-align:center">&gt;&gt;&gt; set1 &amp; set2 {3}</td>
</tr>
<tr>
<td style="text-align:center">并集</td>
<td style="text-align:center">丨</td>
<td style="text-align:center">取两集合全部的元素</td>
<td style="text-align:center">&gt;&gt;&gt; set1 丨 set2 {1,2,3,4,5}</td>
</tr>
<tr>
<td style="text-align:center">差集</td>
<td style="text-align:center">-</td>
<td style="text-align:center">取一个集合中另一集合没有的元素</td>
<td style="text-align:center">&gt;&gt;&gt; set1 - set2 {1,2}<br /> &gt;&gt;&gt; set2 - set1 {4,5}</td>
</tr>
<tr>
<td style="text-align:center">对称差集</td>
<td style="text-align:center">^</td>
<td style="text-align:center">取集合 A 和 B 中不属于 A&amp;B 的元素</td>
<td style="text-align:center">&gt;&gt;&gt; set1 ^ set2 {1,2,4,5}</td>
</tr>
</tbody>
</table>
<h4 id="python-set集合方法大全"><a class="markdownIt-Anchor" href="#python-set集合方法大全"></a> Python set集合方法大全</h4>
<p>这里我们给出C语言编程网的Python中集合函数大全方便查阅：</p>
<div class="tag-plugin link dis-select"><a class="link-card plain" title="set集合操作大全" href="http://c.biancheng.net/view/4402.html" target="_blank" rel="external nofollow noopener noreferrer" cardlink autofill="icon"><div class="left"><span class="title">set集合操作大全</span><span class="cap link fs12">http://c.biancheng.net/view/4402.html</span></div><div class="right"><div class="lazy img" data-bg="https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/link/8f277b4ee0ecd.svg"></div></div></a></div>
<h3 id="python-frozenset"><a class="markdownIt-Anchor" href="#python-frozenset"></a> Python frozenset</h3>
<p>set是一个可变序列，程序可以改变序列中的元素，而frozenset集合是不可变序列，程序是不能改变不可变序列中的元素的。set结合所支持的add()、remove()、discard()等方法frozenset一概不支持，而set中不改变集合本身的方法frozenset也支持。</p>
<p>我们在以下两种场景下会使用到frozenset，也正是这两个场景确立了frozenset的不可替代性：</p>
<ul>
<li>当集合的元素不需要改变时，我们可以使用 fronzenset 替代 set，这样更加安全。</li>
<li>有时候程序要求必须是不可变对象，这个时候也要使用 fronzenset 替代 set。比如，字典（dict）的键（key）就要求是不可变对象。</li>
</ul>
<div class="tag-plugin note" color="yellow"><div class="body"><p>一定要注意字典的键是不允许发生改变的，因此他不支持list,set这些可变序列数据类型的。</p></div></div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">s = &#123;<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>&#125;<br>fs = <span class="hljs-built_in">frozenset</span>([<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Shell&#x27;</span>])<br>s_sub = &#123;<span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-string">&#x27;C#&#x27;</span>&#125;<br><span class="hljs-comment">#向set集合中添加frozenset</span><br>s.add(fs)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;s =&#x27;</span>, s)<br><span class="hljs-comment">#向为set集合添加子set集合</span><br>s.add(s_sub)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;s =&#x27;</span>, s)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">s = &#123;<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-built_in">frozenset</span>(&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Shell&#x27;</span>&#125;), <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>&#125;<br>Traceback (most recent call last):<br>    File <span class="hljs-string">&quot;C:\Users\mozhiyan\Desktop\demo.py&quot;</span>, line <span class="hljs-number">11</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>        s.add(s_sub)<br>TypeError: unhashable <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;set&#x27;</span><br></code></pre></td></tr></table></figure>
<p>要注意，<strong>set集合本身的元素要求是不可变的</strong>，因此set的元素是不能为set的，即set集合不支持嵌套的，但是我们可以向set中加入frozenset的，因为他是不可变的集合类型。</p>
<h3 id="深入底层了解python字典和集合"><a class="markdownIt-Anchor" href="#深入底层了解python字典和集合"></a> 深入底层了解Python字典和集合</h3>
<p>在Python中字典和集合是进行过性能高度优化的数据结构，特别是对于查找、添加和删除操作。我们首先拿列表介绍一下复杂度：</p>
<p>假设现在有一个存储产品信息（产品ID、名称和价格）的列表，现在的需求是，借助某件产品的ID找出其价格，则实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_product_price</span>(<span class="hljs-params">products, product_id</span>):<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">id</span>, price <span class="hljs-keyword">in</span> products:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span> == product_id:<br>            <span class="hljs-keyword">return</span> price<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>products = [<br>    (<span class="hljs-number">111</span>, <span class="hljs-number">100</span>),<br>    (<span class="hljs-number">222</span>, <span class="hljs-number">30</span>),<br>    (<span class="hljs-number">333</span>, <span class="hljs-number">150</span>)<br>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The price of product 222 is &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(find_product_price(products, <span class="hljs-number">222</span>)))<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">The price of product <span class="hljs-number">222</span> <span class="hljs-keyword">is</span> <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure>
<p>如上查找列表时，如果列表有n个元素，因为查找的过程需要遍历列表，那么最坏的情况时间复杂度是O(n)。即使对列表进行了排序，再使用二分查找算法，也需要<code>O(logn)</code>的时间复杂度，更何况列表的排序还需要<code>O(nlogn)</code>的时间。</p>
<p>当如果用字典来存储这些数据，那么查找就会非常便捷高效，只需要O(1)的时间复杂度就可以完成，因为可以通过<strong>键的哈希值</strong>，找到对应的值，而不需要对字典做遍历操作，实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">products = &#123;<br>  <span class="hljs-number">111</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-number">222</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-number">333</span>: <span class="hljs-number">150</span><br>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The price of product 222 is &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(products[<span class="hljs-number">222</span>]))<br></code></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">The price of product <span class="hljs-number">222</span> <span class="hljs-keyword">is</span> <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure>
<p>如下是一个简单的列表查找和字典查找的速度对比，我们可以看到仅仅十万的数据量，两者的速度差异就如此之大：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#统计时间需要用到 time 模块中的函数，了解即可</span><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_unique_price_using_list</span>(<span class="hljs-params">products</span>):<br>    unique_price_list = []<br>    <span class="hljs-keyword">for</span> _, price <span class="hljs-keyword">in</span> products: <span class="hljs-comment"># A</span><br>        <span class="hljs-keyword">if</span> price <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> unique_price_list: <span class="hljs-comment">#B</span><br>            unique_price_list.append(price)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(unique_price_list)<br><span class="hljs-built_in">id</span> = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100000</span>)]<br>price = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">200000</span>, <span class="hljs-number">300000</span>)]<br>products = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(<span class="hljs-built_in">id</span>, price))<br><span class="hljs-comment"># 计算列表版本的时间</span><br>start_using_list = time.perf_counter()<br>find_unique_price_using_list(products)<br>end_using_list = time.perf_counter()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;time elapse using list: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(end_using_list - start_using_list))<br><span class="hljs-comment">#使用集合完成同样的工作</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_unique_price_using_set</span>(<span class="hljs-params">products</span>):<br>    unique_price_set = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> _, price <span class="hljs-keyword">in</span> products:<br>        unique_price_set.add(price)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(unique_price_set)<br><span class="hljs-comment"># 计算集合版本的时间</span><br>start_using_set = time.perf_counter()<br>find_unique_price_using_set(products)<br>end_using_set = time.perf_counter()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;time elapse using set: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(end_using_set - start_using_set))<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">time elapse using <span class="hljs-built_in">list</span>: <span class="hljs-number">68.78650900000001</span><br>time elapse using <span class="hljs-built_in">set</span>: <span class="hljs-number">0.010747099999989018</span><br></code></pre></td></tr></table></figure>
<p>而往往企业的后台数据都有上亿乃至十亿数量级，因此如果使用了不合适的数据结构，很容易造成服务器的崩溃。因此字典和集合O(1)的复杂度可谓是相当快速了，加下来我们就了解一下他们的底层实现原理。</p>
<h4 id="字典和集合的工作原理"><a class="markdownIt-Anchor" href="#字典和集合的工作原理"></a> 字典和集合的工作原理</h4>
<p>字典和集合能如此高效，和他们的数据结构密不可分，不同于其他数据结构，字典和集合内部结构都是一张哈希表：</p>
<ul>
<li>对于字典而言，这张表存储了哈希值（hash）、键和值这 3 个元素。</li>
<li>而对集合来说，哈希表内只存储单一的元素。</li>
</ul>
<p>对于之前版本的Python，他的哈希结构如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"> | 哈希值 (<span class="hljs-built_in">hash</span>)  键 (key)  值 (value)<br>. |           ...<br><span class="hljs-number">0</span> |    hash0      key0    value0<br>. |           ...<br><span class="hljs-number">1</span> |    hash1      key1    value1<br>. |           ...<br><span class="hljs-number">2</span> |    hash2      key2    value2<br>. |           ...<br></code></pre></td></tr></table></figure>
<p>但是我们发现这种结构的弊端，是随着哈希表的扩张，他会变得越来越稀疏，比如有这样一个字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;mike&#x27;</span>, <span class="hljs-string">&#x27;dob&#x27;</span>: <span class="hljs-string">&#x27;1999-01-01&#x27;</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<p>那么他会存储为如下结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">entries = [<br>[<span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>]<br>[-<span class="hljs-number">230273521</span>, <span class="hljs-string">&#x27;dob&#x27;</span>, <span class="hljs-string">&#x27;1999-01-01&#x27;</span>],<br>[<span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>],<br>[<span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>],<br>[<span class="hljs-number">1231236123</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;mike&#x27;</span>],<br>[<span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>],<br>[<span class="hljs-number">9371539127</span>, <span class="hljs-string">&#x27;gender&#x27;</span>, <span class="hljs-string">&#x27;male&#x27;</span>]<br>]<br></code></pre></td></tr></table></figure>
<p>三个键值对数据却需要哈希表开辟7个空间，显然非常浪费存储空间，为了提高存储空间的利用率，现在的哈希表除了字典本身的结构，会把索引和哈希值、键、值单独分开，也就是采用如下这种结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">Indices<br>----------------------------------------------------<br><span class="hljs-literal">None</span> | index | <span class="hljs-literal">None</span> | <span class="hljs-literal">None</span> | index | <span class="hljs-literal">None</span> | index ...<br>----------------------------------------------------<br><br>Entries<br>--------------------<br>hash0   key0  value0<br>---------------------<br>hash1   key1  value1<br>---------------------<br>hash2   key2  value2<br>---------------------<br>        ...<br>---------------------<br><br></code></pre></td></tr></table></figure>
<p>这和数据结构中的索引表建立类似，此时哈希表内键哈希值不同的键值对存储到了相邻的存储单元，而我们使用indices来表示哈希表内的关系，这样就节省了大量的空间。因此此时上面的字典在新哈希表结构下的存储形式为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">indices = [<span class="hljs-literal">None</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">2</span>]<br>entries = [<br>[<span class="hljs-number">1231236123</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;mike&#x27;</span>],<br>[-<span class="hljs-number">230273521</span>, <span class="hljs-string">&#x27;dob&#x27;</span>, <span class="hljs-string">&#x27;1999-01-01&#x27;</span>],<br>[<span class="hljs-number">9371539127</span>, <span class="hljs-string">&#x27;gender&#x27;</span>, <span class="hljs-string">&#x27;male&#x27;</span>]<br>]<br></code></pre></td></tr></table></figure>
<h5 id="哈希表插入数据"><a class="markdownIt-Anchor" href="#哈希表插入数据"></a> 哈希表插入数据</h5>
<p>当我们向字典中插入数据时，Python会首先<strong>根据键(key)计算</strong>出对应的哈希值（通过hash(key)函数计算)，而向集合中插入数据时，Python会<strong>根据元素本身计算</strong>对应的哈希值（通过hash(values)函数计算)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-number">1</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hash</span>(<span class="hljs-string">&quot;name&quot;</span>))<br>setDemo = &#123;<span class="hljs-number">1</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hash</span>(<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">8230115042008314683</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>得到哈希值（例如hash)之后，再结合字典或集合要存储数据的个数（例如n),就可以得到该元素应该插入到哈希表中的位置（比如,可以用hash%n的方式)</p>
<p>如果哈希表中此位置是空的，那么此元素可以直接插入其中，反之如果此位置已经被其他元素占用，那么Python会比较这两个元素的哈希值和键是否相等：</p>
<ul>
<li>如果相等，则表明该元素已经存在，再比较他们的值，不相等就进行更新；</li>
<li>如果不相等，这种情况称为哈希冲突（即两个元素的键不同，但求得的哈希值相同）。这种情况下，Python 会使用开放定址法、再哈希法等继续寻找哈希表中空余的位置，直到找到位置。</li>
</ul>
<h5 id="哈希表查找数据"><a class="markdownIt-Anchor" href="#哈希表查找数据"></a> 哈希表查找数据</h5>
<p>在哈希表中查找数据，和插入操作类似，Python 会根据哈希值，找到该元素应该存储到哈希表中的位置，然后和该位置的元素比较其哈希值和键（集合直接比较元素值）：</p>
<ul>
<li>如果相等，则证明找到；</li>
<li>反之，则证明当初存储该元素时，遇到了哈希冲突，需要继续使用当初解决哈希冲突的方法进行查找，直到找到该元素或者找到空位为止。</li>
</ul>
<div class="tag-plugin note" color="yellow"><div class="body"><p>这里的空位，表示哈希表没有存储目标元素</p></div></div>
<h5 id="哈希表删除元素"><a class="markdownIt-Anchor" href="#哈希表删除元素"></a> 哈希表删除元素</h5>
<p>对于删除操作，<strong>Python会暂时对这个位置的元素赋予一个特殊的值，等到重新调整哈希表的大小时，再将其删除。</strong></p>
<p>需要注意的是，哈希冲突的发生往往会降低字典和集合操作的速度。因此，为了保证其高效性，字典和集合内的哈希表，通常会保证其至少留有 1/3 的剩余空间。随着元素的不停插入，当剩余空间小于 1/3 时，Python 会重新获取更大的内存空间，扩充哈希表，与此同时，表内所有的元素位置都会被重新排放。</p>
<p>虽然哈希冲突和哈希表大小的调整，都会导致速度减缓，但是这种情况发生的次数极少。所以，平均情况下，仍能保证插入、查找和删除的时间复杂度为 <code>O(1)</code>。</p>
<h3 id="python深拷贝和浅拷贝详解"><a class="markdownIt-Anchor" href="#python深拷贝和浅拷贝详解"></a> Python深拷贝和浅拷贝详解</h3>
<h4 id="python浅拷贝"><a class="markdownIt-Anchor" href="#python浅拷贝"></a> Python浅拷贝</h4>
<p>常见的浅拷贝方法，是使用数据类型本身的构造器，比如下面两个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>list2 = <span class="hljs-built_in">list</span>(list1)<br><span class="hljs-built_in">print</span>(list2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;list1==list2 ?&quot;</span>,list1==list2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;list1 is list2 ?&quot;</span>,list1 <span class="hljs-keyword">is</span> list2)<br>set1= <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>set2 = <span class="hljs-built_in">set</span>(set1)<br><span class="hljs-built_in">print</span>(set2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;set1==set2 ?&quot;</span>,set1==set2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;set1 is set2 ?&quot;</span>,set1 <span class="hljs-keyword">is</span> set2)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>list1==list2 ? <span class="hljs-literal">True</span><br>list1 <span class="hljs-keyword">is</span> list2 ? <span class="hljs-literal">False</span><br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>set1==set2 ? <span class="hljs-literal">True</span><br>set1 <span class="hljs-keyword">is</span> set2 ? <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<p>在上面程序中，list2就是list1的浅拷贝，同理set2是set1的浅拷贝。当然，对于<strong>可变的序列</strong>，还可以通过切片操作符<code>:</code>来完成浅拷贝，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>list2 = list1[:]<br><span class="hljs-built_in">print</span>(list2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;list1 == list2 ?&quot;</span>,list1 == list2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;list1 is list2 ?&quot;</span>,list1 <span class="hljs-keyword">is</span> list2)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>list1 == list2 ? <span class="hljs-literal">True</span><br>list1 <span class="hljs-keyword">is</span> list2 ? <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<p>除此之外，Python 还提供了对应的函数 copy.copy() 函数，适用于任何数据类型。其用法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>list2 = copy.copy(list1)<br><span class="hljs-built_in">print</span>(list2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;list1 == list2 ?&quot;</span>,list1 == list2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;list1 is list2 ?&quot;</span>,list1 <span class="hljs-keyword">is</span> list2)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>list1 == list2 ? <span class="hljs-literal">True</span><br>list1 <span class="hljs-keyword">is</span> list2 ? <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<p>不过要注意的是，对于元组，使用tuple()或者切片操作符<code>:</code>不会创建一个浅拷贝，相反他会创建一个指向相同元组的引用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">tuple1 = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>tuple2 = <span class="hljs-built_in">tuple</span>(tuple1)<br><span class="hljs-built_in">print</span>(tuple2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;tuple1 == tuple2 ?&quot;</span>,tuple1 == tuple2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;tuple1 is tuple2 ?&quot;</span>,tuple1 <span class="hljs-keyword">is</span> tuple2)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>tuple1 == tuple2 ? <span class="hljs-literal">True</span><br>tuple1 <span class="hljs-keyword">is</span> tuple2 ? <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<p>此程序中，元组 (1, 2, 3) 只被创建一次，t1 和 t2 同时指向这个元组。</p>
<h5 id="思考什么时候构造器和切片返还的是引用什么时候是新数据"><a class="markdownIt-Anchor" href="#思考什么时候构造器和切片返还的是引用什么时候是新数据"></a> 思考：什么时候构造器和切片返还的是引用？什么时候是新数据？</h5>
<div class="tag-plugin note" color="yellow"><div class="body"><p>这里有一个规律，就是凡是<strong>可变数据类型</strong>，那么构造器或者切片返还的就是一个新的<strong>浅拷贝数据</strong>；凡是<strong>不可变数据类型</strong>，那么构造器或者切片返还的就是一个指<strong>向原内存单元的引用</strong></p></div></div>
<p>以下是验证，我们发现对于string还是frozenset最终返还的都是引用，而dict就是一个新的拷贝数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>s1=<span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s2=s1[:]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(s2 <span class="hljs-keyword">is</span> s1)<br><span class="hljs-literal">True</span><br><span class="hljs-comment"># frozenset不能切片，因此使用构造器</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>fs1=<span class="hljs-built_in">frozenset</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>fs2=<span class="hljs-built_in">frozenset</span>(fs1)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(fs2 <span class="hljs-keyword">is</span> fs1)<br><span class="hljs-literal">True</span><br><span class="hljs-comment"># 字典不能切片，因此也使用构造器</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>d1=&#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;langwenchong&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">20</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>d2=<span class="hljs-built_in">dict</span>(d1)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(d2 <span class="hljs-keyword">is</span> d1)<br></code></pre></td></tr></table></figure>
<h5 id="思考那么怎样才能让到d2和d1指向同一地址呢"><a class="markdownIt-Anchor" href="#思考那么怎样才能让到d2和d1指向同一地址呢"></a> 思考：那么怎样才能让到d2和d1指向同一地址呢？</h5>
<p>很简单使用赋值即可，毕竟d1本身就是一个指向内存单元的指针：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>d2=d1<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(d2 <span class="hljs-keyword">is</span> d1)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<p>看到这里，也许你可能对浅拷贝有了初步的认识。浅拷贝，指的是重新分配一块内存，创建一个新的对象，但里面的元素是原对象中各个子对象的引用。</p>
<p>对数据采用浅拷贝的方式时，如果原对象中的元素不可变，那倒无所谓；但如果元素可变，浅拷贝通常会出现一些问题，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], (<span class="hljs-number">30</span>, <span class="hljs-number">40</span>)]<br>list2 = <span class="hljs-built_in">list</span>(list1)<br>list1.append(<span class="hljs-number">100</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;list1:&quot;</span>,list1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;list2:&quot;</span>,list2)<br>list1[<span class="hljs-number">0</span>].append(<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;list1:&quot;</span>,list1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;list2:&quot;</span>,list2)<br>list1[<span class="hljs-number">1</span>] += (<span class="hljs-number">50</span>, <span class="hljs-number">60</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;list1:&quot;</span>,list1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;list2:&quot;</span>,list2)<br></code></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">list1: [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], (<span class="hljs-number">30</span>, <span class="hljs-number">40</span>), <span class="hljs-number">100</span>]<br>list2: [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], (<span class="hljs-number">30</span>, <span class="hljs-number">40</span>)]<br>list1: [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], (<span class="hljs-number">30</span>, <span class="hljs-number">40</span>), <span class="hljs-number">100</span>]<br>list2: [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], (<span class="hljs-number">30</span>, <span class="hljs-number">40</span>)]<br>list1: [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], (<span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>), <span class="hljs-number">100</span>]<br>list2: [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], (<span class="hljs-number">30</span>, <span class="hljs-number">40</span>)]<br></code></pre></td></tr></table></figure>
<p>再来看，list1[0].append(3) 表示对 list1 中的第一个列表新增元素 3。因为 list2 是 list1 的浅拷贝，list2 中的第一个元素和 list1 中的第一个元素，共同指向同一个列表，因此 list2 中的第一个列表也会相对应的新增元素 3。</p>
<p>最后是 list1[1] += (50, 60)，因为元组是不可变的，这里表示对 list1 中的第二个元组拼接，然后重新创建了一个新元组作为 list1 中的第二个元素，而 list2 中没有引用新元组，因此 list2 并不受影响。</p>
<p>通过这个例子，你可以很清楚地看到使用浅拷贝可能带来的副作用。如果想避免这种副作用，完整地拷贝一个对象，就需要使用深拷贝。所谓深拷贝，是指重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中。因此，新对象和原对象没有任何关联。</p>
<h4 id="python深拷贝"><a class="markdownIt-Anchor" href="#python深拷贝"></a> Python深拷贝</h4>
<p>Python 中以 copy.deepcopy() 来实现对象的深度拷贝。比如上述例子写成下面的形式，就是深度拷贝：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>list1 = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], (<span class="hljs-number">30</span>, <span class="hljs-number">40</span>)]<br>list2 = copy.deepcopy(list1)<br>list1.append(<span class="hljs-number">100</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;list1:&quot;</span>,list1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;list2:&quot;</span>,list2)<br>list1[<span class="hljs-number">0</span>].append(<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;list1:&quot;</span>,list1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;list2:&quot;</span>,list2)<br>list1[<span class="hljs-number">1</span>] += (<span class="hljs-number">50</span>, <span class="hljs-number">60</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;list1:&quot;</span>,list1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;list2:&quot;</span>,list2)<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pytohn">list1: [[1, 2], (30, 40), 100]<br>list2: [[1, 2], (30, 40)]<br>list1: [[1, 2, 3], (30, 40), 100]<br>list2: [[1, 2], (30, 40)]<br>list1: [[1, 2, 3], (30, 40, 50, 60), 100]<br>list2: [[1, 2], (30, 40)]<br></code></pre></td></tr></table></figure>
<p>不过，深度拷贝也不是完美的，往往也会带来一系列问题。如果被拷贝对象中存在指向自身的引用，那么程序很容易陷入无限循环，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>list1 = [<span class="hljs-number">1</span>]<br>list1.append(list1)<br><span class="hljs-built_in">print</span>(list1)<br>list2 = copy.deepcopy(list1)<br><span class="hljs-built_in">print</span>(list2)<br></code></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-number">1</span>, [...]]<br>[<span class="hljs-number">1</span>, [...]]<br></code></pre></td></tr></table></figure>
<p>此例子中，列表 x 中有指向自身的引用，因此 x 是一个无限嵌套的列表。但是当深度拷贝 x 到 y 后，程序并没有出现栈溢出的现象。这是为什么呢？</p>
<p>其实，这是因为深度拷贝函数 deepcopy 中会维护一个字典，记录已经拷贝的对象与其 ID。拷贝过程中，如果字典里已经存储了将要拷贝的对象，则会从字典直接返回。通过查看 deepcopy 函数实现的源码就会明白：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">deepcopy</span>(<span class="hljs-params">x, memo=<span class="hljs-literal">None</span>, _nil=[]</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Deep copy operation on arbitrary Python objects.</span><br><span class="hljs-string">       </span><br><span class="hljs-string">    See the module&#x27;s __doc__ string for more info.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>   <br>    <span class="hljs-keyword">if</span> memo <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        memo = &#123;&#125;<br>    d = <span class="hljs-built_in">id</span>(x) <span class="hljs-comment"># 查询被拷贝对象 x 的 id</span><br>    y = memo.get(d, _nil) <span class="hljs-comment"># 查询字典里是否已经存储了该对象</span><br>    <span class="hljs-keyword">if</span> y <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> _nil:<br>        <span class="hljs-keyword">return</span> y <span class="hljs-comment"># 如果字典里已经存储了将要拷贝的对象，则直接返回</span><br>        ...<br></code></pre></td></tr></table></figure>

  


  </article>
  
<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">回顾上一篇</div><a href="/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%97%E8%A1%A8/index.html">列表</a></div><div class="item" id="next"><div class="note">接下来阅读</div><a href="/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/index.html">字符串</a></div></section></div>

  

  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      快来参与讨论吧
    </section>
    <section class='body cmt-body waline'>
      

<div id="waline_container" class="waline_thread" comment_id="Python"><svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg></div>

    </section>
  </div>




      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客</span><a href="/">随想录</a><a href="/intro">言堂序</a><a href="/archives">归档册</a></div><div class="sitemap-group"><span class="fs14">笔记</span><a href="/wiki/tags/%E7%AC%AC%E4%B9%9D%E8%89%BA%E6%9C%AF">第九艺术</a><a href="/wiki/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80">计算基础</a><a href="/wiki/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80">语言基础</a><a href="/wiki/tags/%E8%BF%9B%E9%98%B6%E6%8A%80%E8%83%BD">进阶技能</a></div><div class="sitemap-group"><span class="fs14">便笺</span><a href="/notes/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0">科研学习</a><a href="/notes/%E5%BB%BA%E7%AB%99%E5%BF%85%E5%A4%87">建站必备</a><a href="/notes/%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7">建站必备</a></div><div class="sitemap-group"><span class="fs14">更多</span><a target="_blank" rel="noopener" href="https://coolchong.cn">个人主页</a><a target="_blank" rel="noopener" href="https://blog.coolchong.cn/friends.html">友情链接</a></div></div><div class="text"><div class="github-badge">
  <a style="color: #fff"  href="https://coolchong.cn/" target="_blank" title="由 Langwenchong 搭建运营">
    <span class="badge-subject">Built</span><span class="badge-value bg-blue">雨中 @2022-2023</span>
  </a>
  <a style="color: #fff" href="https://www.qiniu.com//" target="_blank" title="静态资源托管于 七牛云" >
    <span class="badge-subject">Powered</span><span class="badge-value bg-orange">七牛云</span>
  </a>
  <a style="color: #fff" href="https://xaoxuu.com/wiki/stellar/" target="_blank" title="站点使用 Stellar 主题" >
    <span class="badge-subject">Theme</span><span class="badge-value bg-brightgreen">Stellar</span>
  </a>
  <a style="color: #fff" href="https://beian.miit.gov.cn/)" target="_blank" title="网站已备案授权开放">
    <span class="badge-subject">Record</span><span class="badge-value bg-red">津ICP备2021009044</span>
  </a>
</div>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.18.5';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://fastly.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://fastly.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://fastly.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function load_comment(){
    if(!document.getElementById("waline_container"))return;
    stellar.loadCSS('https://unpkg.com/@waline/client@2.14.1/dist/waline.css');
    stellar.loadScript('https://unpkg.com/@waline/client@2.14.1/dist/waline.js', {defer:true}).then(function () {
      const el = document.getElementById("waline_container");
      var path = el.getAttribute('comment_id');
      if (!path) {
        path = decodeURI(window.location.pathname);
      }
      Waline.init(Object.assign({"js":"https://unpkg.com/@waline/client@2.14.1/dist/waline.js","css":"https://unpkg.com/@waline/client@2.14.1/dist/waline.css","serverURL":"https://waline.coolchong.cn","commentCount":true,"pageview":false,"emoji":["https://fastly.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/","https://unpkg.com/@waline/emojis@1.1.0/tw-emoji","https://unpkg.com/@waline/emojis@1.1.0/bilibili","https://unpkg.com/@waline/emojis@1.1.0/alus","https://unpkg.com/@waline/emojis@1.1.0/bmoji"],"locale":{"reactionTitle":null,"placeholder":"任何想法畅所欲言，记得填写邮箱方便及时收到回复哦~"},"reaction":["https://fastly.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatheart.png","https://fastly.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatattentionreverse.png","https://fastly.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatrainbow.png","https://fastly.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatwave.png","https://fastly.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/blobcatalt.png","https://fastly.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/blobcatscared.png"]}, {
        el: '#waline_container',
        path: path,
      }));
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
    console.log('DOM fully loaded and parsed');
    load_comment();
  });

</script>




<!-- inject -->


  </div>
</body>
</html>
