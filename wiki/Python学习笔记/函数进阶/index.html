<!DOCTYPE html>
<html lang='zh-CN'>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?fc63ac4843a697431e3d43c4d48b99de";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>Python：函数进阶 - 雨中•学圃堂</title>

  
    <meta name="description" content="Python partial偏函数 简单的理解偏函数，他是对原始函数的二次封装，是将现有函数的部分参数预先绑定为指定值，从而得到一个新的函数，这个函数就成为偏函数。相比原函数，偏函数具有较少的可变参数，从而降低了函数调用的难度。 偏函数的定义需要使用关键字partial（位于模块functools中）。他的语法格式如下： 1偏函数名 &#x3D; partial(func, *args, **kwargs">
<meta property="og:type" content="website">
<meta property="og:title" content="函数进阶">
<meta property="og:url" content="https://scholar.coolchong.cn/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="雨中•学圃堂">
<meta property="og:description" content="Python partial偏函数 简单的理解偏函数，他是对原始函数的二次封装，是将现有函数的部分参数预先绑定为指定值，从而得到一个新的函数，这个函数就成为偏函数。相比原函数，偏函数具有较少的可变参数，从而降低了函数调用的难度。 偏函数的定义需要使用关键字partial（位于模块functools中）。他的语法格式如下： 1偏函数名 &#x3D; partial(func, *args, **kwargs">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-01-27T13:14:31.866Z">
<meta property="article:modified_time" content="2023-01-27T13:14:31.866Z">
<meta property="article:author" content="Wenchong Lang">
<meta name="twitter:card" content="summary">
  
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="雨中•学圃堂" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="https://cdn.coolchong.cn/%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/langwenchong.png">
  

  

  
    <link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
    <script defer src="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js" ></script>
    <script defer src="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
  


  
    
      <link href="https://fonts.font.im/css?family=Dancing+Script" rel="stylesheet">
    
      <link href="https://fastly.jsdelivr.net/gh/volantis-x/cdn-fontawesome-pro@master/css/all.min.css" rel="stylesheet">
    
  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='wiki'>
    

  




<div class="widgets"><widget class="widget-wrapper logo-wrap wiki"><div class="widget-body"><a style="filter: grayscale(100%)" class="wiki-home cap" href="/wiki"><svg aria-hidden="true" viewBox="0 0 16 16" width="1rem" height="1rem" fill="currentColor"><path fill-rule="evenodd" d="M7.78 12.53a.75.75 0 01-1.06 0L2.47 8.28a.75.75 0 010-1.06l4.25-4.25a.75.75 0 011.06 1.06L4.81 7h7.44a.75.75 0 010 1.5H4.81l2.97 2.97a.75.75 0 010 1.06z"></path></svg>所有笔记</a><a class="title" href="/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/index.html"><div class="main" ff="title">Python</div><div class="sub cap">python是世界上最好的语言</div></a></div></widget>
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/wiki/Python学习笔记/" placeholder="想找点什么？"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">好像并未找到什么！</div></div></div></widget>




<widget class="widget-wrapper toc multi" id="data-toc"><div class="widget-header cap dis-select"><span class="name">语法基础</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/index.html#start"><span class="toc-text">变量类型和运算符</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%97%E8%A1%A8/index.html"><span class="toc-text">列表</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%83%E7%BB%84%E3%80%81%E5%AD%97%E5%85%B8%E4%B8%8E%E9%9B%86%E5%90%88/index.html"><span class="toc-text">元组、字典与集合</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/index.html"><span class="toc-text">字符串</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/index.html"><span class="toc-text">流程控制</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/index.html"><span class="toc-text">函数基础</span></a></div><div class="doc-tree active"><a class="doc-tree-link active" href="/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/index.html"><span class="toc-text">函数进阶</span></a><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#python-partial%E5%81%8F%E5%87%BD%E6%95%B0"><span class="toc-text"> Python partial偏函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92"><span class="toc-text"> Python函数递归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92"><span class="toc-text"> 函数递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%AE%9E%E4%BE%8B"><span class="toc-text"> 递归实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text"> Python变量作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text"> Python局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text"> Python全局变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%9C%A8%E5%87%BD%E6%95%B0%E4%BD%93%E5%A4%96%E9%83%A8%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-text"> 一、在函数体外部定义的变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E5%9C%A8%E5%87%BD%E6%95%B0%E4%BD%93%E5%86%85%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text"> 二、 在函数体内定义全局变量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%8C%83%E5%9B%B4%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-text"> 获取指定作用域范围中的变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1globals%E5%87%BD%E6%95%B0"><span class="toc-text"> 1）globals()函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2locals%E5%87%BD%E6%95%B0"><span class="toc-text"> 2）locals()函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3varsobject"><span class="toc-text"> 3）vars(object)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E5%9C%A8%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8%E5%90%8C%E5%90%8D%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text"> Python在函数内部使用同名的全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E5%B1%80%E9%83%A8%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3"><span class="toc-text"> Python局部函数详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text"> Python函数高级使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0"><span class="toc-text"> Python闭包函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E9%97%AD%E5%8C%85%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF"><span class="toc-text"> 思考：闭包还有什么优势？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E9%97%AD%E5%8C%85%E7%9A%84__closure__%E5%B1%9E%E6%80%A7"><span class="toc-text"> Python闭包的__closure__属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text"> Python lambda表达式(匿名函数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python-eval%E5%92%8Cexec%E5%87%BD%E6%95%B0"><span class="toc-text"> Python eval()和exec()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#eval%E5%92%8Cexec%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text"> eval()和exec()的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exec%E5%92%8Ceval%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text"> exec()和eval()的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eval%E5%92%8Cexec%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text"> eval()和exec()函数的应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-text"> Python函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#python-map%E5%87%BD%E6%95%B0"><span class="toc-text"> Python map()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python-filter%E5%87%BD%E6%95%B0"><span class="toc-text"> Python filter()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python-reduce%E5%87%BD%E6%95%B0"><span class="toc-text"> Python reduce()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text"> 总结</span></a></li></ol></li></ol></div></div></widget>




</div>


    </aside>
    <div class='l_main'>
      

      <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?fc63ac4843a697431e3d43c4d48b99de";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
</script>



  
  
<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" id="home" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" id="menu" href="/wiki/">笔记</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/index.html">Python</a></div><div id="post-meta">更新于&nbsp;<time datetime="2023-01-27T13:14:31.866Z">2023-01-27</time></div></div>

  <article class='md-text content wiki reveal'>
  <h1 class="article-title"><span>函数进阶</span></h1>
  <h3 id="python-partial偏函数"><a class="markdownIt-Anchor" href="#python-partial偏函数"></a> Python partial偏函数</h3>
<p>简单的理解偏函数，他是对原始函数的二次封装，是将现有函数的部分参数预先绑定为指定值，从而得到一个新的函数，这个函数就成为偏函数。相比原函数，偏函数具有较少的可变参数，从而降低了函数调用的难度。</p>
<p>偏函数的定义需要使用关键字<code>partial</code>（位于模块functools中）。他的语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">偏函数名 = partial(func, *args, **kwargs)</span><br></pre></td></tr></table></figure>
<p>我们在学习了函数的各种接收方法以后，很容易就可以理解后两个参数的意思。*args用来接收所有的位置参数，而**kwargs用来接收所有的关键字参数，如下是一个偏函数的应用例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="comment">#定义个原函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">name,age</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;name:&quot;</span>,name,<span class="string">&quot;age:&quot;</span>,age)</span><br><span class="line"><span class="comment">#定义偏函数，其封装了 display() 函数，并为 name 参数设置了默认参数</span></span><br><span class="line">GaryFun = partial(display,name = <span class="string">&#x27;Gary&#x27;</span>)</span><br><span class="line"><span class="comment">#由于 name 参数已经有默</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: Gary age: <span class="number">13</span></span><br></pre></td></tr></table></figure>
<p><strong>我们要注意，对于第8行代码，必须采用关键字参数的形式给age形参传值，因为如果以无关键字参数的方式，该实参将试图传递给name形参，Python编辑器会报TypeError错误。</strong></p>
<div class="tag-plugin note" color="yellow"><div class="body"><p>为了方便正确设置默认值，一般情况下我们最好在对偏函数定义设置默认值时使用关键字参数形式，然后调用再使用位置参数的形式。</p></div></div>
<p>当然如果你对参数的传递非常熟悉，那么可以使用位置参数传递，如下是一个使用位置参数为偏函数设置参数默认值的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mod</span>(<span class="params"> n, m </span>):</span><br><span class="line">  <span class="keyword">return</span> n % m</span><br><span class="line"><span class="comment">#定义偏函数，并设置参数 n 对应的实参值为 100</span></span><br><span class="line">mod_by_100 = partial( mod, <span class="number">100</span> )</span><br><span class="line"><span class="built_in">print</span>(mod( <span class="number">100</span>, <span class="number">7</span> ))</span><br><span class="line"><span class="built_in">print</span>(mod_by_100( <span class="number">7</span> ))</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>注意此时mod_by_100相当于只需要再接收一个m参数了，n并不需要在接收了</strong>，因此此时如果像下面这样调用会出错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(mod_by_100( <span class="number">100</span>,<span class="number">7</span> ))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;d:/Pythoncode/Algrithm/test.py&quot;</span>, line <span class="number">8</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(mod_by_100( <span class="number">100</span>,<span class="number">7</span> ))</span><br><span class="line">TypeError: mod() takes <span class="number">2</span> positional arguments but <span class="number">3</span> were given</span><br></pre></td></tr></table></figure>
<div class="tag-plugin note" color="yellow"><div class="title">因此我们可以理解为此时mod_by_100是一个新函数，他只需要接收一个参数，然后就会计算出100%</div><div class="body"><p>n的值，只不过他的具体实现是基于mod实现的。因此它实现了函数的参数截取。</p></div></div>
<p>结合上面的例子，我们不难看出实际上偏函数的运行本质上还是调用了原始函数，只不过是对，原始函数进行了封装，将原函数的一些不需要改变的形参设置了默认值，然后对外部用户只暴露剩下的参数。这种通过将任意数量（顺序）的参数，转化为另一个带有剩余参数的函数对象，从而实现了截取函数功能（偏向）的效果。在实际应用中，可以使用一个原函数，然后将其封装多个偏函数，在调用函数时全部调用偏函数，一定程度上可以提高程序的可读性。</p>
<h3 id="python函数递归"><a class="markdownIt-Anchor" href="#python函数递归"></a> Python函数递归</h3>
<h4 id="函数递归"><a class="markdownIt-Anchor" href="#函数递归"></a> 函数递归</h4>
<p>函数递归就是一个函数不断的调用自身的过程，他往往需要一个终止条件以便能够跳出递归继续向下执行代码。但是有时候我们会由于代码逻辑的缺陷问题，导致函数递归缺失终止条件，那么此时程序并不会真的一直向下递归调用执行，而是在递归调用997次以后停止并报错RecursionError。这是因为在Python中，默认的最大递归次数是997次。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">count=<span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    count+=<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">    func()</span><br><span class="line">func()</span><br><span class="line"><span class="comment">#最大打印出997，最后报错</span></span><br></pre></td></tr></table></figure>
<p>如果我们需要修改默认的最大递归次数，方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(修改后的值)</span><br></pre></td></tr></table></figure>
<h4 id="递归实例"><a class="markdownIt-Anchor" href="#递归实例"></a> 递归实例</h4>
<p>我们以二分法查找列表l中数字num的索引熟悉一下函数的递归</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">l, num, start=<span class="literal">None</span>, end=<span class="literal">None</span></span>):</span><br><span class="line">    start = start <span class="keyword">if</span> start <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    end = end <span class="keyword">if</span> end <span class="keyword">else</span> <span class="built_in">len</span>(l)-<span class="number">1</span></span><br><span class="line">    mid = (end-start)//<span class="number">2</span>+start</span><br><span class="line">    <span class="keyword">if</span> l[mid] &gt; num:</span><br><span class="line">        <span class="keyword">return</span> search(l, num, start, mid-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">elif</span> l[mid] &lt; num:</span><br><span class="line">        <span class="keyword">return</span> search(l, num, mid+<span class="number">1</span>, end)</span><br><span class="line">    <span class="keyword">elif</span> l[mid] == num:</span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认要寻找的数存在，否则会报错</span></span><br><span class="line">l = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">26</span>, <span class="number">30</span>, <span class="number">32</span>, <span class="number">35</span>, <span class="number">41</span>,</span><br><span class="line">     <span class="number">42</span>, <span class="number">43</span>, <span class="number">55</span>, <span class="number">56</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">69</span>, <span class="number">72</span>, <span class="number">76</span>, <span class="number">82</span>, <span class="number">83</span>, <span class="number">88</span>]</span><br><span class="line"><span class="built_in">print</span>(search(l, <span class="number">67</span>))</span><br></pre></td></tr></table></figure>
<div class="tag-plugin note" color="yellow"><div class="body"><p>我们只需要记住，递归需要一个终止条件同时还要注意最大递归次数即可。</p></div></div>
<h3 id="python变量作用域"><a class="markdownIt-Anchor" href="#python变量作用域"></a> Python变量作用域</h3>
<h4 id="python局部变量"><a class="markdownIt-Anchor" href="#python局部变量"></a> Python局部变量</h4>
<p>在函数内部定义的变量，他的作用域也仅限于函数内部，出了函数就不能使用了，我们将这样的变量称为<code>局部变量</code>。</p>
<p>当函数被执行时，Python会为其分配一块临时的存储空间，所有在函数内部定义的变量，都会存储在这块空间中。而在函数执行完毕后，这块临时存储空间随即会被释放并回收，该空间中存储的变量自然也就无法再被使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>():</span><br><span class="line">    add = <span class="string">&quot;hello&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数内部 add =&quot;</span>,add)</span><br><span class="line">demo()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数外部 add =&quot;</span>,add)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数内部 add = hello</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;C:\Users\mengma\Desktop\file.py&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数外部 add =&quot;</span>,add)</span><br><span class="line">NameError: name <span class="string">&#x27;add&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>
<p>我们可以看到，如果试图在函数外部访问其内部定义的变量，那么Python解释器会报NameError错误，并且提示我们没有定义要访问的变量，这也证实了当函数执行完毕后，其内部定义的变量会被销毁并回收。</p>
<p>我们还要注意，函数接收的参数也属于局部变量，只能在函数内部使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">name,add</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数内部 name =&quot;</span>,name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数内部 add =&quot;</span>,add)</span><br><span class="line">demo(<span class="string">&quot;Python教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数外部 name =&quot;</span>,name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数外部 add =&quot;</span>,add)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数内部 name = Python教程</span><br><span class="line">函数内部 add = http://c.biancheng.net/python/</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;C:\Users\mengma\Desktop\file.py&quot;</span>, line <span class="number">7</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数外部 name =&quot;</span>,name)</span><br><span class="line">NameError: name <span class="string">&#x27;name&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>
<p>我们可以看到name变量和add变量形参只能在函数内部使用，外部也是无法使用的。因为函数执行完成以后会立即销毁存储这些函数相关变量的存储空间。</p>
<h4 id="python全局变量"><a class="markdownIt-Anchor" href="#python全局变量"></a> Python全局变量</h4>
<p>除了在函数内部定义变量，Python还允许我们在所有函数的我外部定义变量，这样的变量我们成为<code>全局变量</code>。和局部变量不同，全局变量的默认作用域是整个程序，即全局变量既可以在各个函数的外部使用，也可以在各函数内部使用。</p>
<p>定义全局变量的方式有以下两种：</p>
<h5 id="一-在函数体外部定义的变量"><a class="markdownIt-Anchor" href="#一-在函数体外部定义的变量"></a> 一、在函数体外部定义的变量</h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="string">&quot;http://coolchong.cn&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">text</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数体内访问：&quot;</span>,add)</span><br><span class="line">text()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;函数体外访问：&#x27;</span>,add)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数体内访问： http://coolchong.cn</span><br><span class="line">函数体外访问： http://coolchong.cn</span><br></pre></td></tr></table></figure>
<h5 id="二-在函数体内定义全局变量"><a class="markdownIt-Anchor" href="#二-在函数体内定义全局变量"></a> 二、 在函数体内定义全局变量</h5>
<p>我们可以使用<code>global</code>关键字对变量进行修饰，这样这个变量就变成了全局变量，即使此时他是在函数内部定义的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ef text():</span><br><span class="line">    <span class="keyword">global</span> add</span><br><span class="line">    add= <span class="string">&quot;http://coolchong.cn/&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数体内访问：&quot;</span>,add)</span><br><span class="line">text()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;函数体外访问：&#x27;</span>,add)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数体内访问： http://coolchong.cn/</span><br><span class="line">函数体外访问： http://coolchong.cn/</span><br></pre></td></tr></table></figure>
<div class="tag-plugin note" color="yellow"><div class="body"><p>我们要注意使用global关键字修饰变量时，不能直接给变量赋初值，否则会引发语法错误。</p></div></div>
<h4 id="获取指定作用域范围中的变量"><a class="markdownIt-Anchor" href="#获取指定作用域范围中的变量"></a> 获取指定作用域范围中的变量</h4>
<p>在一些特定场景中，我们可能需要某个作用域内（全局范围内或者局部范围内）所有的变量，Python中提供了一下3种方式：</p>
<h5 id="1globals函数"><a class="markdownIt-Anchor" href="#1globals函数"></a> 1）globals()函数</h5>
<p>globals()函数为Python的内置函数，他可以返还一个包含全局范围内所有的变量的字典，该字典中的每个键值对，键为变量名，值为该变量的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全局变量</span></span><br><span class="line">Pyname = <span class="string">&quot;Python教程&quot;</span></span><br><span class="line">Pyadd = <span class="string">&quot;http://c.biancheng.net/python/&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">text</span>():</span><br><span class="line">    <span class="comment">#局部变量</span></span><br><span class="line">    Shename = <span class="string">&quot;shell教程&quot;</span></span><br><span class="line">    Sheadd= <span class="string">&quot;http://c.biancheng.net/shell/&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; ...... , <span class="string">&#x27;Pyname&#x27;</span>: <span class="string">&#x27;Python教程&#x27;</span>, <span class="string">&#x27;Pyadd&#x27;</span>: <span class="string">&#x27;http://c.biancheng.net/python/&#x27;</span>, ......&#125;</span><br></pre></td></tr></table></figure>
<div class="tag-plugin note" color="yellow"><div class="body"><p>注意globals()函数返还的字典中，不仅仅包含我们定义的全局变量，还有许多默认包含的变量，他们是Python主程序内置的，我们可以不用理会。</p></div></div>
<p>可以看到，通过调用globals()函数我们可以得到一个包含所有全局变量的字典，并且通过字典，我们可以访问指定的全局变量，如果需要，我们还可以修改它的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&#x27;Pyname&#x27;</span>])</span><br><span class="line"><span class="built_in">globals</span>()[<span class="string">&#x27;Pyname&#x27;</span>] = <span class="string">&quot;Python入门教程&quot;</span></span><br><span class="line"><span class="built_in">print</span>(Pyname)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Python教程</span><br><span class="line">Python入门教程</span><br></pre></td></tr></table></figure>
<h5 id="2locals函数"><a class="markdownIt-Anchor" href="#2locals函数"></a> 2）locals()函数</h5>
<p>locals()函数也是Python内置函数之一，通过调用这个函数，我们可以得到一个包含当前作用域内所有变量的字典。当在函数内部调用locals()函数，会得到包含所有局部变量的字典，而在全局范围内调用locals()函数，其功能就和globals()函数功能完全相同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全局变量</span></span><br><span class="line">Pyname = <span class="string">&quot;Python教程&quot;</span></span><br><span class="line">Pyadd = <span class="string">&quot;http://c.biancheng.net/python/&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">text</span>():</span><br><span class="line">    <span class="comment">#局部变量</span></span><br><span class="line">    Shename = <span class="string">&quot;shell教程&quot;</span></span><br><span class="line">    Sheadd= <span class="string">&quot;http://c.biancheng.net/shell/&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数内部的 locals:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())</span><br><span class="line">text()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数外部的 locals:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">locals</span>())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数内部的 <span class="built_in">locals</span>:</span><br><span class="line">&#123;<span class="string">&#x27;Sheadd&#x27;</span>: <span class="string">&#x27;http://c.biancheng.net/shell/&#x27;</span>, <span class="string">&#x27;Shename&#x27;</span>: <span class="string">&#x27;shell教程&#x27;</span>&#125;</span><br><span class="line">函数外部的 <span class="built_in">locals</span>:</span><br><span class="line">&#123;...... , <span class="string">&#x27;Pyname&#x27;</span>: <span class="string">&#x27;Python教程&#x27;</span>, <span class="string">&#x27;Pyadd&#x27;</span>: <span class="string">&#x27;http://c.biancheng.net/python/&#x27;</span>, ...... &#125;</span><br></pre></td></tr></table></figure>
<p><strong>但是我们要注意，当使用locals()函数获得所有局部变量组成的字典时，可以像globals()函数那样，通过指定键访问对应的变量值，但是我们无法对变量值进行修改</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全局变量</span></span><br><span class="line">Pyname = <span class="string">&quot;Python教程&quot;</span></span><br><span class="line">Pyadd = <span class="string">&quot;http://c.biancheng.net/python/&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">text</span>():</span><br><span class="line">    <span class="comment">#局部变量</span></span><br><span class="line">    Shename = <span class="string">&quot;shell教程&quot;</span></span><br><span class="line">    Sheadd= <span class="string">&quot;http://c.biancheng.net/shell/&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>()[<span class="string">&#x27;Shename&#x27;</span>])</span><br><span class="line">    <span class="built_in">locals</span>()[<span class="string">&#x27;Shename&#x27;</span>] = <span class="string">&quot;shell入门教程&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(Shename)</span><br><span class="line">text()</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell教程</span><br><span class="line">shell教程</span><br></pre></td></tr></table></figure>
<h5 id="3varsobject"><a class="markdownIt-Anchor" href="#3varsobject"></a> 3）vars(object)</h5>
<p>vars()函数也是Python内置函数之一，其功能是返回一个指定object对象范围内所有变量组成的字典，如果不传入object参数，vars()和globals()的作用完全相同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#全局变量</span></span><br><span class="line">Pyname = <span class="string">&quot;Python教程&quot;</span></span><br><span class="line">Pyadd = <span class="string">&quot;http://c.biancheng.net/python/&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>:</span><br><span class="line">    name = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">    add = <span class="string">&quot;http://c.biancheng.net/python/&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;有 object：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">vars</span>(Demo))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;无 object：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">vars</span>())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">有 <span class="built_in">object</span>：</span><br><span class="line">&#123;...... , <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Python 教程&#x27;</span>, <span class="string">&#x27;add&#x27;</span>: <span class="string">&#x27;http://c.biancheng.net/python/&#x27;</span>, ......&#125;</span><br><span class="line">无 <span class="built_in">object</span>：</span><br><span class="line">&#123;...... , <span class="string">&#x27;Pyname&#x27;</span>: <span class="string">&#x27;Python教程&#x27;</span>, <span class="string">&#x27;Pyadd&#x27;</span>: <span class="string">&#x27;http://c.biancheng.net/python/&#x27;</span>, ...... &#125;</span><br></pre></td></tr></table></figure>
<h3 id="python在函数内部使用同名的全局变量"><a class="markdownIt-Anchor" href="#python在函数内部使用同名的全局变量"></a> Python在函数内部使用同名的全局变量</h3>
<p>首先我们要明确，函数可以直接不接收参数就直接使用全局变量如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;Charlie&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span> ():</span><br><span class="line">    <span class="comment"># 直接访问name全局变量</span></span><br><span class="line">    <span class="built_in">print</span>(name) <span class="comment"># Charlie</span></span><br><span class="line">test()</span><br><span class="line"><span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Charlie</span><br><span class="line">Charlie</span><br></pre></td></tr></table></figure>
<p>此时写法是正确的，相当于test()函数直接打印了全局变量name，同时在函数外部主程序内又打印了一遍全局变量name，因此两个输出结果均为Charlie。</p>
<p>同时当函数内部出现了同名的局部变量，那么局部变量会覆盖之前的全局变量的值，即函数默认将同名变量视为局部变量进行使用，因此如下所示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;Charlie&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span> ():</span><br><span class="line">    name=<span class="string">&quot;wenchong&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(name) <span class="comment"># wenchong</span></span><br><span class="line">test()</span><br><span class="line"><span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wenchong</span><br><span class="line">Charlie</span><br></pre></td></tr></table></figure>
<p>此时test()函数内部声明了一个name局部变量并且将值设置为了wenchong，因此此时输出结果如下所示，即在test()函数内部局部变量name覆盖掉了全局变量name。但是我们假如将<code>name=&quot;wenchong&quot;</code>放到<code>print(name)</code>下方会怎样？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;Charlie&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span> ():</span><br><span class="line">    <span class="built_in">print</span>(name) </span><br><span class="line">    name=<span class="string">&quot;wenchong&quot;</span></span><br><span class="line">test()</span><br><span class="line"><span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnboundLocalError : local variable ‘name’ referenced before assignment</span><br></pre></td></tr></table></figure>
<p>我们发现此时报错了！原因是此时test()会将namne视为局部变量，那么很显然<code>print(name)</code>代码打印的是局部变量的值，但是此时局部变量name还未进行赋值，因此报错了。</p>
<p>实际上此时上面的代码本意是打印全局变量name的值，然后再声明一个全局变量name并且赋值为字符串wenchong,那么此时怎么实现呢？很显然我们并不能直接在函数内部将name声明为<code>global</code>全局变量类型，因为这样会导致函数执行结束以后全局变量name也发生了改变导致输出的结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Charlie</span><br><span class="line">wenchong</span><br></pre></td></tr></table></figure>
<p>但是实际上我们希望输出的结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Charlie</span><br><span class="line">Charlie</span><br></pre></td></tr></table></figure>
<p>即在test()函数内部定义了局部变量name赋值为wenchong，同时两次打印使用的都是全局变量name，那么此时我们就会用到之前我们学习的<code>globals()</code>函数了，代码改为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;Charlie&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span> ():</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&#x27;name&#x27;</span>]) <span class="comment"># Charlie</span></span><br><span class="line">    <span class="comment">#也可以写为 print(globals.getr(&#x27;name&#x27;))</span></span><br><span class="line">    name=<span class="string">&quot;wenchong&quot;</span></span><br><span class="line">test()</span><br><span class="line"><span class="built_in">print</span>(name) <span class="comment">#Charlie</span></span><br></pre></td></tr></table></figure>
<p>为了验证此时函数内部的name确实为局部变量，我们可以使用如下代码测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;Charlie&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span> ():</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">globals</span>().get(<span class="string">&#x27;name&#x27;</span>)) <span class="comment"># wenchong</span></span><br><span class="line">    name=<span class="string">&quot;wenchong&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">test()</span><br><span class="line"><span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Charlie</span><br><span class="line">wenchong</span><br><span class="line">Charlie</span><br></pre></td></tr></table></figure>
<h3 id="python局部函数详解"><a class="markdownIt-Anchor" href="#python局部函数详解"></a> Python局部函数详解</h3>
<p>通过前面的学习我们已经知道Python支持局部变量了，那么Python是否支持局部函数呢？即Python函数内部可以在定义函数吗？答案是可以得。Python支持在函数内部定义函数，此类函数就被成为局部函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全局函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outdef</span> ():</span><br><span class="line">    <span class="comment">#局部函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">indef</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="comment">#调用局部函数</span></span><br><span class="line">    indef()</span><br><span class="line"><span class="comment">#调用全局函数</span></span><br><span class="line">outdef()</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>和全局函数返回其局部变量从而扩大这个变量的作用域一样，通过将局部函数函数作为函数的返回值，也可以扩大局部函数的使用范围，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全局函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outdef</span> ():</span><br><span class="line">    <span class="comment">#局部函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">indef</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用局部函数&quot;</span>)</span><br><span class="line">    <span class="comment">#调用局部函数</span></span><br><span class="line">    <span class="keyword">return</span> indef</span><br><span class="line"><span class="comment">#调用全局函数</span></span><br><span class="line">new_indef = outdef()</span><br><span class="line">调用全局函数中的局部函数</span><br><span class="line">new_indef()</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用局部函数</span><br></pre></td></tr></table></figure>
<p>此时这个局部函数作用域就扩大了，他可以脱离父函数作用而在全局内使用。因此我们可以总结出以下规律：</p>
<ol>
<li>如果所在函数并没有返还局部函数，那么这个局部函数的可用范围仅限于所在函数内部</li>
<li>反之，如果所在函数将局部函数作为返回值，那么局部函数的作用域就会扩大，既可以在函数内部使用，也可以在所在函数的作用域中使用。</li>
</ol>
<p>同时我们要注意一个问题，<strong>局部函数内部是一个新的作用域，因此如果局部函数中定义了和所在函数中变量同名的变量，也会发生遮蔽问题。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全局函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outdef</span> ():</span><br><span class="line">    name = <span class="string">&quot;所在函数中定义的 name 变量&quot;</span></span><br><span class="line">    <span class="comment">#局部函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">indef</span>():</span><br><span class="line">        <span class="built_in">print</span>(name)</span><br><span class="line">        name = <span class="string">&quot;局部函数中定义的 name 变量&quot;</span></span><br><span class="line">    indef()</span><br><span class="line"><span class="comment">#调用全局函数</span></span><br><span class="line">outdef()</span><br></pre></td></tr></table></figure>
<p>此时indef()函数内是一个新的作用域，并且此时在内部又定义了一个新的局部变量name，因此此时很明显会报错，Python解释器会报如下错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnboundLocalError: local variable <span class="string">&#x27;name&#x27;</span> referenced before assignment</span><br></pre></td></tr></table></figure>
<p>那么为了解决这个问题，我们应该怎么样修改代码呢？ 很明显此时无论是使用<code>global</code>关键字还是内置函数<code>globals()</code>、<code>locals()</code>都无法解决错误。此时我们需要使用Python提供的关键字<code>nonlocal</code>，顾名思义不是局部变量，那么此时他就会取消遮蔽效果获取到局部函数所在父函数作用域的变量<code>name</code>的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全局函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outdef</span> ():</span><br><span class="line">    name = <span class="string">&quot;所在函数中定义的 name 变量&quot;</span></span><br><span class="line">    <span class="comment">#局部函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">indef</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> name</span><br><span class="line">        <span class="built_in">print</span>(name)</span><br><span class="line">        <span class="comment">#修改name变量的值</span></span><br><span class="line">        name = <span class="string">&quot;局部函数中定义的 name 变量&quot;</span></span><br><span class="line">    indef()</span><br><span class="line"><span class="comment">#调用全局函数</span></span><br><span class="line">outdef()</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所在函数中定义的 name 变量</span><br></pre></td></tr></table></figure>
<h3 id="python函数高级使用方法"><a class="markdownIt-Anchor" href="#python函数高级使用方法"></a> Python函数高级使用方法</h3>
<p>前面我们已经学习函数的基础用法，接下来我们再学习一些高级用法。首先Python允许直接将函数赋值给变量，这样做的效果是，程序也可以用其他变量来调用函数，更加灵活。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_def</span> ():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在执行 my_def 函数&quot;</span>)</span><br><span class="line"><span class="comment">#将函数赋值给其他变量   </span></span><br><span class="line">other = my_def</span><br><span class="line"><span class="comment">#间接调用 my_def() 函数</span></span><br><span class="line">other()</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正在执行 my_def 函数</span><br></pre></td></tr></table></figure>
<p>不仅如此，Python还支持将函数以参数的形式传入其他函数，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span> (a,b):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multi</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a*b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_def</span>(<span class="params">a,b,dis</span>):</span><br><span class="line">    <span class="keyword">return</span> dis(a,b)</span><br><span class="line">   </span><br><span class="line"><span class="comment">#求 2 个数的和</span></span><br><span class="line"><span class="built_in">print</span>(my_def(<span class="number">3</span>,<span class="number">4</span>,add))</span><br><span class="line"><span class="comment">#求 2 个数的乘积</span></span><br><span class="line"><span class="built_in">print</span>(my_def(<span class="number">3</span>,<span class="number">4</span>,multi))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到上面的代码中my_def接收的第三个参数是一个函数，然后将前两个接收的参数传给第三个函数参数去执行，因此函数可以作为参数传递。</p>
<h3 id="python闭包函数"><a class="markdownIt-Anchor" href="#python闭包函数"></a> Python闭包函数</h3>
<p>闭包，又称为闭包函数或闭合函数，其实和前面我们学习的嵌套函数类似，不同之处在于，闭包中外部函数返回的不是一个具体的值，而是一个函数。一般情况下， 返回的函数会赋值给一个变量，这个变量可以在后面被继续执行调用。</p>
<p>例如，现在我们要实现一个计算数的n次幂的函数，那么用闭包可以如下实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#闭包函数，其中 exponent 称为自由变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nth_power</span>(<span class="params">exponent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exponent_of</span>(<span class="params">base</span>):</span><br><span class="line">        <span class="keyword">return</span> base ** exponent</span><br><span class="line">    <span class="keyword">return</span> exponent_of <span class="comment"># 返回值是 exponent_of 函数</span></span><br><span class="line">square = nth_power(<span class="number">2</span>) <span class="comment"># 计算一个数的平方</span></span><br><span class="line">cube = nth_power(<span class="number">3</span>) <span class="comment"># 计算一个数的立方</span></span><br><span class="line"><span class="built_in">print</span>(square(<span class="number">2</span>))  <span class="comment"># 计算 2 的平方</span></span><br><span class="line"><span class="built_in">print</span>(cube(<span class="number">2</span>)) <span class="comment"># 计算 2 的立方</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>在上面的程序中，外部函数nth_power()的返回值是函数exponent__of()，而不是一个具体的数值。这个返还的exponent_of函数还需要接收一个base变量，nth_power()只是将exponent_of内部的exponent变量进行了赋值。</p>
<p><strong>因此，在执行完<code>square=nth_power(2)</code>和<code>cube=nth_power(3)</code>后，外部函数nth_power()的参数exponent会和内部函数exponent_of一起赋值给square和cube，这样在之后调用square(2）和cube(2)时，程序就能顺利的输出结果，而不会报错exponent变量没有定义</strong></p>
<p>但是你可能会疑惑我们为什么非要使用闭包来实现上面的功能呢？完全可以下面这种简单的形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nth_power_rewrite</span>(<span class="params">base, exponent</span>):</span><br><span class="line">    <span class="keyword">return</span> base ** exponent</span><br></pre></td></tr></table></figure>
<p>上面的程序确实也可以实现相同的功能，不过使用闭包，可以让程序变得更加简洁易读。设想一下，比如我们现在需要计算很多个数的平方，那么闭包函数的写法明显更好：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不使用闭包</span></span><br><span class="line">res1 = nth_power_rewrite(base1, <span class="number">2</span>)</span><br><span class="line">res2 = nth_power_rewrite(base2, <span class="number">2</span>)</span><br><span class="line">res3 = nth_power_rewrite(base3, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 使用闭包</span></span><br><span class="line">square = nth_power(<span class="number">2</span>)</span><br><span class="line">res1 = square(base1)</span><br><span class="line">res2 = square(base2)</span><br><span class="line">res3 = square(base3)</span><br></pre></td></tr></table></figure>
<p>采用闭包的第二个形式，表达更为简单，每次调用函数时，我们都可以少输入一个参数。</p>
<h4 id="思考闭包还有什么优势"><a class="markdownIt-Anchor" href="#思考闭包还有什么优势"></a> 思考：闭包还有什么优势？</h4>
<p>如果仅仅是减少输入参数，貌似闭包优点大材小用了，毕竟闭包很难构思，难道优势仅仅是降低操作的难度吗？当然不是，闭包的优点和缩减嵌套函数的优点类似，我们知道每一个函数开头都需要做一些额外工作，那么当多次调用该函数时，每次都需要重复初始化工作，但是如果我们将这些额外工作统一放置到外部函数中，用闭包返还内部函数，就可以减少多次调用导致的不必要的开销，提高程序的运行效率。</p>
<h4 id="python闭包的__closure__属性"><a class="markdownIt-Anchor" href="#python闭包的__closure__属性"></a> Python闭包的__closure__属性</h4>
<p>闭包函数比普通的函数多了一个__closure__属性，这个属性记录着自由变量的地址。当闭包被调用时，系统就会根据该地址找到对应的自由变量，完成整体的函数调用。</p>
<p>以nth_power()为例，当其被调用时，可以通过__closure__属性获取自由变量（也就是程序中的exponent参数）存储的地址，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nth_power</span>(<span class="params">exponent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exponent_of</span>(<span class="params">base</span>):</span><br><span class="line">        <span class="keyword">return</span> base ** exponent</span><br><span class="line">    <span class="keyword">return</span> exponent_of</span><br><span class="line">square = nth_power(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#查看 __closure__ 的值</span></span><br><span class="line"><span class="built_in">print</span>(square.__closure__)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;cell at <span class="number">0x0000014454DFA948</span>: <span class="built_in">int</span> <span class="built_in">object</span> at <span class="number">0x00000000513CC6D0</span>&gt;,)</span><br></pre></td></tr></table></figure>
<p>可以看到，显示的内容是一个int整数类型，这就是square中自由变量exponent的初始值，还可以看到，__closure__属性的类型是一个元组，这表明闭包可以支持多个自由变量的形式。</p>
<h3 id="python-lambda表达式匿名函数"><a class="markdownIt-Anchor" href="#python-lambda表达式匿名函数"></a> Python lambda表达式(匿名函数）</h3>
<p>对于一个简单的函数，Python还提供了另外一种方法，即lambda表达式。lambda表达式，又称为匿名函数，常用来表示内部仅包含一行表达式的函数。如果一个函数的函数体仅有一行表达式，那么这个函数就可以使用lambda表达式来代替。</p>
<p>lambda表达式的语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="keyword">lambda</span> [<span class="built_in">list</span>] : 表达式</span><br></pre></td></tr></table></figure>
<p>其中，定义lambda表达式时，必须使用lambda关键字，[list]作为可选参数，等同于定义函数时指定的参数列表或者元组用来接收参数，name为表达式的名称。</p>
<p>如果将lambda表达式转换为普通函数的形式就如下方所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">name</span>(<span class="params"><span class="built_in">list</span></span>):</span><br><span class="line">    <span class="keyword">return</span> 表达式</span><br><span class="line">name(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<p>接下来我们尝试使用一个lambda表达式解决求两个数之和的问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="keyword">lambda</span> x,y:x+y</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>使用lambda表达式的优势有：</p>
<ol>
<li>对于单行函数，使用lambda表达式可以省去定义函数的过程，让代码更加简洁</li>
<li>对于不需要多次复用的函数，使用lambda表达式可以在用完之后立即释放，提高程序执行的性能</li>
</ol>
<h3 id="python-eval和exec函数"><a class="markdownIt-Anchor" href="#python-eval和exec函数"></a> Python eval()和exec()函数</h3>
<p>eval()和exec()函数都属于Python内置函数，两个函数的功能是类似的，都可以执行一个字符串形式的Python代码（代码以字符串的形式提供），相当于一个Python的解释器。而这不同之处在于，eval()执行完要返回结果，而exec()执行完不返回结果。</p>
<h4 id="eval和exec的用法"><a class="markdownIt-Anchor" href="#eval和exec的用法"></a> eval()和exec()的用法</h4>
<p>eval()函数的语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(source, <span class="built_in">globals</span>=<span class="literal">None</span>, <span class="built_in">locals</span>=<span class="literal">None</span>, /)</span><br></pre></td></tr></table></figure>
<p>而exec()函数的语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span>(source, <span class="built_in">globals</span>=<span class="literal">None</span>, <span class="built_in">locals</span>=<span class="literal">None</span>, /)</span><br></pre></td></tr></table></figure>
<p>两者除了函数名不同，其他都相同，各个参数的具体含义为：</p>
<ul>
<li>expression：这个参数是一个字符串，代表要执行的语句。该语句受后面两个字典类型参数globals和locals的限制，只有在globals字典和locals字典作用域内的变量和函数才能被执行。</li>
<li>globals：这个参数管控的是一个全局的命名空间，即expression可以使用全局命名空间中的函数。如果只是提供了globals参数，而没有提供自定义的 __builtins__，则系统会将当前环境中的__builtins__复制到自己提供的globals中，然后才会进行计算。如果连globals这个参数都没有被提供，那么使用Python的全局命名空间。</li>
<li>locals：这个参数管控的是一个局部命名空间，和globals类似，当它和globals中有重复或冲突时，以locals为准。如果locals没有被提供，那么默认为globals。</li>
</ul>
<div class="tag-plugin note" color="yellow"><div class="title">注意，\_\_builtins\_\_</div><div class="body"><p>是 Python 的内建模块，平时使用的 int、str、abs 都在这个模块中。通过 print(dic[__builtins__]) 语句可以查看 __builtins__ 所对应的 value。</p></div></div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dic=&#123;&#125; <span class="comment">#定义一个字</span></span><br><span class="line">dic[<span class="string">&#x27;b&#x27;</span>] = <span class="number">3</span> <span class="comment">#在 dic 中加一条元素，key 为 b</span></span><br><span class="line"><span class="built_in">print</span> (dic.keys()) <span class="comment">#先将 dic 的 key 打印出来，有一个元素 b</span></span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;a = 4&quot;</span>, dic) <span class="comment">#在 exec 执行的语句后面跟一个作用域 dic</span></span><br><span class="line"><span class="comment">#全局域字典dic很明显会增加一个新的全局变量a</span></span><br><span class="line"><span class="built_in">print</span>(dic.keys()) <span class="comment">#exec 后，dic 的 key 多了一个</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict_keys([<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">dict_keys([<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>上面的代码是在作用域 dic 下执行了一句 a = 4 的代码。可以看出，exec() 之前 dic 中的 key 只有一个 b。执行完 exec() 之后，系统在 dic 中生成了两个新的 key，分别是 a 和__builtins__。其中，a 为执行语句生成的变量，系统将其放到指定的作用域字典里；__builtins__是系统加入的内置 key。</p>
<p>我们再看一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">10</span></span><br><span class="line">b=<span class="number">20</span></span><br><span class="line">c=<span class="number">30</span></span><br><span class="line">g=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">6</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">8</span>&#125; <span class="comment">#定义一个字典</span></span><br><span class="line">t=&#123;<span class="string">&#x27;b&#x27;</span>:<span class="number">100</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">10</span>&#125; <span class="comment">#定义一个字典</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&#x27;a+b+c&#x27;</span>, g, t)) <span class="comment">#定义一个字典 116</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">116</span></span><br></pre></td></tr></table></figure>
<p>为什么结果为116呢？首先我们设置了eval()函数的全局域为<code>&#123;'a':6, 'b':8&#125;</code>，然后又设置了局部域为<code>&#123;'b':100, 'c':10&#125;</code>。但是根据之前的讲解，当globals和locals有冲突时，会产生局部域遮蔽全局域冲突变量的情况，因此此时实际上<code>a+b+c</code>执行的时候，a用全局域中的6，b和c都是使用局部域中的100和10，因此最终结果为116。</p>
<p>我们会发现eval函数中执行代码时变量的值与eval所处的域中变量值并不同，这是因为我们重新为其传入了globals和locals，假设此时我们不设置globals如下所示，那么此时eval()的globals将会继承当前的全局域，因此a为10，代码执行结果为120</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">10</span></span><br><span class="line">b=<span class="number">20</span></span><br><span class="line">c=<span class="number">30</span></span><br><span class="line">g=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">6</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">8</span>&#125; <span class="comment">#定义一个字典</span></span><br><span class="line">t=&#123;<span class="string">&#x27;b&#x27;</span>:<span class="number">100</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">10</span>&#125; <span class="comment">#定义一个字典</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&#x27;a+b+c&#x27;</span>, <span class="literal">None</span>, t)) <span class="comment">#定义一个字典 120</span></span><br></pre></td></tr></table></figure>
<p>以此类推，假设此时我们globals和locals都不设置，那么运行结果将是60</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">10</span></span><br><span class="line">b=<span class="number">20</span></span><br><span class="line">c=<span class="number">30</span></span><br><span class="line">g=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">6</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">8</span>&#125; <span class="comment">#定义一个字典</span></span><br><span class="line">t=&#123;<span class="string">&#x27;b&#x27;</span>:<span class="number">100</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">10</span>&#125; <span class="comment">#定义一个字典</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&#x27;a+b+c&#x27;</span>)) <span class="comment">#定义一个字典 60</span></span><br></pre></td></tr></table></figure>
<h4 id="exec和eval的区别"><a class="markdownIt-Anchor" href="#exec和eval的区别"></a> exec()和eval()的区别</h4>
<p>前面我们讲过，eval()执行完结果会返还，而exec()执行完并不会返还结果，举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;a = 2&quot;</span>) <span class="comment">#相当于直接执行 a=2</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a = <span class="built_in">exec</span>(<span class="string">&quot;2+3&quot;</span>) <span class="comment">#相当于直接执行 2+3，但是并没有返回值，a 应为 None</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a = <span class="built_in">eval</span>(<span class="string">&#x27;2+3&#x27;</span>) <span class="comment">#执行 2+3，并把结果返回给 a</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>当我们为eval()里放置一个没有结果返回的语句时，Python解释器将会报SyntaxError错误</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a= <span class="built_in">eval</span>(<span class="string">&quot;a = 2&quot;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;d:/Pythoncode/Algrithm/test.py&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    a= <span class="built_in">eval</span>(<span class="string">&quot;a = 2&quot;</span>)</span><br><span class="line">  File <span class="string">&quot;&lt;string&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">      ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>
<h4 id="eval和exec函数的应用场景"><a class="markdownIt-Anchor" href="#eval和exec函数的应用场景"></a> eval()和exec()函数的应用场景</h4>
<p>在使用Python开发服务端程序时，两个函数应用的非常广泛，例如客户端向服务端发送一段字符串代码，服务端无需关心具体的内容，直接通过 eval() 或 exec() 来执行，这样的设计会使服务端与客户端的耦合度更低，系统更易扩展。</p>
<p>另外，如果以后接触 <a target="_blank" rel="noopener" href="http://c.biancheng.net/tensorflow/">TensorFlow</a> 框架，就会发现该框架中的静态图就是类似这个原理实现的：</p>
<ul>
<li>TensorFlow 中先将张量定义在一个静态图里，这就相当将键值对添加到字典里一样；</li>
<li>TensorFlow 中通过 session 和张量的 eval() 函数来进行具体值的运算，就当于使用 eval() 函数进行具体值的运算一样。</li>
</ul>
<p>需要注意的是，在使用 eval() 或是 exec() 来处理请求代码时，函数 eval() 和 exec() 常常会被黑客利用，成为可以执行系统级命令的入口点，进而来攻击网站。解决方法是：通过设置其命名空间里的可执行函数，来限制 eval() 和 exec() 的执行范围。</p>
<h3 id="python函数式编程"><a class="markdownIt-Anchor" href="#python函数式编程"></a> Python函数式编程</h3>
<p>所谓函数式编程，就是指代码中每一块都是不可变的，都由纯函数的形式组成。这里的纯函数，是指函数本身相互独立、互相影响，对于相同的输入，总会有相同的输出。</p>
<div class="tag-plugin note" color="yellow"><div class="body"><p>函数式编程的一大特点，就是允许把函数本身作为参数传入另一个函数，还允许返回一个函数。</p></div></div>
<p>假设现在我们想让列表中的元素值都变为原来的两倍，可以使用如下函数实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">multiply_2</span>(<span class="params"><span class="built_in">list</span></span>):</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(<span class="built_in">list</span>)):</span><br><span class="line">        <span class="built_in">list</span>[index] *= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span></span><br></pre></td></tr></table></figure>
<p>要注意，这段代码并不是一个纯函数的形式，因为列表中的元素的值都被改变了，如果多次调用multiply_2()函数，那么每次得到的结果都是不一样的。</p>
<p>而如果想让multiply_2()成为一个纯函数的形式，就得重新创建一个新的列表并返回，也就是写成下面这种形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">multiply_2_pure</span>(<span class="params"><span class="built_in">list</span></span>):</span><br><span class="line">    new_list = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">        new_list.append(item * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> new_list</span><br></pre></td></tr></table></figure>
<p>对比上面两种写法，我们可以发现第一种写法中是直接修改了输入列表的元素，而第二种写法是返回了一个新的列表，新的列表存储了操作后的结果元素，并未修改原列表。**第二种写法无论传入多少次list，返回的结果都是一样的。**函数式编程的优点，就是其纯函数和不可变的特性使程序更加健壮，易于调试和测试，但是缺点是限制多，难写。</p>
<p>纯粹的函数式编程语言（比如Scala)，其编写的函数中是没有变量的，因此可以保证，只要输入是确定的，输出就是确定的。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，因此同样的输入，可能也会得到不同的输出。</p>
<p>Python允许使用变量，所以他并不是一门纯函数式编程语言。Python仅对函数式编程提供了部分支持，主要包括map()，filter()和reduce()这3个函数。他们通常都和lambda匿名函数一起使用。</p>
<h4 id="python-map函数"><a class="markdownIt-Anchor" href="#python-map函数"></a> Python map()函数</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(function, iterable)</span><br></pre></td></tr></table></figure>
<p>其中，fucntion参数表示要传入一个函数，其可以是内置函数、自定义函数或者lambda匿名函数，iterable表示一个或者多个可迭代对象，可以是列表、字符串等。</p>
<p>map()函数的功能是对每一个可迭代对象中的每个元素，都调用指定的函数，并且返回一个map()对象。<strong>由于返回的是一个map()对象，因此不能直接输出，可以通过for循环或者list()函数来显示。</strong></p>
<p>我们还是实现对列表中的每一个元素都乘2的功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listDemo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">new_list = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * <span class="number">2</span>, listDemo)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(new_list))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>， <span class="number">4</span>， <span class="number">6</span>， <span class="number">8</span>， <span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<p>并且map()支持传入多个可迭代对象作为参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listDemo1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">listDemo2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">new_list = <span class="built_in">map</span>(<span class="keyword">lambda</span> x,y: x + y, listDemo1,listDemo2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(new_list))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure>
<p>由于map()函数是直接使用C语言写的，运行时不需要通过Python解释器间接调用，并且内部做了诸多优化，所以相比其他方法，此方法的运行效率更高。</p>
<h4 id="python-filter函数"><a class="markdownIt-Anchor" href="#python-filter函数"></a> Python filter()函数</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">filter</span>(function, iterable)</span><br></pre></td></tr></table></figure>
<p>此格式中，fucntion参数要传入一个函数，iterable表示一个可迭代对象。</p>
<p>filter()函数的功能是对iterable中的每一个元素，都使用function函数判断，并返回True或者False，最后将True的元素组成一个新的可遍历的集合。即<code>元素筛选</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listDemo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">new_list = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, listDemo)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(new_list))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h4 id="python-reduce函数"><a class="markdownIt-Anchor" href="#python-reduce函数"></a> Python reduce()函数</h4>
<p>reduce() 函数通常用来对一个集合做一些累积操作，其基本语法格式为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(function, iterable)</span><br></pre></td></tr></table></figure>
<p>function参数必须是一个包含两个参数的函数，iterable表示可迭代对象。</p>
<div class="tag-plugin note" color="yellow"><div class="title">注意，由于</div><div class="body"><p>reduce() 函数在 Python 3.x 中已经被移除，放入了 functools 模块，因此在使用该函数之前，需先导入 functools 模块。</p></div></div>
<p>假设我们要计算某个列表所有元素的乘积</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line">listDemo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">product = functools.reduce(<span class="keyword">lambda</span> x, y: x * y, listDemo)</span><br><span class="line"><span class="built_in">print</span>(product)</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure>
<h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4>
<p>通常来说，当对集合中的元素进行一系列操作时，如果操作非常简单，比如累加、累积这种，那么优先考虑使用map()，filter()，reduce()等实现，另外，在数据量非常多的情况下（比如机器学习的应用），一般更倾向于使用函数式编程的表示，因为效率更高。</p>
<p>当然，在数据量不多的情况下，使用for循环等方式也是可以的，不过，如果要对集合中的元素做一些比较复杂的操作，考虑到代码的可读性，通常会使用for循环。</p>

  


  </article>
  
<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">回顾上一篇</div><a href="/wiki/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/index.html">函数基础</a></div><div class="item" id="next"></div></section></div>

  

  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      快来参与讨论吧
    </section>
    <section class='body cmt-body waline'>
      

<div id="waline_container" class="waline_thread" comment_id="Python"><svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg></div>

    </section>
  </div>




      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客</span><a href="/">随想录</a><a href="/intro">言堂序</a><a href="/archives">归档册</a></div><div class="sitemap-group"><span class="fs14">笔记</span><a href="/wiki/tags/%E7%AC%AC%E4%B9%9D%E8%89%BA%E6%9C%AF">第九艺术</a><a href="/wiki/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80">计算基础</a><a href="/wiki/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80">语言基础</a><a href="/wiki/tags/%E8%BF%9B%E9%98%B6%E6%8A%80%E8%83%BD">进阶技能</a></div><div class="sitemap-group"><span class="fs14">便笺</span><a href="/notes/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0">科研学习</a><a href="/notes/%E5%BB%BA%E7%AB%99%E5%BF%85%E5%A4%87">建站必备</a><a href="/notes/%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7">建站必备</a></div><div class="sitemap-group"><span class="fs14">更多</span><a target="_blank" rel="noopener" href="https://coolchong.cn">个人主页</a><a target="_blank" rel="noopener" href="https://blog.coolchong.cn/friends.html">友情链接</a></div></div><div class="text"><div class="github-badge">
  <a style="color: #fff"  href="https://coolchong.cn/" target="_blank" title="由 Langwenchong 搭建运营">
    <span class="badge-subject">Built</span><span class="badge-value bg-blue">雨中 @2022-2023</span>
  </a>
  <a style="color: #fff" href="https://https://www.qiniu.com//" target="_blank" title="静态资源托管于 七牛云" >
    <span class="badge-subject">Powered</span><span class="badge-value bg-orange">七牛云</span>
  </a>
  <a style="color: #fff" href="https://xaoxuu.com/wiki/stellar/" target="_blank" title="站点使用 Stellar 主题" >
    <span class="badge-subject">Theme</span><span class="badge-value bg-brightgreen">Stellar</span>
  </a>
  <a style="color: #fff" href="https://beian.miit.gov.cn/)" target="_blank" title="网站已备案授权开放">
    <span class="badge-subject">Record</span><span class="badge-value bg-red">津ICP备2021009044</span>
  </a>
</div>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.18.5';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function load_comment(){
    if(!document.getElementById("waline_container"))return;
    stellar.loadCSS('https://unpkg.com/@waline/client@2.14.1/dist/waline.css');
    stellar.loadScript('https://unpkg.com/@waline/client@2.14.1/dist/waline.js', {defer:true}).then(function () {
      const el = document.getElementById("waline_container");
      var path = el.getAttribute('comment_id');
      if (!path) {
        path = decodeURI(window.location.pathname);
      }
      Waline.init(Object.assign({"js":"https://unpkg.com/@waline/client@2.14.1/dist/waline.js","css":"https://unpkg.com/@waline/client@2.14.1/dist/waline.css","serverURL":"https://waline.coolchong.cn","commentCount":true,"pageview":false,"emoji":["https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/","https://unpkg.com/@waline/emojis@1.1.0/tw-emoji","https://unpkg.com/@waline/emojis@1.1.0/bilibili","https://unpkg.com/@waline/emojis@1.1.0/alus","https://unpkg.com/@waline/emojis@1.1.0/bmoji"],"locale":{"reactionTitle":null,"placeholder":"任何想法畅所欲言，记得填写邮箱方便及时收到回复哦~"},"reaction":["https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatheart.png","https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatattentionreverse.png","https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatrainbow.png","https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatwave.png","https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/blobcatalt.png","https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/blobcatscared.png"]}, {
        el: '#waline_container',
        path: path,
      }));
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
    console.log('DOM fully loaded and parsed');
    load_comment();
  });

</script>




<!-- inject -->


  </div>
</body>
</html>
