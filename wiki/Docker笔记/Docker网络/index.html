<!DOCTYPE html>
<html lang='zh-CN'>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?fc63ac4843a697431e3d43c4d48b99de";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>Docker：网络与Dockerhub - 雨中•学圃堂</title>

  
    <meta name="description" content="发布镜像到Dockerhub等远程仓库首先我们需要一个DockerHub账户，这样我们就可以在服务器发布我们的镜像到远程仓库了。首先我们查看一下在服务器上登录我们DockerHub账户 12345678910111213141516171819Log in to a Docker registry.If no server is specified, the default is defined">
<meta property="og:type" content="website">
<meta property="og:title" content="网络与Dockerhub">
<meta property="og:url" content="https://scholar.coolchong.cn/wiki/Docker%E7%AC%94%E8%AE%B0/Docker%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="雨中•学圃堂">
<meta property="og:description" content="发布镜像到Dockerhub等远程仓库首先我们需要一个DockerHub账户，这样我们就可以在服务器发布我们的镜像到远程仓库了。首先我们查看一下在服务器上登录我们DockerHub账户 12345678910111213141516171819Log in to a Docker registry.If no server is specified, the default is defined">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126153217.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126153404.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126154006.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126154311.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126154430.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126154525.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126155205.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126161845.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126162111.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126162346.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126164053.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126171200.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126165752.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126170213.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126170510.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126164053.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126172319.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126172439.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126174906.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126174800.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126174954.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126175738.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126180048.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211126180619.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128145822.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128150344.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128151709.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128155111.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128155405.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128155636.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128161409.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128161717.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128161934.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128164409.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128170151.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128171236.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128171413.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128172108.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128192720.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128193232.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128193745.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128193942.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128194259.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128202631.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128203035.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128204308.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128204515.png">
<meta property="og:image" content="https://langwenchong.gitee.io/figure-bed/20211128204622.png">
<meta property="article:published_time" content="2023-01-28T06:17:12.742Z">
<meta property="article:modified_time" content="2023-01-28T06:17:12.742Z">
<meta property="article:author" content="Wenchong Lang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://langwenchong.gitee.io/figure-bed/20211126153217.png">
  
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="雨中•学圃堂" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="https://cdn.coolchong.cn/%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/langwenchong.png">
  

  

  
    <link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
    <script defer src="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js" ></script>
    <script defer src="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
  


  
    
      <link href="https://fonts.font.im/css?family=Dancing+Script" rel="stylesheet">
    
      <link href="https://fastly.jsdelivr.net/gh/volantis-x/cdn-fontawesome-pro@master/css/all.min.css" rel="stylesheet">
    
  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='wiki'>
    

  




<div class="widgets"><widget class="widget-wrapper logo-wrap wiki"><div class="widget-body"><a style="filter: grayscale(100%)" class="wiki-home cap" href="/wiki"><svg aria-hidden="true" viewBox="0 0 16 16" width="1rem" height="1rem" fill="currentColor"><path fill-rule="evenodd" d="M7.78 12.53a.75.75 0 01-1.06 0L2.47 8.28a.75.75 0 010-1.06l4.25-4.25a.75.75 0 011.06 1.06L4.81 7h7.44a.75.75 0 010 1.5H4.81l2.97 2.97a.75.75 0 010 1.06z"></path></svg>所有笔记</a><a class="title" href="/wiki/Docker%E7%AC%94%E8%AE%B0/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/index.html"><div class="main" ff="title">Docker</div><div class="sub cap">一起成为可爱的蓝鲸搬运工吧</div></a></div></widget>
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/wiki/Docker笔记/" placeholder="想找点什么？"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">好像并未找到什么！</div></div></div></widget>




<widget class="widget-wrapper toc multi" id="data-toc"><div class="widget-header cap dis-select"><span class="name">基础知识</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Docker%E7%AC%94%E8%AE%B0/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/index.html#start"><span class="toc-text">常用操作</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Docker%E7%AC%94%E8%AE%B0/%E9%95%9C%E5%83%8F%E4%B8%8E%E5%8D%B7%E6%8C%82%E8%BD%BD/index.html"><span class="toc-text">镜像与卷挂载</span></a></div><div class="doc-tree active"><a class="doc-tree-link active" href="/wiki/Docker%E7%AC%94%E8%AE%B0/Docker%E7%BD%91%E7%BB%9C/index.html"><span class="toc-text">网络与Dockerhub</span></a><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E9%95%9C%E5%83%8F%E5%88%B0Dockerhub%E7%AD%89%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-text">发布镜像到Dockerhub等远程仓库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E9%95%9C%E5%83%8F%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-text">发布镜像到阿里云镜像远程仓库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E6%89%80%E6%9C%89%E6%B5%81%E7%A8%8B%E5%B0%8F%E7%BB%93"><span class="toc-text">Docker所有流程小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E7%BD%91%E7%BB%9C"><span class="toc-text">Docker网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3Docker0"><span class="toc-text">理解Docker0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9A%E8%BF%99%E6%A0%B7%E8%BF%9E%E6%8E%A5%E4%BC%9A%E4%B8%8D%E4%BC%9A%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%8E%9F%E5%88%99%E7%9B%B8%E6%82%96%EF%BC%9F"><span class="toc-text">思考：这样连接会不会与容器之间独立的原则相悖？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9Aveth-pair%E5%88%B0%E5%BA%95%E6%98%AF%E5%95%A5%EF%BC%9F%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%EF%BC%9F"><span class="toc-text">思考：veth-pair到底是啥？怎么运行的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9A%E6%AD%A4%E6%97%B6tomcat01%E8%83%BD%E5%90%A6%E7%9B%B4%E6%8E%A5%E5%92%8Ctomcat02ping%E9%80%9A%EF%BC%9F"><span class="toc-text">思考：此时tomcat01能否直接和tomcat02ping通？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9Adocker0%E5%8F%AF%E7%94%A8%E7%9A%84ip%E6%95%B0%E9%87%8F%E6%9C%89%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">思考：docker0可用的ip数量有多少？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94%E2%80%94link"><span class="toc-text">容器互联—link</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9A%E6%AD%A4%E6%97%B6tomcat02%E8%83%BD%E5%90%A6%E4%BD%BF%E7%94%A8ping-tomcat03%E8%BF%9E%E6%8E%A5%E5%88%B0tomcat03%E5%AE%B9%E5%99%A8%EF%BC%9F"><span class="toc-text">思考：此时tomcat02能否使用ping tomcat03连接到tomcat03容器？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C"><span class="toc-text">自定义网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%BF%9E%E9%80%9A"><span class="toc-text">网络连通</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9A%E6%AD%A4%E6%97%B6tomcat01%E8%83%BD%E5%90%A6%E4%BD%BF%E7%94%A8ping-%E5%AE%B9%E5%99%A8%E5%90%8D%E7%9A%84%E5%BD%A2%E5%BC%8Fping%E9%80%9A%E5%85%B6%E4%BB%96%E5%AE%B9%E5%99%A8%EF%BC%9F"><span class="toc-text">思考：此时tomcat01能否使用ping+容器名的形式ping通其他容器？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%EF%BC%9A%E9%83%A8%E7%BD%B2redis%E9%9B%86%E7%BE%A4"><span class="toc-text">实战：部署redis集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SingBoot%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%89%93%E5%8C%85Docker%E9%95%9C%E5%83%8F"><span class="toc-text">SingBoot微服务打包Docker镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9A%E5%9B%A0%E6%AD%A4%E6%88%91%E4%BB%AC%E6%9C%80%E7%BB%88%E5%8F%AA%E9%9C%80%E8%A6%81%E7%BB%99%E5%88%AB%E4%BA%BA%E4%BB%80%E4%B9%88%E6%96%87%E4%BB%B6%E7%94%A8%E6%9D%A5%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF%E5%91%A2%EF%BC%9F"><span class="toc-text">思考：因此我们最终只需要给别人什么文件用来部署上线呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></div></div></widget>



<widget class="widget-wrapper related"><div class="widget-header cap theme dis-select"><span class="name">更多进阶技能</span></div><div class="widget-body related-posts"><a class="item wiki" href="/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/index.html"><span class="title">设计模式笔记</span><span class="excerpt">设计模式即DesignPatterns是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。</span></a><a class="item wiki" href="/wiki/Git%E7%AC%94%E8%AE%B0/%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/index.html"><span class="title">Git笔记</span><span class="excerpt">Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</span></a></div></widget>
</div>


    </aside>
    <div class='l_main'>
      

      <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?fc63ac4843a697431e3d43c4d48b99de";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
</script>



  
  
<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" id="home" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" id="menu" href="/wiki/">笔记</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/wiki/Docker%E7%AC%94%E8%AE%B0/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/index.html">Docker</a></div><div id="post-meta">更新于&nbsp;<time datetime="2023-01-28T06:17:12.742Z">2023-01-28</time></div></div>

  <article class='md-text content wiki reveal'>
  <h1 class="article-title"><span>网络与Dockerhub</span></h1>
  <h2 id="发布镜像到Dockerhub等远程仓库"><a href="#发布镜像到Dockerhub等远程仓库" class="headerlink" title="发布镜像到Dockerhub等远程仓库"></a>发布镜像到Dockerhub等远程仓库</h2><p>首先我们需要一个DockerHub账户，这样我们就可以在服务器发布我们的镜像到远程仓库了。首先我们查看一下在服务器上登录我们DockerHub账户</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Log in to a Docker registry.</span><br><span class="line">If no server is specified, the default is defined by the daemon.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">密码</span></span><br><span class="line">  -p, --password string   Password</span><br><span class="line">      --password-stdin    Take the password from stdin</span><br><span class="line">     #账号</span><br><span class="line">  -u, --username string   Username</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里我们登录自己的账号</span></span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you don&#x27;t have a Docker ID, head over to https://hub.docker.com to create one.</span><br><span class="line">Username: langwenchong</span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">登录成功</span></span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure>
<p>然后我们尝试发布这个镜像，但是在发布之前我们需要先创建一个标签如下图所示</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126153217.png" alt=""></p>
<p>我们使用<code>docker push</code>指令进行发布，如下图所示，但是由于DockerHub在外网，因此我们可能会上传失败或者上传非常慢，请耐心等待，后面我们还会学习如何发布到阿里云镜像仓库。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126153404.png" alt=""></p>
<h2 id="发布镜像到阿里云镜像远程仓库"><a href="#发布镜像到阿里云镜像远程仓库" class="headerlink" title="发布镜像到阿里云镜像远程仓库"></a>发布镜像到阿里云镜像远程仓库</h2><p>我们已经体会到了上传DockerHub有多慢了，因此我们这里学习如何发布到阿里云镜像仓库。首先我们登录阿里云然后搜索寻找<code>容器镜像服务</code>，然后创建一个个人实例用来学习即可如下图</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126154006.png" alt=""></p>
<p>然后我们进入个人镜像实例，这里我们可以创建命名空间，但是要注意一个账号只能创建三个命名空间，但是一个命名空间可以存储许多的镜像仓库，因此个人使用完全足够，如下图：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126154311.png" alt=""></p>
<p>然后我们再创建一个镜像仓库（就类似于github的远程仓库），一会我们就提交到这个远程仓库中，如下图</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126154430.png" alt=""></p>
<p>然后选择本地仓库创建即可，然后我们就得到了一个远程仓库的地址</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126154525.png" alt=""></p>
<p>接下来我们按照上面的步骤上传即可，首先我们DockerHub的账号，然后登陆阿里云的账号</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126155205.png" alt=""></p>
<p>然后我们按照步骤还需要进行仓库的pull,使用<code>docker tag</code>创建提交版本等， 这里由于我们是首次提交就不需要拉取了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从Registry中拉取镜像</span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/langwenchong/tomcat-test:[镜像版本号]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建提交版本</span></span><br><span class="line">docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/langwenchong/tomcat-test:[镜像版本号]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">然后push</span></span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/langwenchong/tomcat-test:[镜像版本号]</span><br></pre></td></tr></table></figure>
<div class="tag-plugin note" color="yellow"><div class="body"><p>一定要注意这里的创建版本，提交必须按照阿里云的要求完成，否则会被拒绝push😯！前面的<code>hangzhou.aliyuncs.com</code>是不能省略的！</p></div></div>
<p>比如我们这里将镜像版本号设置为1.0并提交，那么指令应该如下图这样操作：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126161845.png" alt=""></p>
<p>理论上来说应该挺快的，一会就能提交完成然而我最终还是提交失败了…如果你提交成功了，应该可以看到阿里云的镜像仓库已经更新了</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126162111.png" alt=""></p>
<p>以后如果我们需要别人使用我们的镜像，只需要docker pull 镜像名称即可了。</p>
<h2 id="Docker所有流程小结"><a href="#Docker所有流程小结" class="headerlink" title="Docker所有流程小结"></a>Docker所有流程小结</h2><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126162346.png" alt=""></p>
<p>自此我们已经学会了docker的全部基本操作，上图是所有流程的过程图。我们看到上图还有<code>save</code>和<code>load</code>指令，这两个指令实际上也很好理解，我们除了可以让伙伴直接从远程仓库拉取我们推送的镜像以外，也可以使用save指令将我们创建的镜像打包成压缩包，然后发送给伙伴，他再使用<code>load</code>指令解压即可得到我们创建的镜像。如果你已经能看懂上面的图了，那么恭喜你已经入门Docker成功😁！但是我们可以再深入学习进阶Docker知识，偏向集群的运维。</p>
<h2 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h2><h3 id="理解Docker0"><a href="#理解Docker0" class="headerlink" title="理解Docker0"></a>理解Docker0</h3><p>首先我们清空之前创建的所有镜像和容器，然后输入<code>ip addr</code>查看网络信息</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126164053.png" alt=""></p>
<p>我们可以看到三个网络，分别是三个docker环境。我们思考一个问题：假设现在主机内部有两个容器，其中一个是tomcat容器负责页面的访问，另一个容器时mysql容器用来存储数据，那么我们tomcat容器的项目如何去连接mysql容器获取数据？</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126171200.png" alt=""></p>
<h4 id="思考：这样连接会不会与容器之间独立的原则相悖？"><a href="#思考：这样连接会不会与容器之间独立的原则相悖？" class="headerlink" title="思考：这样连接会不会与容器之间独立的原则相悖？"></a>思考：这样连接会不会与容器之间独立的原则相悖？</h4><p>答案是不会，因为此时两个容器结构上还是独立运行的，两者配置的更改不会影响到对方，只是两个容器之间有功能上的连接，这种连接是允许的。</p>
<p>这里就会涉及到docker网络的知识。接下来我们就以这个为案例进行docker网络的学习，首先我们创建一个tomcat容器，然后启动并且在后面追加<code>ip addr</code>查看这个容器的内网信息如下图所示，由于我下载的这个最新版tomcat是精简版没有<code>ip addr</code>指令，因此我们选择进入这个容器然后输入如下指令先安装指令集</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update &amp;&amp; apt install -y iproute2</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126165752.png" alt=""></p>
<p>安装完成后我们再输入<code>ip addr</code>查看这个容器的内网信息：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126170213.png" alt=""></p>
<div class="tag-plugin note" color="yellow"><div class="body"><p>如果你已经学过计算及网络了，可以回忆一下这个地址后面的<code>/8</code>、<code>/16</code>代表什么？实际上他是子网掩码，通过前面的ip地址加上子网掩码我们就可以得知子网的划分。</p></div></div>
<p>上面的第二个网络是每一个容器都有的，他是docker为其分配的一个地址用来宿主机访问连接的，我们在创建这个容器时使用的是<code>-P</code>随机的端口暴露，但是我们可以通过这个docker为其分配的地址仍然可以ping通这个容器，如下图</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126170510.png" alt=""></p>
<p>现在我们发现主机是可以通过docker为这个容器分配的地址ping到这个容器的，想一想也很合理，既然容器在宿主机上运行，很显然宿主机应该能够ping到这个容器内部。我们前面学习过两个容器之间很难直接建立连接，那么我们此时就可以借用主机可以ping通任何一个容器的特点，让两个容器通过主机来间接连接。实际上我们学习过计网后应该可以知道实际上docke为这些容器分配的就是一个主机的内网ip，因此这些容器处于同一个主机内网下。</p>
<p>我们每启动一个docker容器，docker就会为docker容器分配一个ip,我们只要安装了docker，就会有一个网卡docker0,他使用桥接模式工作，使用的技术是veth-pair技术。此时每添加一个容器，主机的docker0网络就会添加一条网卡即docker容器的veth地址如下图我们对比一下：</p>
<div class="tag-plugin tabs"id="tab_14"><div class="nav-tabs"><div class="tab active"><a href="#tab_14-1">创建容器前主机docker0网络</a></div><div class="tab"><a href="#tab_14-2">创建容器主机后docker0网络</a></div><div class="tab"><a href="#tab_14-3">tomcat容器内网信息</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_14-1"><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126164053.png" alt="创建容器前主机docker0网络"><br><!-- endtab --></p></div><div class="tab-pane" id="tab_14-2"><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126172319.png" alt="创建容器主机后docker0网络"><br><!-- endtab --></p></div><div class="tab-pane" id="tab_14-3"><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126172439.png" alt="tomcat容器内网信息"><br><!-- endtab --></p></div></div></div>
<p>这就是主机可以ping同创建的容器的原因，由此类推，如果现在再创建一个tomcat02容器，那么主机docker0网络下会再新增一个记录值网卡：</p>
<div class="tag-plugin tabs"id="tab_15"><div class="nav-tabs"><div class="tab active"><a href="#tab_15-1">创建tomcat02后主机网络</a></div><div class="tab"><a href="#tab_15-2">第二个容器内网信息</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_15-1"><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126174906.png" alt="创建tomcat02后主机网络"><br><!-- endtab --></p></div><div class="tab-pane" id="tab_15-2"><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126174800.png" alt="第二个容器内网信息"><br><!-- endtab --></p></div></div></div>
<h4 id="思考：veth-pair到底是啥？怎么运行的？"><a href="#思考：veth-pair到底是啥？怎么运行的？" class="headerlink" title="思考：veth-pair到底是啥？怎么运行的？"></a>思考：veth-pair到底是啥？怎么运行的？</h4><p>我们仔细观察发现当创建一个容器后，这个容器获得了88，而宿主机就是89，他们永远生成的都是一对连接的数值即网卡，这就是linux的veth-pair技术，他是专门用来连接各种虚拟网络设备的技术类似于“桥梁”，如下图我们很容易就能理解主机是如何通过veth-pair技术提供的网卡实现和容器通信的</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126174954.png" alt=""></p>
<div class="tag-plugin note" color="yellow"><div class="body"><p>OpenStac、Docker容器之间的连接、OVS的连接等都是使用veth-pair技术实现的</p></div></div>
<h4 id="思考：此时tomcat01能否直接和tomcat02ping通？"><a href="#思考：此时tomcat01能否直接和tomcat02ping通？" class="headerlink" title="思考：此时tomcat01能否直接和tomcat02ping通？"></a>思考：此时tomcat01能否直接和tomcat02ping通？</h4><p>此时tomcat01是可以ping通tomcat02的，原因就是两个容器可以通过主机间接实现连接，此时他们位于同一个内网网段了（此时主机是172.18.0.1,tomcat01是172.18.0.2，tomcat02是172.18.0.3），因此可以互相连接了。实际上就是基于vrth-pair实现的。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126175738.png" alt=""></p>
<p>即此时两个容器之间可以间接连通了：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126180048.png" alt=""></p>
<div class="tag-plugin note" color="yellow"><div class="body"><p>我们要注意首先是通过veth-pair实现了主机和所有的容器连通，然后容器之间又通过和主机的veth-pair通信技术和其他容器处于了同一个网段因此间接也连通了！</p></div></div>
<p>也就是说刚刚我们实现的tomcat01连接tomcat02通信实际上通信的路径应该如下：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211126180619.png" alt=""></p>
<p>我们可以查看到主机的docker0下存储了所有的相关的网卡，因此主机模块优点类似于网络层的路由器他维护了一个路由转发表用来转发信息，因此其他容器间的通信会经过主机。</p>
<p>同时我们要注意，docker0是虚拟的，使用linux桥接直接和物理设备的ip直连映射，即NAT直连。如下图：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128145822.png" alt=""></p>
<div class="tag-plugin note" color="yellow"><div class="body"><p>由于docker0的地址都是虚拟ip，因此容器间的通信速度，主机的转发速度非常快。</p></div></div>
<h4 id="思考：docker0可用的ip数量有多少？"><a href="#思考：docker0可用的ip数量有多少？" class="headerlink" title="思考：docker0可用的ip数量有多少？"></a>思考：docker0可用的ip数量有多少？</h4><p>所有的容器在不指定网络下，都是docker0路由，docker会给我们的容器分配一个默认的可用ip，那么可用的ip数量大概有多少呢？我们查看一下docker0的子网ip是xxx.xxx.xxx.xxx/16，那么也就意味着子网段码占后16位ip，因此是255*255-2≈65535个可分配容器的ip(减去的两个是回环地址0.0.0.0和用来表示子网掩码的255.255.255.255)。</p>
<p>并且当我们删除容器时，docker0网卡会自动回收，假设现在我们将tomcat01容器删除，再查看主机docker0下的网卡信息，会发现之前的88-89网卡被回收了。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128150344.png" alt=""></p>
<h3 id="容器互联—link"><a href="#容器互联—link" class="headerlink" title="容器互联—link"></a>容器互联—link</h3><p>我们回顾一下之前两个容器之间的通信，他们是基于清楚对方ip的情况下才能通过主机转发连通的，但是我们知道ip是很容易变化的，即使是docker0分配，当一个容器崩溃重启后他的ip会被收回可能再次被分配的ip也和之前的不一样了，那么之前和他有联系的容器现在在和他通信难道还需要手动的一个个去更新ip?很显然不现实，因此我们希望可以通过知道对方的容器服名就可以自动连接，而不再是基于ip。这时我们就会用到<code>--link</code>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128151709.png" alt=""></p>
<p>首先我们尝试不用<code>--link</code>能够让tomcat02ping到tomcat01，就直接使用容器名tomcat01。</p>
<div class="tag-plugin note" color="yellow"><div class="title">容器默认不配备ping指令，请先输入如下指令为容器安装</div><div class="body"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt install iputils-ping &amp;&amp; apt install net-tools</span><br></pre></td></tr></table></figure></div></div>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128155111.png" alt=""></p>
<p>此时我们在创建一个容器时加上<code>--link 要连接的容器</code>既可以实现他的单向连通，比如此时我们创建一个tomcat03容器命令如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P --name tomcat03 --link tomcat02 tomcat</span><br></pre></td></tr></table></figure>
<p>此时我们创建的容器tomcat03就可以使用容器名来连通tomcat02了（别忘了先安装ping指令），证明图如下</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128155405.png" alt=""></p>
<h4 id="思考：此时tomcat02能否使用ping-tomcat03连接到tomcat03容器？"><a href="#思考：此时tomcat02能否使用ping-tomcat03连接到tomcat03容器？" class="headerlink" title="思考：此时tomcat02能否使用ping tomcat03连接到tomcat03容器？"></a>思考：此时tomcat02能否使用<code>ping tomcat03</code>连接到tomcat03容器？</h4><p>答案是不能，我们之前说到了—link仅仅是单向连同，因此此时tomcat02并不能使用<code>ping tomcat03</code>连接到tomcat03:</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128155636.png" alt=""></p>
<p>我们探究一下tomcat03为什么可以知道tomcat02的ip，实际上他是使用<code>--link</code>为自己的本地host中添加了一条规则记录值记录着tomcat02的ip，因此我们输入<code>ping tomcat02</code>时他可以从自己的本地host中获知tomcat02的ip，实际上这个场景优点类似于域名和ip的关系。如下图是探究时的一些发现：</p>
<p><strong>一：docker network指令的使用以及docker0信息</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-7-centos ~]# docker network --help</span><br><span class="line"></span><br><span class="line">Usage:  docker network COMMAND</span><br><span class="line"></span><br><span class="line">Manage networks</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面是docker network后面可以追加的参数</span></span><br><span class="line">Commands:</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">连接一个容器加入网络</span></span><br><span class="line">  connect     Connect a container to a network</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">创建网络</span></span><br><span class="line">  create      Create a network</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">容器断开指定网络</span></span><br><span class="line">  disconnect  Disconnect a container from a network</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">查看某一个网络的详细信息</span></span><br><span class="line">  inspect     Display detailed information on one or more networks</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">获取网络信息</span></span><br><span class="line">  ls          List networks</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">删除所有没有被使用的网络</span></span><br><span class="line">  prune       Remove all unused networks</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">删除指定网络</span></span><br><span class="line">  rm          Remove one or more networks</span><br><span class="line"></span><br><span class="line">Run &#x27;docker network COMMAND --help&#x27; for more information on a command.</span><br></pre></td></tr></table></figure>
<p>因此这里我们使用<code>docker network ls</code>查看一下全局的网络配置如下图</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-7-centos ~]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里的第一个bridge实际上就是使用桥接的docker0网络我们进一步查看</span></span><br><span class="line">010db73bc452   bridge    bridge    local</span><br><span class="line">7bb6e8a7bdb9   host      host      local</span><br><span class="line">b57d61a5e430   none      null      local</span><br></pre></td></tr></table></figure>
<p>这里我们使用<code>docker network inspect 010db73bc452</code>进一步查看docker0网络的信息</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128161409.png" alt=""></p>
<p><strong>二：容器内部信息</strong></p>
<p>这里我们是将tomcat03使用了<code>--link</code>单向连接了tomcat02，因此此时我们就来查看docker03的信息，这里输入<code>docker inspect docker03的id</code>查看他的详细信息：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128161717.png" alt=""></p>
<p>除了发现环境配置以外，我们还可以看到他的被分配的docker0ip地址以及默认网关确实就是主机的docker0因此他会经过主机的转发</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128161934.png" alt=""></p>
<p><strong>三：查看tomcat03的本地host记录值</strong></p>
<p>我们知道hosts是一种很早的计网产物，他类似于一个设备的网络备忘录，记录了常用的连接设备要解析的ip地址，因此他再访问这个设备时可以自动根据设备名从host查看到对应的ip。由于使用了<code>--link tomcat02</code>，现在tomcat03确实可以根据tomcat02就自动ping通，因此他肯定是知道tomcat02的ip，那么理论上这个对应关系应该就存储到了tomcat03的本地hosts:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打印docker03的hosts</span></span><br><span class="line">[root@VM-0-7-centos ~]# docker exec -it tomcat03 /bin/bash</span><br><span class="line">root@ad49f9ff52b2:/usr/local/tomcat# cat /etc/hosts</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">localhost对应回环地址127.0.0.1</span></span><br><span class="line">127.0.0.1	localhost</span><br><span class="line">::1	localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0	ip6-localnet</span><br><span class="line">ff00::0	ip6-mcastprefix</span><br><span class="line">ff02::1	ip6-allnodes</span><br><span class="line">ff02::2	ip6-allrouters</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意这里确实记录了tomcat02的ip</span></span><br><span class="line">172.18.0.3	tomcat02 560768d4bf97</span><br><span class="line">172.18.0.4	ad49f9ff52b2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>正式由于tomcat03的hosts记录了tomcat02的ip映射，因此tomcat03可以通过<code>ping tomcat02</code>就可以ping通，因为他会从hotsts获取到tomcat02的ip。</p>
<p>那么现在我们怎么才能让tomcat02也能够通过<code>ping tomcat03</code>甚至<code>ping tomcat01</code>等等就可以实现连通呢？答案很简单了，逐一去修改各容器的hosts后重启就可以了，但是很显然这种操作太麻烦了，即使使用了卷挂载技术共享hosts也很麻烦。因此<code>--link</code>现在并不常用了，甚至docker0都不太常用， 因为他是一个官网的网络，默认不支持<code>容器名连接访问</code>等功能，因此接下来我们会学习自定义网络。</p>
<h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><p>我们输入<code>docker netwoek ls</code>查看一下当前已有的网络：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-7-centos ~]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意name为beidge默认就是docker0</span></span><br><span class="line">010db73bc452   bridge    bridge    local</span><br><span class="line">7bb6e8a7bdb9   host      host      local</span><br><span class="line">b57d61a5e430   none      null      local</span><br></pre></td></tr></table></figure>
<p>会发现有如下几种网络模式（driver)：</p>
<ol>
<li>bridge：桥接模式（默认的网络模式，一会我们创建的自定义网络也是这种类型）</li>
<li>none：不配置网络</li>
<li>host：和宿主机共享网络</li>
<li>container：容器网络连通（用得少，局限性大）</li>
</ol>
<p>接下来我们就来实际操作一下自定义网络，我们在创建自定义网络进行测试之前，先将之前用来演示的tomcat01,tomcat02,tomcat03容器删除。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128164409.png" alt=""></p>
<p>然后我们来创建一个网络，首先我们看一下<code>`docker network create</code>的可选参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">[root@VM-0-7-centos ~]# docker network create --help</span><br><span class="line"></span><br><span class="line">Usage:  docker network create [OPTIONS] NETWORK</span><br><span class="line"></span><br><span class="line">Create a network</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --attachable           Enable manual container attachment</span><br><span class="line">      --aux-address map      Auxiliary IPv4 or IPv6 addresses used by Network driver (default map[])</span><br><span class="line">      --config-from string   The network from which to copy the configuration</span><br><span class="line">      --config-only          Create a configuration only network</span><br><span class="line">      #核心参数：配置网络模式</span><br><span class="line">  -d, --driver string        Driver to manage the Network (default &quot;bridge&quot;)</span><br><span class="line">  	  #核心参数：配置子网网关</span><br><span class="line">      --gateway strings      IPv4 or IPv6 Gateway for the master subnet</span><br><span class="line">      --ingress              Create swarm routing-mesh network</span><br><span class="line">      --internal             Restrict external access to the network</span><br><span class="line">      --ip-range strings     Allocate container ip from a sub-range</span><br><span class="line">      --ipam-driver string   IP Address Management Driver (default &quot;default&quot;)</span><br><span class="line">      --ipam-opt map         Set IPAM driver specific options (default map[])</span><br><span class="line">      --ipv6                 Enable IPv6 networking</span><br><span class="line">      --label list           Set metadata on a network</span><br><span class="line">  -o, --opt map              Set driver specific options (default map[])</span><br><span class="line">      --scope string         Control the network&#x27;s scope</span><br><span class="line">      #核心参数：配置子网并且格式为xx.xx.xx.xx/xx，决定了一个子网个数以及子网下可分配ip数</span><br><span class="line">      --subnet strings       Subnet in CIDR format that represents a network segment</span><br></pre></td></tr></table></figure>
<p>我们创建一个子网命名为<code>mynet</code>并且子网掩码长度是16，这样他就可以支持65535个可分配ip,同时子网段是192.168那么命令如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建网络，并且mynet的默认网关是192.168.0.1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--drive 设置网络模式为bridge，实际上默认就是bridge</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--subnet 设置子网段为192.168，后面随意变化，因此有255个子网并且每一个子网有255个可分配ip</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--gateway 设置默认网关，一般就是子网下的第一个可分配ip</span></span><br><span class="line">[root@VM-0-7-centos ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line">c9bf25797ca395d914d6807e3536e148a464777831b9cc4897d166a88e565f2d</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看所有网络</span></span><br><span class="line">[root@VM-0-7-centos ~]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">010db73bc452   bridge    bridge    local</span><br><span class="line">7bb6e8a7bdb9   host      host      local</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加成功</span></span><br><span class="line">c9bf25797ca3   mynet     bridge    local</span><br><span class="line">b57d61a5e430   none      null      local</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128170151.png" alt=""></p>
<p>然后接下来我们创建两个容器为<code>tomcat-mynet-01</code>和<code>tomcat-mynet-02</code>并且不再默认加入到docker0网络下，而是我们自己新创建的自定义网络<code>mynet</code>，如下图输入指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-7-centos ~]# docker run -d -P --name tomcat-mynet-01 --net mynet tomcat</span><br><span class="line">8bc67a95591891df5347385f91a36ab8fff46f6fe77a6a1b8ce36a295e98467d</span><br><span class="line">[root@VM-0-7-centos ~]# docker run -d -P --name tomcat-mynet-02 --net mynet tomcat</span><br><span class="line">14adf5f3a12c4b41ba61eb6886c3f4bfd83799372cee4374936274f2a0821f48</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="tag-plugin note" color="yellow"><div class="body"><p>注意<code>-net</code>是设置容器加入的网络，默认情况下不写是加入到名为<code>bridge</code>的网络也就是docker0网络，但是docker0禁止了域名访问，只有使用<code>--link</code>才能打通。</p></div></div>
<p>我们为了能够支持域名访问，因此创建了一个新的自定义网络，一个完整的默认的bridge桥接网络模式是支持域名访问的，因此此时我们发现<code>tomcat-mynet-01</code>是可以不用<code>--link</code>既可以使用<code>ping tomcat-mynet-02</code>连接tomcat-mynet-02容器的，即支持了域名访问，这比docker0要方便的多。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128171236.png" alt=""></p>
<p>同样tomcat-mynet-02肯定也是可以的，这里我们再查看一下tomcat-mynet-01容器的信息会发现他被分配的ip使用的子网确实使我们之前设置的。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128171413.png" alt=""></p>
<div class="tag-plugin note" color="yellow"><div class="body"><p>自定义的网络都已经自动帮我们维护好了ip和容器名的对应关系，因此推荐平时使用自定义网络而不要使用docker0</p></div></div>
<p>同时我们使用自定义网络可以为不同的集群分配不同的自定义网络，保证各个功能模块集群互不干扰的工作，比如现在有一个redis集群和一个mysql集群，为他们分配到不同的自定义网络，那么不同种类的容器就会做到通信隔离，更加安全！</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128172108.png" alt=""></p>
<p>但是两个集群也不能完全不通信呀😂，还是需要有一些容器有连通的（此时使用<code>--link</code>也做不到，因为他们不再同一个网段），因此接下来我们将学习网络连通。</p>
<h3 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h3><p>接下来我们以docker0网络下的<code>tomcat01</code>和<code>tomcat02</code>以及mynet下的<code>tomcat01-mynet-01</code>和<code>tomcat-mynet-02</code>进行演示，首先我们创建<code>tomcat01</code>和<code>tomcat02</code>两个容器，然后尝试用tomcat-mynet-01容器去ping容器tomcat01发现无法实现：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128192720.png" alt=""></p>
<p>因此不同网络下的容器无法通信，但是实际上有时处于不同网络下的两个容器功能上需要进行连接通信，因此我们希望可以允许容器和另一个网络下的某个容器进行连通。首先两个网卡不能直接打通，这样会导致两个子网发生变化，应该是让一个容器和另一个子网的网卡连接即他进入到另一个子网下，也就是类似于一个人加入多个组织，他同时拥有多个网络的分配ip，这样他就可以和另一个子网的容器进行通信了，如下图：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128193232.png" alt=""></p>
<p>这里我们就会用到一个新指令即<code>docker network connect</code>,他的可选参数如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-7-centos ~]# docker network connect --help</span><br><span class="line"></span><br><span class="line">Usage:  docker network connect [OPTIONS] NETWORK CONTAINER</span><br><span class="line"></span><br><span class="line">Connect a container to a network</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --alias strings           Add network-scoped alias for the container</span><br><span class="line">      --driver-opt strings      driver options for the network</span><br><span class="line">      --ip string               IPv4 address (e.g., 172.30.100.104)</span><br><span class="line">      --ip6 string              IPv6 address (e.g., 2001:db8::33)</span><br><span class="line">      --link list               Add link to another container</span><br><span class="line">      --link-local-ip strings   Add a link-local address for the container</span><br></pre></td></tr></table></figure>
<p>现在我们就将容器tomcat01打通加入到mynet网络下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-7-centos ~]# docker inspect tomcat01</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128193745.png" alt=""></p>
<p>配置成功后我们发现正如之前的那个比喻所说，现在这个tomcat01容器同时属于两个网络了，因此他有两个ip分别对应docker0和mynet网络，因此此时tomcat-mynet-01容器可以ping通tomcat01了</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128193942.png" alt=""></p>
<h4 id="思考：此时tomcat01能否使用ping-容器名的形式ping通其他容器？"><a href="#思考：此时tomcat01能否使用ping-容器名的形式ping通其他容器？" class="headerlink" title="思考：此时tomcat01能否使用ping+容器名的形式ping通其他容器？"></a>思考：此时tomcat01能否使用ping+容器名的形式ping通其他容器？</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128194259.png" alt=""></p>
<p>很显然结果应该是tomcat01只能使用ping+容器名的形式连通mynet下的容器，这就好比你假如了A组织和B组织，虽然此时你能与B组织交流了，但是在与A组织下的成员交流时还是要遵循之前A组织的规则，因此tomcat01在和tomcat02连通时还是要遵循docker0网络基于ip的规则，但是在和tomcat-mynet-01和tomcat-mynet-02容器连通时可以基于容器名。</p>
<div class="tag-plugin note" color="yellow"><div class="body"><p>但是如果此时tomcat02也用connect指令加入到了mynet网络下，那么此时tomcat01就可以和tomcat02使用ping+容器名的形式ping通了</p></div></div>
<h2 id="实战：部署redis集群"><a href="#实战：部署redis集群" class="headerlink" title="实战：部署redis集群"></a>实战：部署redis集群</h2><p>这部分博主还没有学习redis，暂时不写了，您可以参考这里学习</p>
<div class="tag-plugin link dis-select"><a class="link-card plain" title="redis集群部署实战" href="https://www.bilibili.com/video/BV1og4y1q7M4?p=38&spm_id_from=pageDriver" target="_blank" rel="external nofollow noopener noreferrer" cardlink autofill="icon"><div class="left"><span class="title">redis集群部署实战</span><span class="cap link fs12">https://www.bilibili.com/video/BV1og4y1q7M4?p=38&spm_id_from=pageDriver</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/link/8f277b4ee0ecd.svg"></div></div></a></div>
<p>如果一个月内博主还没有更新，请@我督促我去学习😂</p>
<h2 id="SingBoot微服务打包Docker镜像"><a href="#SingBoot微服务打包Docker镜像" class="headerlink" title="SingBoot微服务打包Docker镜像"></a>SingBoot微服务打包Docker镜像</h2><p>接下来我们学习一下如何将简单的SpringBoot项目打包成Docker镜像然后部署到服务器上，首先我们打开idea创建一个SpringBoot项目，选择Sping Initializer创建项目然后选择最简单web功能即可，这里我们新建一个Controller包进行测试，里面添加一个HelloController.java文件，内容如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Lang wenchong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/11/28 20:21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello,wenchong😎&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们本地先测试一下，运行以后前往<code>http://localhost:8080/hello</code>查看能够正确返还字符串</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128202631.png" alt=""></p>
<p>成功以后我们开始进行项目的打包，点击右侧Maven栏demo声明周期下的package选项进行打包</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128203035.png" alt=""></p>
<p>然后我们进行DockerFile的编写，首先我们安装一下Docker的高亮插件直接在设置-&gt;插件中搜索Docker安装即可，安装完成以后我们在demo目录下新建一个<code>Dockerfile</code>文件，命名正确且插件安装成功后这个文件的小图标会有一个小鲸鱼，然后我们开始写Dockerfile脚本文件如下</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#引入项目需要的jdk基础环境</span></span><br><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"><span class="comment">#引入项目文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> *.jar /app.jar</span></span><br><span class="line"><span class="comment">#设置及端口</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;--server.port=8080&quot;</span>]</span></span><br><span class="line"><span class="comment">#项目在容器内暴露8080端口上运行</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment">#启动项目</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>然后我们打开xftp将jar包和Dockerfile上传到服务器的<code>/home/idea</code>下，然后我们在这个目录下进行打包，实际上就是运行Dockerfile创建镜像，如下图</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128204308.png" alt=""></p>
<p>这样我们就打包完成了得到一个<code>springboot-project</code>镜像，然后我们运行镜像创建一个容器查看能否完美部署运行，为了方便测试我们将容器端口暴露映射到主机的8081端口上</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128204515.png" alt=""></p>
<p>然后我们在浏览器中输入<code>http://服务器ip:8081/hello</code>即可查看到入口页面</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://langwenchong.gitee.io/figure-bed/20211128204622.png" alt=""></p>
<h3 id="思考：因此我们最终只需要给别人什么文件用来部署上线呢？"><a href="#思考：因此我们最终只需要给别人什么文件用来部署上线呢？" class="headerlink" title="思考：因此我们最终只需要给别人什么文件用来部署上线呢？"></a>思考：因此我们最终只需要给别人什么文件用来部署上线呢？</h3><p>我们发现实际上还是要将项目打包成jar包，然后我们在编辑Dockerfile是引入了这个jar包来构建镜像，因此我们最终创建容器时这个容器会包含有这个项目并且自动部署运行，并且使用FROM引入了需要的jdk环境。因此我们实际上最终只需要给别人发送这个使用Dockerfile构建的镜像即可了，这个别人只需要pull这个镜像然后run创建并启动容器即可，剩下的环境配置容器会自动完成，非常简单！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自此， 我们花费了大约1周的时间入门了Docker，剩下的进阶篇我们以后再更。相较于一周前我们对Docker的懵懂到如今基本掌握Docker应用，细细想来，这一路并不是很艰难，学习的过程并不仅仅充满了汗水与枯燥，实际上也伴随着学习新知识后的充实与快乐，希望你我都能坚持学习，不辜负自己的一片野心😊！</p>

  


  </article>
  
<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">回顾上一篇</div><a href="/wiki/Docker%E7%AC%94%E8%AE%B0/%E9%95%9C%E5%83%8F%E4%B8%8E%E5%8D%B7%E6%8C%82%E8%BD%BD/index.html">镜像与卷挂载</a></div><div class="item" id="next"></div></section></div>

  

  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      快来参与讨论吧
    </section>
    <section class='body cmt-body waline'>
      

<div id="waline_container" class="waline_thread" comment_id="Docker"><svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg></div>

    </section>
  </div>




      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客</span><a href="/">随想录</a><a href="/intro">言堂序</a><a href="/archives">归档册</a></div><div class="sitemap-group"><span class="fs14">笔记</span><a href="/wiki/tags/%E7%AC%AC%E4%B9%9D%E8%89%BA%E6%9C%AF">第九艺术</a><a href="/wiki/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80">计算基础</a><a href="/wiki/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80">语言基础</a><a href="/wiki/tags/%E8%BF%9B%E9%98%B6%E6%8A%80%E8%83%BD">进阶技能</a></div><div class="sitemap-group"><span class="fs14">便笺</span><a href="/notes/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0">科研学习</a><a href="/notes/%E5%BB%BA%E7%AB%99%E5%BF%85%E5%A4%87">建站必备</a><a href="/notes/%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7">建站必备</a></div><div class="sitemap-group"><span class="fs14">更多</span><a target="_blank" rel="noopener" href="https://coolchong.cn">个人主页</a><a target="_blank" rel="noopener" href="https://blog.coolchong.cn/friends.html">友情链接</a></div></div><div class="text"><div class="github-badge">
  <a style="color: #fff"  href="https://coolchong.cn/" target="_blank" title="由 Langwenchong 搭建运营">
    <span class="badge-subject">Built</span><span class="badge-value bg-blue">雨中 @2022-2023</span>
  </a>
  <a style="color: #fff" href="https://www.qiniu.com//" target="_blank" title="静态资源托管于 七牛云" >
    <span class="badge-subject">Powered</span><span class="badge-value bg-orange">七牛云</span>
  </a>
  <a style="color: #fff" href="https://xaoxuu.com/wiki/stellar/" target="_blank" title="站点使用 Stellar 主题" >
    <span class="badge-subject">Theme</span><span class="badge-value bg-brightgreen">Stellar</span>
  </a>
  <a style="color: #fff" href="https://beian.miit.gov.cn/)" target="_blank" title="网站已备案授权开放">
    <span class="badge-subject">Record</span><span class="badge-value bg-red">津ICP备2021009044</span>
  </a>
</div>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.18.5';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function load_comment(){
    if(!document.getElementById("waline_container"))return;
    stellar.loadCSS('https://unpkg.com/@waline/client@2.14.1/dist/waline.css');
    stellar.loadScript('https://unpkg.com/@waline/client@2.14.1/dist/waline.js', {defer:true}).then(function () {
      const el = document.getElementById("waline_container");
      var path = el.getAttribute('comment_id');
      if (!path) {
        path = decodeURI(window.location.pathname);
      }
      Waline.init(Object.assign({"js":"https://unpkg.com/@waline/client@2.14.1/dist/waline.js","css":"https://unpkg.com/@waline/client@2.14.1/dist/waline.css","serverURL":"https://waline.coolchong.cn","commentCount":true,"pageview":false,"emoji":["https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/","https://unpkg.com/@waline/emojis@1.1.0/tw-emoji","https://unpkg.com/@waline/emojis@1.1.0/bilibili","https://unpkg.com/@waline/emojis@1.1.0/alus","https://unpkg.com/@waline/emojis@1.1.0/bmoji"],"locale":{"reactionTitle":null,"placeholder":"任何想法畅所欲言，记得填写邮箱方便及时收到回复哦~"},"reaction":["https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatheart.png","https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatattentionreverse.png","https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatrainbow.png","https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatwave.png","https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/blobcatalt.png","https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/blobcatscared.png"]}, {
        el: '#waline_container',
        path: path,
      }));
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
    console.log('DOM fully loaded and parsed');
    load_comment();
  });

</script>




<!-- inject -->


  </div>
</body>
</html>
